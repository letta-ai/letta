// This file is auto-generated by @hey-api/openapi-ts

/**
 * Action data model.
 */
export type ActionModel = {
  name: string;
  description: string;
  parameters: ActionParametersModel;
  response: ActionResponseModel;
  appName: string;
  appId: string;
  version: string;
  available_versions: Array<string>;
  tags: Array<string>;
  logo?: string | null;
  display_name?: string | null;
  enabled?: boolean;
};

/**
 * Action parameter data models.
 */
export type ActionParametersModel = {
  properties: {
    [key: string]: unknown;
  };
  title: string;
  type: string;
  required?: Array<string> | null;
  examples?: Array<unknown> | null;
};

/**
 * Action response data model.
 */
export type ActionResponseModel = {
  properties: {
    [key: string]: unknown;
  };
  title: string;
  type: string;
  required?: Array<string> | null;
  examples?: Array<unknown> | null;
};

export type AgentEnvironmentVariable = {
  /**
   * The id of the user that made this object.
   */
  created_by_id?: string | null;
  /**
   * The id of the user that made this object.
   */
  last_updated_by_id?: string | null;
  /**
   * The timestamp when the object was created.
   */
  created_at?: string | null;
  /**
   * The timestamp when the object was last updated.
   */
  updated_at?: string | null;
  /**
   * The human-friendly ID of the Agent-env
   */
  id?: string;
  /**
   * The name of the environment variable.
   */
  key: string;
  /**
   * The value of the environment variable.
   */
  value: string;
  /**
   * An optional description of the environment variable.
   */
  description?: string | null;
  /**
   * The ID of the organization this environment variable belongs to.
   */
  organization_id?: string | null;
  /**
   * The ID of the agent this environment variable belongs to.
   */
  agent_id: string;
};

/**
 * Schema for serialized agent file that can be exported to JSON and imported into agent server.
 */
export type AgentFileSchema = {
  /**
   * List of agents in this agent file
   */
  agents: Array<letta__schemas__agent_file__AgentSchema>;
  /**
   * List of groups in this agent file
   */
  groups: Array<GroupSchema>;
  /**
   * List of memory blocks in this agent file
   */
  blocks: Array<BlockSchema>;
  /**
   * List of files in this agent file
   */
  files: Array<FileSchema>;
  /**
   * List of sources in this agent file
   */
  sources: Array<SourceSchema>;
  /**
   * List of tools in this agent file
   */
  tools: Array<letta__schemas__agent_file__ToolSchema>;
  /**
   * List of MCP servers in this agent file
   */
  mcp_servers: Array<MCPServerSchema>;
  /**
   * Metadata for this agent file, including revision_id and other export information.
   */
  metadata?: {
    [key: string]: string;
  };
  /**
   * The timestamp when the object was created.
   */
  created_at?: string | null;
};

/**
 * Representation of an agent's state. This is the state of the agent at a given time, and is persisted in the DB backend. The state has all the information needed to recreate a persisted agent.
 *
 * Parameters:
 * id (str): The unique identifier of the agent.
 * name (str): The name of the agent (must be unique to the user).
 * created_at (datetime): The datetime the agent was created.
 * message_ids (List[str]): The ids of the messages in the agent's in-context memory.
 * memory (Memory): The in-context memory of the agent.
 * tools (List[str]): The tools used by the agent. This includes any memory editing functions specified in `memory`.
 * system (str): The system prompt used by the agent.
 * llm_config (LLMConfig): The LLM configuration used by the agent.
 * embedding_config (EmbeddingConfig): The embedding configuration used by the agent.
 */
export type AgentState = {
  /**
   * The id of the user that made this object.
   */
  created_by_id?: string | null;
  /**
   * The id of the user that made this object.
   */
  last_updated_by_id?: string | null;
  /**
   * The timestamp when the object was created.
   */
  created_at?: string | null;
  /**
   * The timestamp when the object was last updated.
   */
  updated_at?: string | null;
  /**
   * The id of the agent. Assigned by the database.
   */
  id: string;
  /**
   * The name of the agent.
   */
  name: string;
  /**
   * The list of tool rules.
   */
  tool_rules?: Array<
    | ChildToolRule
    | InitToolRule
    | TerminalToolRule
    | ConditionalToolRule
    | ContinueToolRule
    | RequiredBeforeExitToolRule
    | MaxCountPerStepToolRule
    | ParentToolRule
  > | null;
  /**
   * The ids of the messages in the agent's in-context memory.
   */
  message_ids?: Array<string> | null;
  /**
   * The system prompt used by the agent.
   */
  system: string;
  /**
   * The type of agent.
   */
  agent_type: AgentType;
  /**
   * The LLM configuration used by the agent.
   */
  llm_config: LLMConfig;
  /**
   * The embedding configuration used by the agent.
   */
  embedding_config: EmbeddingConfig;
  /**
   * The response format used by the agent when returning from `send_message`.
   */
  response_format?:
    | TextResponseFormat
    | JsonSchemaResponseFormat
    | JsonObjectResponseFormat
    | null;
  /**
   * The description of the agent.
   */
  description?: string | null;
  /**
   * The metadata of the agent.
   */
  metadata?: {
    [key: string]: unknown;
  } | null;
  /**
   * The in-context memory of the agent.
   */
  memory: Memory;
  /**
   * The tools used by the agent.
   */
  tools: Array<Tool>;
  /**
   * The sources used by the agent.
   */
  sources: Array<Source>;
  /**
   * The tags associated with the agent.
   */
  tags: Array<string>;
  /**
   * The environment variables for tool execution specific to this agent.
   */
  tool_exec_environment_variables?: Array<AgentEnvironmentVariable>;
  /**
   * The id of the project the agent belongs to.
   */
  project_id?: string | null;
  /**
   * The id of the template the agent belongs to.
   */
  template_id?: string | null;
  /**
   * The base template id of the agent.
   */
  base_template_id?: string | null;
  /**
   * The ids of the identities associated with this agent.
   */
  identity_ids?: Array<string>;
  /**
   * If set to True, the agent will not remember previous messages (though the agent will still retain state via core memory blocks and archival/recall memory). Not recommended unless you have an advanced use case.
   */
  message_buffer_autoclear?: boolean;
  /**
   * If set to True, memory management will move to a background agent thread.
   */
  enable_sleeptime?: boolean | null;
  /**
   * The multi-agent group that this agent manages
   */
  multi_agent_group?: Group | null;
  /**
   * The timestamp when the agent last completed a run.
   */
  last_run_completion?: string | null;
  /**
   * The duration in milliseconds of the agent's last run.
   */
  last_run_duration_ms?: number | null;
  /**
   * The timezone of the agent (IANA format).
   */
  timezone?: string | null;
  /**
   * Maximum number of files that can be open at once for this agent. Setting this too high may exceed the context window, which will break the agent.
   */
  max_files_open?: number | null;
  /**
   * The per-file view window character limit for this agent. Setting this too high may exceed the context window, which will break the agent.
   */
  per_file_view_window_char_limit?: number | null;
  /**
   * If set to True, the agent will be hidden.
   */
  hidden?: boolean | null;
};

/**
 * Enum to represent the type of agent.
 */
export type AgentType =
  | 'memgpt_agent'
  | 'memgpt_v2_agent'
  | 'react_agent'
  | 'workflow_agent'
  | 'split_thread_agent'
  | 'sleeptime_agent'
  | 'voice_convo_agent'
  | 'voice_sleeptime_agent';

/**
 * App authenticatio scheme.
 */
export type AppAuthScheme = {
  scheme_name: string;
  auth_mode:
    | 'OAUTH2'
    | 'OAUTH1'
    | 'API_KEY'
    | 'BASIC'
    | 'BEARER_TOKEN'
    | 'BASIC_WITH_JWT'
    | 'GOOGLE_SERVICE_ACCOUNT'
    | 'GOOGLEADS_AUTH'
    | 'NO_AUTH'
    | 'CALCOM_AUTH';
  fields: Array<AuthSchemeField>;
  proxy?: {
    [key: string]: unknown;
  } | null;
  authorization_url?: string | null;
  token_url?: string | null;
  default_scopes?: Array<unknown> | null;
  token_response_metadata?: Array<unknown> | null;
  client_id?: string | null;
  client_secret?: string | null;
};

export type auth_mode =
  | 'OAUTH2'
  | 'OAUTH1'
  | 'API_KEY'
  | 'BASIC'
  | 'BEARER_TOKEN'
  | 'BASIC_WITH_JWT'
  | 'GOOGLE_SERVICE_ACCOUNT'
  | 'GOOGLEADS_AUTH'
  | 'NO_AUTH'
  | 'CALCOM_AUTH';

/**
 * App data model.
 */
export type AppModel = {
  name: string;
  key: string;
  appId: string;
  description: string;
  categories: Array<string>;
  meta: {
    [key: string]: unknown;
  };
  logo?: string | null;
  docs?: string | null;
  group?: string | null;
  status?: string | null;
  enabled?: boolean;
  no_auth?: boolean;
  auth_schemes?: Array<AppAuthScheme> | null;
  testConnectors?: Array<{
    [key: string]: unknown;
  }> | null;
  documentation_doc_text?: string | null;
  configuration_docs_text?: string | null;
};

/**
 * A message sent by the LLM in response to user input. Used in the LLM context.
 *
 * Args:
 * id (str): The ID of the message
 * date (datetime): The date the message was created in ISO format
 * name (Optional[str]): The name of the sender of the message
 * content (Union[str, List[LettaAssistantMessageContentUnion]]): The message content sent by the agent (can be a string or an array of content parts)
 */
export type AssistantMessage = {
  id: string;
  date: string;
  name?: string | null;
  /**
   * The type of the message.
   */
  message_type?: 'assistant_message';
  otid?: string | null;
  sender_id?: string | null;
  step_id?: string | null;
  is_err?: boolean | null;
  /**
   * The message content sent by the agent (can be a string or an array of content parts)
   */
  content: Array<LettaAssistantMessageContentUnion> | string;
};

export type Audio = {
  id: string;
};

export type AuthRequest = {
  /**
   * Admin password provided when starting the Letta server
   */
  password?: string;
};

export type AuthResponse = {
  /**
   * UUID of the user
   */
  uuid: string;
  /**
   * Whether the user is an admin
   */
  is_admin?: boolean | null;
};

/**
 * Auth scheme field.
 */
export type AuthSchemeField = {
  name: string;
  display_name?: string | null;
  description: string;
  type: string;
  default?: string | null;
  required?: boolean;
  expected_from_customer?: boolean;
  get_current_user_endpoint?: string | null;
};

export type Base64Image = {
  /**
   * The source type for the image.
   */
  type?: 'base64';
  /**
   * The media type for the image.
   */
  media_type: string;
  /**
   * The base64 encoded image data.
   */
  data: string;
  /**
   * What level of detail to use when processing and understanding the image (low, high, or auto to let the model decide)
   */
  detail?: string | null;
};

export type BaseToolRuleSchema = {
  tool_name: string;
  type: string;
};

export type BatchJob = {
  /**
   * The id of the user that made this object.
   */
  created_by_id?: string | null;
  /**
   * The id of the user that made this object.
   */
  last_updated_by_id?: string | null;
  /**
   * The timestamp when the object was created.
   */
  created_at?: string | null;
  /**
   * The timestamp when the object was last updated.
   */
  updated_at?: string | null;
  /**
   * The status of the job.
   */
  status?: JobStatus;
  /**
   * The unix timestamp of when the job was completed.
   */
  completed_at?: string | null;
  /**
   * The metadata of the job.
   */
  metadata?: {
    [key: string]: unknown;
  } | null;
  job_type?: JobType;
  /**
   * If set, POST to this URL when the job completes.
   */
  callback_url?: string | null;
  /**
   * Timestamp when the callback was last attempted.
   */
  callback_sent_at?: string | null;
  /**
   * HTTP status code returned by the callback endpoint.
   */
  callback_status_code?: number | null;
  /**
   * Optional error message from attempting to POST the callback endpoint.
   */
  callback_error?: string | null;
  /**
   * Time to first token for a run in nanoseconds
   */
  ttft_ns?: number | null;
  /**
   * Total run duration in nanoseconds
   */
  total_duration_ns?: number | null;
  /**
   * The human-friendly ID of the Job
   */
  id?: string;
  /**
   * The unique identifier of the user associated with the job.
   */
  user_id?: string | null;
};

/**
 * A Block represents a reserved section of the LLM's context window which is editable. `Block` objects contained in the `Memory` object, which is able to edit the Block values.
 *
 * Parameters:
 * label (str): The label of the block (e.g. 'human', 'persona'). This defines a category for the block.
 * value (str): The value of the block. This is the string that is represented in the context window.
 * limit (int): The character limit of the block.
 * is_template (bool): Whether the block is a template (e.g. saved human/persona options). Non-template blocks are not stored in the database and are ephemeral, while templated blocks are stored in the database.
 * label (str): The label of the block (e.g. 'human', 'persona'). This defines a category for the block.
 * template_name (str): The name of the block template (if it is a template).
 * description (str): Description of the block.
 * metadata (Dict): Metadata of the block.
 * user_id (str): The unique identifier of the user associated with the block.
 */
export type Block = {
  /**
   * Value of the block.
   */
  value: string;
  /**
   * Character limit of the block.
   */
  limit?: number;
  /**
   * The associated project id.
   */
  project_id?: string | null;
  /**
   * Name of the block if it is a template.
   */
  name?: string | null;
  /**
   * Whether the block is a template (e.g. saved human/persona options).
   */
  is_template?: boolean;
  /**
   * Preserve the block on template migration.
   */
  preserve_on_migration?: boolean | null;
  /**
   * Label of the block (e.g. 'human', 'persona') in the context window.
   */
  label?: string | null;
  /**
   * Whether the agent has read-only access to the block.
   */
  read_only?: boolean;
  /**
   * Description of the block.
   */
  description?: string | null;
  /**
   * Metadata of the block.
   */
  metadata?: {
    [key: string]: unknown;
  } | null;
  /**
   * The human-friendly ID of the Block
   */
  id?: string;
  /**
   * The id of the user that made this Block.
   */
  created_by_id?: string | null;
  /**
   * The id of the user that last updated this Block.
   */
  last_updated_by_id?: string | null;
};

/**
 * Block with human-readable ID for agent file
 */
export type BlockSchema = {
  /**
   * Value of the block.
   */
  value: string;
  /**
   * Character limit of the block.
   */
  limit?: number;
  /**
   * The associated project id.
   */
  project_id?: string | null;
  /**
   * Name of the block if it is a template.
   */
  name?: string | null;
  is_template?: boolean;
  /**
   * Preserve the block on template migration.
   */
  preserve_on_migration?: boolean | null;
  /**
   * Label of the block.
   */
  label: string;
  /**
   * Whether the agent has read-only access to the block.
   */
  read_only?: boolean;
  /**
   * Description of the block.
   */
  description?: string | null;
  /**
   * Metadata of the block.
   */
  metadata?: {
    [key: string]: unknown;
  } | null;
  /**
   * Human-readable identifier for this block in the file
   */
  id: string;
};

/**
 * Update a block
 */
export type BlockUpdate = {
  /**
   * Value of the block.
   */
  value?: string | null;
  /**
   * Character limit of the block.
   */
  limit?: number | null;
  /**
   * The associated project id.
   */
  project_id?: string | null;
  /**
   * Name of the block if it is a template.
   */
  name?: string | null;
  /**
   * Whether the block is a template (e.g. saved human/persona options).
   */
  is_template?: boolean;
  /**
   * Preserve the block on template migration.
   */
  preserve_on_migration?: boolean | null;
  /**
   * Label of the block (e.g. 'human', 'persona') in the context window.
   */
  label?: string | null;
  /**
   * Whether the agent has read-only access to the block.
   */
  read_only?: boolean;
  /**
   * Description of the block.
   */
  description?: string | null;
  /**
   * Metadata of the block.
   */
  metadata?: {
    [key: string]: unknown;
  } | null;
};

export type Body_export_agent_serialized = {
  spec?: AgentFileSchema | null;
  legacy_spec?: letta__serialize_schemas__pydantic_agent_schema__AgentSchema | null;
};

export type Body_import_agent_serialized = {
  file: Blob | File;
  /**
   * If set to True, appends "_copy" to the end of the agent name.
   */
  append_copy_suffix?: boolean;
  /**
   * If set to True, existing tools can get their source code overwritten by the uploaded tool definitions. Note that Letta core tools can never be updated externally.
   */
  override_existing_tools?: boolean;
  /**
   * The project ID to associate the uploaded agent with.
   */
  project_id?: string | null;
  /**
   * If set to True, strips all messages from the agent before importing.
   */
  strip_messages?: boolean;
  /**
   * Environment variables to pass to the agent for tool execution.
   */
  env_vars?: {
    [key: string]: unknown;
  } | null;
};

export type Body_upload_file_to_folder = {
  file: Blob | File;
};

export type Body_upload_file_to_source = {
  file: Blob | File;
};

export type ChatCompletionAssistantMessageParam = {
  role: 'assistant';
  audio?: Audio | null;
  content?:
    | string
    | Array<
        | ChatCompletionContentPartTextParam
        | ChatCompletionContentPartRefusalParam
      >
    | null;
  function_call?: FunctionCall | null;
  name?: string;
  refusal?: string | null;
  tool_calls?: Array<ChatCompletionMessageToolCallParam>;
};

export type ChatCompletionAudioParam = {
  format: 'wav' | 'aac' | 'mp3' | 'flac' | 'opus' | 'pcm16';
  voice:
    | string
    | 'alloy'
    | 'ash'
    | 'ballad'
    | 'coral'
    | 'echo'
    | 'sage'
    | 'shimmer'
    | 'verse';
};

export type format = 'wav' | 'aac' | 'mp3' | 'flac' | 'opus' | 'pcm16';

export type ChatCompletionContentPartImageParam = {
  image_url: ImageURL;
  type: 'image_url';
};

export type ChatCompletionContentPartInputAudioParam = {
  input_audio: InputAudio;
  type: 'input_audio';
};

export type ChatCompletionContentPartRefusalParam = {
  refusal: string;
  type: 'refusal';
};

export type ChatCompletionContentPartTextParam = {
  text: string;
  type: 'text';
};

export type ChatCompletionDeveloperMessageParam = {
  content: string | Array<ChatCompletionContentPartTextParam>;
  role: 'developer';
  name?: string;
};

export type ChatCompletionFunctionCallOptionParam = {
  name: string;
};

export type ChatCompletionFunctionMessageParam = {
  content: string | null;
  name: string;
  role: 'function';
};

export type ChatCompletionMessageToolCall = {
  id: string;
  function: Function_Output;
  type: 'function';
  [key: string]: unknown | string | Function_Output | 'function';
};

export type ChatCompletionMessageToolCallParam = {
  id: string;
  function: openai__types__chat__chat_completion_message_tool_call_param__Function;
  type: 'function';
};

export type ChatCompletionNamedToolChoiceParam = {
  function: openai__types__chat__chat_completion_named_tool_choice_param__Function;
  type: 'function';
};

export type ChatCompletionPredictionContentParam = {
  content: string | Array<ChatCompletionContentPartTextParam>;
  type: 'content';
};

export type ChatCompletionStreamOptionsParam = {
  include_usage?: boolean;
};

export type ChatCompletionSystemMessageParam = {
  content: string | Array<ChatCompletionContentPartTextParam>;
  role: 'system';
  name?: string;
};

export type ChatCompletionToolMessageParam = {
  content: string | Array<ChatCompletionContentPartTextParam>;
  role: 'tool';
  tool_call_id: string;
};

export type ChatCompletionToolParam = {
  function: FunctionDefinition_Input;
  type: 'function';
};

export type ChatCompletionUserMessageParam = {
  content:
    | string
    | Array<
        | ChatCompletionContentPartTextParam
        | ChatCompletionContentPartImageParam
        | ChatCompletionContentPartInputAudioParam
        | File
      >;
  role: 'user';
  name?: string;
};

/**
 * A ToolRule represents a tool that can be invoked by the agent.
 */
export type ChildToolRule = {
  /**
   * The name of the tool. Must exist in the database for the user's organization.
   */
  tool_name: string;
  type?: 'constrain_child_tools';
  /**
   * Optional Jinja2 template for generating agent prompt about this tool rule.
   */
  prompt_template?: string | null;
  /**
   * The children tools that can be invoked.
   */
  children: Array<string>;
};

export type ChildToolRuleSchema = {
  tool_name: string;
  type: string;
  children: Array<string>;
};

export type CodeInput = {
  /**
   * Python source code to parse for JSON schema
   */
  code: string;
};

export type CompletionCreateParamsNonStreaming = {
  messages: Array<
    | ChatCompletionDeveloperMessageParam
    | ChatCompletionSystemMessageParam
    | ChatCompletionUserMessageParam
    | ChatCompletionAssistantMessageParam
    | ChatCompletionToolMessageParam
    | ChatCompletionFunctionMessageParam
  >;
  model:
    | string
    | 'gpt-4.1'
    | 'gpt-4.1-mini'
    | 'gpt-4.1-nano'
    | 'gpt-4.1-2025-04-14'
    | 'gpt-4.1-mini-2025-04-14'
    | 'gpt-4.1-nano-2025-04-14'
    | 'o4-mini'
    | 'o4-mini-2025-04-16'
    | 'o3'
    | 'o3-2025-04-16'
    | 'o3-mini'
    | 'o3-mini-2025-01-31'
    | 'o1'
    | 'o1-2024-12-17'
    | 'o1-preview'
    | 'o1-preview-2024-09-12'
    | 'o1-mini'
    | 'o1-mini-2024-09-12'
    | 'gpt-4o'
    | 'gpt-4o-2024-11-20'
    | 'gpt-4o-2024-08-06'
    | 'gpt-4o-2024-05-13'
    | 'gpt-4o-audio-preview'
    | 'gpt-4o-audio-preview-2024-10-01'
    | 'gpt-4o-audio-preview-2024-12-17'
    | 'gpt-4o-audio-preview-2025-06-03'
    | 'gpt-4o-mini-audio-preview'
    | 'gpt-4o-mini-audio-preview-2024-12-17'
    | 'gpt-4o-search-preview'
    | 'gpt-4o-mini-search-preview'
    | 'gpt-4o-search-preview-2025-03-11'
    | 'gpt-4o-mini-search-preview-2025-03-11'
    | 'chatgpt-4o-latest'
    | 'codex-mini-latest'
    | 'gpt-4o-mini'
    | 'gpt-4o-mini-2024-07-18'
    | 'gpt-4-turbo'
    | 'gpt-4-turbo-2024-04-09'
    | 'gpt-4-0125-preview'
    | 'gpt-4-turbo-preview'
    | 'gpt-4-1106-preview'
    | 'gpt-4-vision-preview'
    | 'gpt-4'
    | 'gpt-4-0314'
    | 'gpt-4-0613'
    | 'gpt-4-32k'
    | 'gpt-4-32k-0314'
    | 'gpt-4-32k-0613'
    | 'gpt-3.5-turbo'
    | 'gpt-3.5-turbo-16k'
    | 'gpt-3.5-turbo-0301'
    | 'gpt-3.5-turbo-0613'
    | 'gpt-3.5-turbo-1106'
    | 'gpt-3.5-turbo-0125'
    | 'gpt-3.5-turbo-16k-0613';
  audio?: ChatCompletionAudioParam | null;
  frequency_penalty?: number | null;
  function_call?: 'none' | 'auto' | ChatCompletionFunctionCallOptionParam;
  functions?: Array<openai__types__chat__completion_create_params__Function>;
  logit_bias?: {
    [key: string]: number;
  } | null;
  logprobs?: boolean | null;
  max_completion_tokens?: number | null;
  max_tokens?: number | null;
  metadata?: {
    [key: string]: string;
  } | null;
  modalities?: Array<'text' | 'audio'> | null;
  n?: number | null;
  parallel_tool_calls?: boolean;
  prediction?: ChatCompletionPredictionContentParam | null;
  presence_penalty?: number | null;
  prompt_cache_key?: string;
  reasoning_effort?: 'low' | 'medium' | 'high' | null;
  response_format?:
    | ResponseFormatText
    | ResponseFormatJSONSchema
    | ResponseFormatJSONObject;
  safety_identifier?: string;
  seed?: number | null;
  service_tier?: 'auto' | 'default' | 'flex' | 'scale' | 'priority' | null;
  stop?: string | Array<string> | null;
  store?: boolean | null;
  stream_options?: ChatCompletionStreamOptionsParam | null;
  temperature?: number | null;
  tool_choice?:
    | 'none'
    | 'auto'
    | 'required'
    | ChatCompletionNamedToolChoiceParam;
  tools?: Array<ChatCompletionToolParam>;
  top_logprobs?: number | null;
  top_p?: number | null;
  user?: string;
  web_search_options?: WebSearchOptions;
  stream?: false | null;
};

export type CompletionCreateParamsStreaming = {
  messages: Array<
    | ChatCompletionDeveloperMessageParam
    | ChatCompletionSystemMessageParam
    | ChatCompletionUserMessageParam
    | ChatCompletionAssistantMessageParam
    | ChatCompletionToolMessageParam
    | ChatCompletionFunctionMessageParam
  >;
  model:
    | string
    | 'gpt-4.1'
    | 'gpt-4.1-mini'
    | 'gpt-4.1-nano'
    | 'gpt-4.1-2025-04-14'
    | 'gpt-4.1-mini-2025-04-14'
    | 'gpt-4.1-nano-2025-04-14'
    | 'o4-mini'
    | 'o4-mini-2025-04-16'
    | 'o3'
    | 'o3-2025-04-16'
    | 'o3-mini'
    | 'o3-mini-2025-01-31'
    | 'o1'
    | 'o1-2024-12-17'
    | 'o1-preview'
    | 'o1-preview-2024-09-12'
    | 'o1-mini'
    | 'o1-mini-2024-09-12'
    | 'gpt-4o'
    | 'gpt-4o-2024-11-20'
    | 'gpt-4o-2024-08-06'
    | 'gpt-4o-2024-05-13'
    | 'gpt-4o-audio-preview'
    | 'gpt-4o-audio-preview-2024-10-01'
    | 'gpt-4o-audio-preview-2024-12-17'
    | 'gpt-4o-audio-preview-2025-06-03'
    | 'gpt-4o-mini-audio-preview'
    | 'gpt-4o-mini-audio-preview-2024-12-17'
    | 'gpt-4o-search-preview'
    | 'gpt-4o-mini-search-preview'
    | 'gpt-4o-search-preview-2025-03-11'
    | 'gpt-4o-mini-search-preview-2025-03-11'
    | 'chatgpt-4o-latest'
    | 'codex-mini-latest'
    | 'gpt-4o-mini'
    | 'gpt-4o-mini-2024-07-18'
    | 'gpt-4-turbo'
    | 'gpt-4-turbo-2024-04-09'
    | 'gpt-4-0125-preview'
    | 'gpt-4-turbo-preview'
    | 'gpt-4-1106-preview'
    | 'gpt-4-vision-preview'
    | 'gpt-4'
    | 'gpt-4-0314'
    | 'gpt-4-0613'
    | 'gpt-4-32k'
    | 'gpt-4-32k-0314'
    | 'gpt-4-32k-0613'
    | 'gpt-3.5-turbo'
    | 'gpt-3.5-turbo-16k'
    | 'gpt-3.5-turbo-0301'
    | 'gpt-3.5-turbo-0613'
    | 'gpt-3.5-turbo-1106'
    | 'gpt-3.5-turbo-0125'
    | 'gpt-3.5-turbo-16k-0613';
  audio?: ChatCompletionAudioParam | null;
  frequency_penalty?: number | null;
  function_call?: 'none' | 'auto' | ChatCompletionFunctionCallOptionParam;
  functions?: Array<openai__types__chat__completion_create_params__Function>;
  logit_bias?: {
    [key: string]: number;
  } | null;
  logprobs?: boolean | null;
  max_completion_tokens?: number | null;
  max_tokens?: number | null;
  metadata?: {
    [key: string]: string;
  } | null;
  modalities?: Array<'text' | 'audio'> | null;
  n?: number | null;
  parallel_tool_calls?: boolean;
  prediction?: ChatCompletionPredictionContentParam | null;
  presence_penalty?: number | null;
  prompt_cache_key?: string;
  reasoning_effort?: 'low' | 'medium' | 'high' | null;
  response_format?:
    | ResponseFormatText
    | ResponseFormatJSONSchema
    | ResponseFormatJSONObject;
  safety_identifier?: string;
  seed?: number | null;
  service_tier?: 'auto' | 'default' | 'flex' | 'scale' | 'priority' | null;
  stop?: string | Array<string> | null;
  store?: boolean | null;
  stream_options?: ChatCompletionStreamOptionsParam | null;
  temperature?: number | null;
  tool_choice?:
    | 'none'
    | 'auto'
    | 'required'
    | ChatCompletionNamedToolChoiceParam;
  tools?: Array<ChatCompletionToolParam>;
  top_logprobs?: number | null;
  top_p?: number | null;
  user?: string;
  web_search_options?: WebSearchOptions;
  stream: true;
};

/**
 * A ToolRule that conditionally maps to different child tools based on the output.
 */
export type ConditionalToolRule = {
  /**
   * The name of the tool. Must exist in the database for the user's organization.
   */
  tool_name: string;
  type?: 'conditional';
  /**
   * Optional Jinja2 template for generating agent prompt about this tool rule.
   */
  prompt_template?: string | null;
  /**
   * The default child tool to be called. If None, any tool can be called.
   */
  default_child?: string | null;
  /**
   * The output case to check for mapping
   */
  child_output_mapping: {
    [key: string]: string;
  };
  /**
   * Whether to throw an error when output doesn't match any case
   */
  require_output_mapping?: boolean;
};

export type ConditionalToolRuleSchema = {
  tool_name: string;
  type: string;
  default_child: string | null;
  child_output_mapping: {
    [key: string]: string;
  };
  require_output_mapping: boolean;
};

/**
 * Overview of the context window, including the number of messages and tokens.
 */
export type ContextWindowOverview = {
  /**
   * The maximum amount of tokens the context window can hold.
   */
  context_window_size_max: number;
  /**
   * The current number of tokens in the context window.
   */
  context_window_size_current: number;
  /**
   * The number of messages in the context window.
   */
  num_messages: number;
  /**
   * The number of messages in the archival memory.
   */
  num_archival_memory: number;
  /**
   * The number of messages in the recall memory.
   */
  num_recall_memory: number;
  /**
   * The number of tokens in the external memory summary (archival + recall metadata).
   */
  num_tokens_external_memory_summary: number;
  /**
   * The metadata summary of the external memory sources (archival + recall metadata).
   */
  external_memory_summary: string;
  /**
   * The number of tokens in the system prompt.
   */
  num_tokens_system: number;
  /**
   * The content of the system prompt.
   */
  system_prompt: string;
  /**
   * The number of tokens in the core memory.
   */
  num_tokens_core_memory: number;
  /**
   * The content of the core memory.
   */
  core_memory: string;
  /**
   * The number of tokens in the summary memory.
   */
  num_tokens_summary_memory: number;
  /**
   * The content of the summary memory.
   */
  summary_memory?: string | null;
  /**
   * The number of tokens in the functions definitions.
   */
  num_tokens_functions_definitions: number;
  /**
   * The content of the functions definitions.
   */
  functions_definitions: Array<FunctionTool> | null;
  /**
   * The number of tokens in the messages list.
   */
  num_tokens_messages: number;
  /**
   * The messages in the context window.
   */
  messages: Array<Message>;
};

/**
 * Represents a tool rule configuration where if this tool gets called, it must continue the agent loop.
 */
export type ContinueToolRule = {
  /**
   * The name of the tool. Must exist in the database for the user's organization.
   */
  tool_name: string;
  type?: 'continue_loop';
  /**
   * Optional Jinja2 template for generating agent prompt about this tool rule.
   */
  prompt_template?: string | null;
};

export type CoreMemoryBlockSchema = {
  created_at: string;
  description: string | null;
  is_template: boolean;
  label: string;
  limit: number;
  metadata_?: {
    [key: string]: unknown;
  } | null;
  template_name: string | null;
  updated_at: string;
  value: string;
};

/**
 * CreateAgent model specifically for POST request body, excluding user_id which comes from headers
 */
export type CreateAgentRequest = {
  /**
   * The name of the agent.
   */
  name?: string;
  /**
   * The blocks to create in the agent's in-context memory.
   */
  memory_blocks?: Array<CreateBlock> | null;
  /**
   * The tools used by the agent.
   */
  tools?: Array<string> | null;
  /**
   * The ids of the tools used by the agent.
   */
  tool_ids?: Array<string> | null;
  /**
   * The ids of the sources used by the agent.
   */
  source_ids?: Array<string> | null;
  /**
   * The ids of the blocks used by the agent.
   */
  block_ids?: Array<string> | null;
  /**
   * The tool rules governing the agent.
   */
  tool_rules?: Array<
    | ChildToolRule
    | InitToolRule
    | TerminalToolRule
    | ConditionalToolRule
    | ContinueToolRule
    | RequiredBeforeExitToolRule
    | MaxCountPerStepToolRule
    | ParentToolRule
  > | null;
  /**
   * The tags associated with the agent.
   */
  tags?: Array<string> | null;
  /**
   * The system prompt used by the agent.
   */
  system?: string | null;
  /**
   * The type of agent.
   */
  agent_type?: AgentType;
  /**
   * The LLM configuration used by the agent.
   */
  llm_config?: LLMConfig | null;
  /**
   * The embedding configuration used by the agent.
   */
  embedding_config?: EmbeddingConfig | null;
  /**
   * The initial set of messages to put in the agent's in-context memory.
   */
  initial_message_sequence?: Array<MessageCreate> | null;
  /**
   * If true, attaches the Letta core tools (e.g. core_memory related functions).
   */
  include_base_tools?: boolean;
  /**
   * If true, attaches the Letta multi-agent tools (e.g. sending a message to another agent).
   */
  include_multi_agent_tools?: boolean;
  /**
   * If true, attaches the Letta base tool rules (e.g. deny all tools not explicitly allowed).
   */
  include_base_tool_rules?: boolean | null;
  /**
   * If true, automatically creates and attaches a default data source for this agent.
   */
  include_default_source?: boolean;
  /**
   * The description of the agent.
   */
  description?: string | null;
  /**
   * The metadata of the agent.
   */
  metadata?: {
    [key: string]: unknown;
  } | null;
  /**
   * The LLM configuration handle used by the agent, specified in the format provider/model-name, as an alternative to specifying llm_config.
   */
  model?: string | null;
  /**
   * The embedding configuration handle used by the agent, specified in the format provider/model-name.
   */
  embedding?: string | null;
  /**
   * The context window limit used by the agent.
   */
  context_window_limit?: number | null;
  /**
   * The embedding chunk size used by the agent.
   */
  embedding_chunk_size?: number | null;
  /**
   * The maximum number of tokens to generate, including reasoning step. If not set, the model will use its default value.
   */
  max_tokens?: number | null;
  /**
   * The maximum number of tokens to generate for reasoning step. If not set, the model will use its default value.
   */
  max_reasoning_tokens?: number | null;
  /**
   * Whether to enable internal extended thinking step for a reasoner model.
   */
  enable_reasoner?: boolean | null;
  /**
   * Whether to enable reasoning for this agent.
   */
  reasoning?: boolean | null;
  /**
   * The template id used to configure the agent
   */
  from_template?: string | null;
  /**
   * Whether the agent is a template
   */
  template?: boolean;
  /**
   * Deprecated: Project should now be passed via the X-Project header instead of in the request body. If using the sdk, this can be done via the new x_project field below.
   * @deprecated
   */
  project?: string | null;
  /**
   * The environment variables for tool execution specific to this agent.
   */
  tool_exec_environment_variables?: {
    [key: string]: string;
  } | null;
  /**
   * The variables that should be set for the agent.
   */
  memory_variables?: {
    [key: string]: string;
  } | null;
  /**
   * The id of the project the agent belongs to.
   */
  project_id?: string | null;
  /**
   * The id of the template the agent belongs to.
   */
  template_id?: string | null;
  /**
   * The base template id of the agent.
   */
  base_template_id?: string | null;
  /**
   * The ids of the identities associated with this agent.
   */
  identity_ids?: Array<string> | null;
  /**
   * If set to True, the agent will not remember previous messages (though the agent will still retain state via core memory blocks and archival/recall memory). Not recommended unless you have an advanced use case.
   */
  message_buffer_autoclear?: boolean;
  /**
   * If set to True, memory management will move to a background agent thread.
   */
  enable_sleeptime?: boolean | null;
  /**
   * The response format for the agent.
   */
  response_format?:
    | TextResponseFormat
    | JsonSchemaResponseFormat
    | JsonObjectResponseFormat
    | null;
  /**
   * The timezone of the agent (IANA format).
   */
  timezone?: string | null;
  /**
   * Maximum number of files that can be open at once for this agent. Setting this too high may exceed the context window, which will break the agent.
   */
  max_files_open?: number | null;
  /**
   * The per-file view window character limit for this agent. Setting this too high may exceed the context window, which will break the agent.
   */
  per_file_view_window_char_limit?: number | null;
  /**
   * If set to True, the agent will be hidden.
   */
  hidden?: boolean | null;
  actor_id?: string | null;
};

export type CreateArchivalMemory = {
  /**
   * Text to write to archival memory.
   */
  text: string;
};

export type CreateBatch = {
  /**
   * List of requests to be processed in batch.
   */
  requests: Array<LettaBatchRequest>;
  /**
   * Optional URL to call via POST when the batch completes. The callback payload will be a JSON object with the following fields: {'job_id': string, 'status': string, 'completed_at': string}. Where 'job_id' is the unique batch job identifier, 'status' is the final batch status (e.g., 'completed', 'failed'), and 'completed_at' is an ISO 8601 timestamp indicating when the batch job completed.
   */
  callback_url?: string | null;
};

/**
 * Create a block
 */
export type CreateBlock = {
  /**
   * Value of the block.
   */
  value: string;
  /**
   * Character limit of the block.
   */
  limit?: number;
  /**
   * The associated project id.
   */
  project_id?: string | null;
  /**
   * Name of the block if it is a template.
   */
  name?: string | null;
  is_template?: boolean;
  /**
   * Preserve the block on template migration.
   */
  preserve_on_migration?: boolean | null;
  /**
   * Label of the block.
   */
  label: string;
  /**
   * Whether the agent has read-only access to the block.
   */
  read_only?: boolean;
  /**
   * Description of the block.
   */
  description?: string | null;
  /**
   * Metadata of the block.
   */
  metadata?: {
    [key: string]: unknown;
  } | null;
};

/**
 * How to handle duplicate filenames when uploading files
 */
export type DuplicateFileHandling = 'skip' | 'error' | 'suffix';

export type DynamicManager = {
  manager_type?: 'dynamic';
  manager_agent_id: string;
  termination_token?: string | null;
  max_turns?: number | null;
};

export type DynamicManagerUpdate = {
  manager_type?: 'dynamic';
  manager_agent_id?: string | null;
  termination_token?: string | null;
  max_turns?: number | null;
};

export type E2BSandboxConfig = {
  /**
   * Time limit for the sandbox (in seconds).
   */
  timeout?: number;
  /**
   * The E2B template id (docker image).
   */
  template?: string | null;
  /**
   * A list of pip packages to install on the E2B Sandbox
   */
  pip_requirements?: Array<string> | null;
};

/**
 * Configuration for embedding model connection and processing parameters.
 */
export type EmbeddingConfig = {
  /**
   * The endpoint type for the model.
   */
  embedding_endpoint_type:
    | 'openai'
    | 'anthropic'
    | 'bedrock'
    | 'cohere'
    | 'google_ai'
    | 'google_vertex'
    | 'azure'
    | 'groq'
    | 'ollama'
    | 'webui'
    | 'webui-legacy'
    | 'lmstudio'
    | 'lmstudio-legacy'
    | 'llamacpp'
    | 'koboldcpp'
    | 'vllm'
    | 'hugging-face'
    | 'mistral'
    | 'together'
    | 'pinecone';
  /**
   * The endpoint for the model (`None` if local).
   */
  embedding_endpoint?: string | null;
  /**
   * The model for the embedding.
   */
  embedding_model: string;
  /**
   * The dimension of the embedding.
   */
  embedding_dim: number;
  /**
   * The chunk size of the embedding.
   */
  embedding_chunk_size?: number | null;
  /**
   * The handle for this config, in the format provider/model-name.
   */
  handle?: string | null;
  /**
   * The maximum batch size for processing embeddings.
   */
  batch_size?: number;
  /**
   * The Azure endpoint for the model.
   */
  azure_endpoint?: string | null;
  /**
   * The Azure version for the model.
   */
  azure_version?: string | null;
  /**
   * The Azure deployment for the model.
   */
  azure_deployment?: string | null;
};

/**
 * The endpoint type for the model.
 */
export type embedding_endpoint_type =
  | 'openai'
  | 'anthropic'
  | 'bedrock'
  | 'cohere'
  | 'google_ai'
  | 'google_vertex'
  | 'azure'
  | 'groq'
  | 'ollama'
  | 'webui'
  | 'webui-legacy'
  | 'lmstudio'
  | 'lmstudio-legacy'
  | 'llamacpp'
  | 'koboldcpp'
  | 'vllm'
  | 'hugging-face'
  | 'mistral'
  | 'together'
  | 'pinecone';

export type FeedbackType = 'positive' | 'negative';

export type File = {
  file: FileFile;
  type: 'file';
};

/**
 * File-Agent relationship with human-readable ID for agent file
 */
export type FileAgentSchema = {
  /**
   * Unique identifier of the agent.
   */
  agent_id: string;
  /**
   * Unique identifier of the file.
   */
  file_id: string;
  /**
   * Unique identifier of the source.
   */
  source_id: string;
  /**
   * Name of the file.
   */
  file_name: string;
  /**
   * True if the agent currently has the file open.
   */
  is_open?: boolean;
  /**
   * Portion of the file the agent is focused on (may be large).
   */
  visible_content?: string | null;
  /**
   * UTC timestamp of the agent's most recent access to this file.
   */
  last_accessed_at?: string | null;
  /**
   * Starting line number (1-indexed) when file was opened with line range.
   */
  start_line?: number | null;
  /**
   * Ending line number (exclusive) when file was opened with line range.
   */
  end_line?: number | null;
  /**
   * Human-readable identifier for this file-agent relationship in the file
   */
  id: string;
};

export type FileBlock = {
  /**
   * Value of the block.
   */
  value: string;
  /**
   * Character limit of the block.
   */
  limit?: number;
  /**
   * The associated project id.
   */
  project_id?: string | null;
  /**
   * Name of the block if it is a template.
   */
  name?: string | null;
  /**
   * Whether the block is a template (e.g. saved human/persona options).
   */
  is_template?: boolean;
  /**
   * Preserve the block on template migration.
   */
  preserve_on_migration?: boolean | null;
  /**
   * Label of the block (e.g. 'human', 'persona') in the context window.
   */
  label?: string | null;
  /**
   * Whether the agent has read-only access to the block.
   */
  read_only?: boolean;
  /**
   * Description of the block.
   */
  description?: string | null;
  /**
   * Metadata of the block.
   */
  metadata?: {
    [key: string]: unknown;
  } | null;
  /**
   * The human-friendly ID of the Block
   */
  id?: string;
  /**
   * The id of the user that made this Block.
   */
  created_by_id?: string | null;
  /**
   * The id of the user that last updated this Block.
   */
  last_updated_by_id?: string | null;
  /**
   * Unique identifier of the file.
   */
  file_id: string;
  /**
   * Unique identifier of the source.
   */
  source_id: string;
  /**
   * True if the agent currently has the file open.
   */
  is_open: boolean;
  /**
   * UTC timestamp of the agent’s most recent access to this file. Any operations from the open, close, or search tools will update this field.
   */
  last_accessed_at?: string | null;
};

export type FileFile = {
  file_data?: string;
  file_id?: string;
  filename?: string;
};

/**
 * Representation of a single FileMetadata
 */
export type FileMetadata = {
  /**
   * The unique identifier of the source associated with the document.
   */
  source_id: string;
  /**
   * The name of the file.
   */
  file_name?: string | null;
  /**
   * The original name of the file as uploaded.
   */
  original_file_name?: string | null;
  /**
   * The path to the file.
   */
  file_path?: string | null;
  /**
   * The type of the file (MIME type).
   */
  file_type?: string | null;
  /**
   * The size of the file in bytes.
   */
  file_size?: number | null;
  /**
   * The creation date of the file.
   */
  file_creation_date?: string | null;
  /**
   * The last modified date of the file.
   */
  file_last_modified_date?: string | null;
  /**
   * The current processing status of the file (e.g. pending, parsing, embedding, completed, error).
   */
  processing_status?: FileProcessingStatus;
  /**
   * Optional error message if the file failed processing.
   */
  error_message?: string | null;
  /**
   * Total number of chunks for the file.
   */
  total_chunks?: number | null;
  /**
   * Number of chunks that have been embedded.
   */
  chunks_embedded?: number | null;
  /**
   * Optional full-text content of the file; only populated on demand due to its size.
   */
  content?: string | null;
  /**
   * The human-friendly ID of the File
   */
  id?: string;
  /**
   * The unique identifier of the organization associated with the document.
   */
  organization_id?: string | null;
  /**
   * The creation date of the file.
   */
  created_at?: string | null;
  /**
   * The update date of the file.
   */
  updated_at?: string | null;
};

export type FileProcessingStatus =
  | 'pending'
  | 'parsing'
  | 'embedding'
  | 'completed'
  | 'error';

/**
 * File with human-readable ID for agent file
 */
export type FileSchema = {
  /**
   * The unique identifier of the source associated with the document.
   */
  source_id: string;
  /**
   * The name of the file.
   */
  file_name?: string | null;
  /**
   * The original name of the file as uploaded.
   */
  original_file_name?: string | null;
  /**
   * The path to the file.
   */
  file_path?: string | null;
  /**
   * The type of the file (MIME type).
   */
  file_type?: string | null;
  /**
   * The size of the file in bytes.
   */
  file_size?: number | null;
  /**
   * The creation date of the file.
   */
  file_creation_date?: string | null;
  /**
   * The last modified date of the file.
   */
  file_last_modified_date?: string | null;
  /**
   * The current processing status of the file (e.g. pending, parsing, embedding, completed, error).
   */
  processing_status?: FileProcessingStatus;
  /**
   * Optional error message if the file failed processing.
   */
  error_message?: string | null;
  /**
   * Total number of chunks for the file.
   */
  total_chunks?: number | null;
  /**
   * Number of chunks that have been embedded.
   */
  chunks_embedded?: number | null;
  /**
   * Optional full-text content of the file; only populated on demand due to its size.
   */
  content?: string | null;
  /**
   * Human-readable identifier for this file in the file
   */
  id: string;
};

/**
 * File statistics for metadata endpoint
 */
export type FileStats = {
  /**
   * Unique identifier of the file
   */
  file_id: string;
  /**
   * Name of the file
   */
  file_name: string;
  /**
   * Size of the file in bytes
   */
  file_size?: number | null;
};

/**
 * Representation of a folder, which is a collection of files and passages.
 *
 * Parameters:
 * id (str): The ID of the folder
 * name (str): The name of the folder.
 * embedding_config (EmbeddingConfig): The embedding configuration used by the folder.
 * user_id (str): The ID of the user that created the folder.
 * metadata (dict): Metadata associated with the folder.
 * description (str): The description of the folder.
 */
export type Folder = {
  /**
   * The name of the folder.
   */
  name: string;
  /**
   * The description of the folder.
   */
  description?: string | null;
  /**
   * Instructions for how to use the folder.
   */
  instructions?: string | null;
  /**
   * Metadata associated with the folder.
   */
  metadata?: {
    [key: string]: unknown;
  } | null;
  /**
   * The human-friendly ID of the Source
   */
  id?: string;
  /**
   * The embedding configuration used by the folder.
   */
  embedding_config: EmbeddingConfig;
  /**
   * The ID of the organization that created the folder.
   */
  organization_id?: string | null;
  /**
   * The id of the user that made this Tool.
   */
  created_by_id?: string | null;
  /**
   * The id of the user that made this Tool.
   */
  last_updated_by_id?: string | null;
  /**
   * The timestamp when the folder was created.
   */
  created_at?: string | null;
  /**
   * The timestamp when the folder was last updated.
   */
  updated_at?: string | null;
};

export type Function_Output = {
  arguments: string;
  name: string;
  [key: string]: unknown | string;
};

export type FunctionCall = {
  arguments: string;
  name: string;
};

export type FunctionDefinition_Input = {
  name: string;
  description?: string;
  parameters?: {
    [key: string]: unknown;
  };
  strict?: boolean | null;
};

export type FunctionDefinition_Output = {
  name: string;
  description?: string | null;
  parameters?: {
    [key: string]: unknown;
  } | null;
  strict?: boolean | null;
  [key: string]: unknown | string;
};

export type FunctionTool = {
  function: FunctionDefinition_Output;
  type: 'function';
  [key: string]: unknown | FunctionDefinition_Output | 'function';
};

export type GenerateToolInput = {
  /**
   * Name of the tool to generate code for
   */
  tool_name: string;
  /**
   * User prompt to generate code
   */
  prompt: string;
  /**
   * Handle of the tool to generate code for
   */
  handle?: string | null;
  /**
   * Python source code to parse for JSON schema
   */
  starter_code?: string | null;
  /**
   * List of validation errors
   */
  validation_errors: Array<string>;
};

export type GenerateToolOutput = {
  /**
   * Generated tool
   */
  tool: Tool;
  /**
   * Sample arguments for the tool
   */
  sample_args: {
    [key: string]: unknown;
  };
  /**
   * Response from the assistant
   */
  response: string;
};

export type Group = {
  /**
   * The id of the group. Assigned by the database.
   */
  id: string;
  manager_type: ManagerType;
  agent_ids: Array<string>;
  description: string;
  /**
   * The associated project id.
   */
  project_id?: string | null;
  shared_block_ids?: Array<string>;
  manager_agent_id?: string | null;
  termination_token?: string | null;
  max_turns?: number | null;
  sleeptime_agent_frequency?: number | null;
  turns_counter?: number | null;
  last_processed_message_id?: string | null;
  /**
   * The desired maximum length of messages in the context window of the convo agent. This is a best effort, and may be off slightly due to user/assistant interleaving.
   */
  max_message_buffer_length?: number | null;
  /**
   * The desired minimum length of messages in the context window of the convo agent. This is a best effort, and may be off-by-one due to user/assistant interleaving.
   */
  min_message_buffer_length?: number | null;
};

export type GroupCreate = {
  agent_ids: Array<string>;
  description: string;
  manager_config?:
    | RoundRobinManager
    | SupervisorManager
    | DynamicManager
    | SleeptimeManager
    | VoiceSleeptimeManager;
  /**
   * The associated project id.
   */
  project_id?: string | null;
  shared_block_ids?: Array<string>;
};

/**
 * Group with human-readable ID for agent file
 */
export type GroupSchema = {
  agent_ids: Array<string>;
  description: string;
  manager_config?:
    | RoundRobinManager
    | SupervisorManager
    | DynamicManager
    | SleeptimeManager
    | VoiceSleeptimeManager;
  /**
   * The associated project id.
   */
  project_id?: string | null;
  shared_block_ids?: Array<string>;
  /**
   * Human-readable identifier for this group in the file
   */
  id: string;
};

export type GroupUpdate = {
  agent_ids?: Array<string> | null;
  description?: string | null;
  manager_config?:
    | RoundRobinManagerUpdate
    | SupervisorManagerUpdate
    | DynamicManagerUpdate
    | SleeptimeManagerUpdate
    | VoiceSleeptimeManagerUpdate
    | null;
  /**
   * The associated project id.
   */
  project_id?: string | null;
  shared_block_ids?: Array<string> | null;
};

export type HTTPValidationError = {
  detail?: Array<ValidationError>;
};

/**
 * Health check response body
 */
export type Health = {
  version: string;
  status: string;
};

/**
 * Representation of an agent's internal reasoning where reasoning content
 * has been hidden from the response.
 *
 * Args:
 * id (str): The ID of the message
 * date (datetime): The date the message was created in ISO format
 * name (Optional[str]): The name of the sender of the message
 * state (Literal["redacted", "omitted"]): Whether the reasoning
 * content was redacted by the provider or simply omitted by the API
 * hidden_reasoning (Optional[str]): The internal reasoning of the agent
 */
export type HiddenReasoningMessage = {
  id: string;
  date: string;
  name?: string | null;
  /**
   * The type of the message.
   */
  message_type?: 'hidden_reasoning_message';
  otid?: string | null;
  sender_id?: string | null;
  step_id?: string | null;
  is_err?: boolean | null;
  state: 'redacted' | 'omitted';
  hidden_reasoning?: string | null;
};

export type state = 'redacted' | 'omitted';

export type Identity = {
  /**
   * The human-friendly ID of the Identity
   */
  id?: string;
  /**
   * External, user-generated identifier key of the identity.
   */
  identifier_key: string;
  /**
   * The name of the identity.
   */
  name: string;
  /**
   * The type of the identity.
   */
  identity_type: IdentityType;
  /**
   * The project id of the identity, if applicable.
   */
  project_id?: string | null;
  /**
   * The IDs of the agents associated with the identity.
   */
  agent_ids: Array<string>;
  /**
   * The IDs of the blocks associated with the identity.
   */
  block_ids: Array<string>;
  /**
   * The organization id of the user
   */
  organization_id?: string | null;
  /**
   * List of properties associated with the identity
   */
  properties?: Array<IdentityProperty>;
};

export type IdentityCreate = {
  /**
   * External, user-generated identifier key of the identity.
   */
  identifier_key: string;
  /**
   * The name of the identity.
   */
  name: string;
  /**
   * The type of the identity.
   */
  identity_type: IdentityType;
  /**
   * The project id of the identity, if applicable.
   */
  project_id?: string | null;
  /**
   * The agent ids that are associated with the identity.
   */
  agent_ids?: Array<string> | null;
  /**
   * The IDs of the blocks associated with the identity.
   */
  block_ids?: Array<string> | null;
  /**
   * List of properties associated with the identity.
   */
  properties?: Array<IdentityProperty> | null;
};

/**
 * A property of an identity
 */
export type IdentityProperty = {
  /**
   * The key of the property
   */
  key: string;
  /**
   * The value of the property
   */
  value:
    | string
    | number
    | boolean
    | {
        [key: string]: unknown;
      };
  /**
   * The type of the property
   */
  type: IdentityPropertyType;
};

/**
 * Enum to represent the type of the identity property.
 */
export type IdentityPropertyType = 'string' | 'number' | 'boolean' | 'json';

/**
 * Enum to represent the type of the identity.
 */
export type IdentityType = 'org' | 'user' | 'other';

export type IdentityUpdate = {
  /**
   * External, user-generated identifier key of the identity.
   */
  identifier_key?: string | null;
  /**
   * The name of the identity.
   */
  name?: string | null;
  /**
   * The type of the identity.
   */
  identity_type?: IdentityType | null;
  /**
   * The agent ids that are associated with the identity.
   */
  agent_ids?: Array<string> | null;
  /**
   * The IDs of the blocks associated with the identity.
   */
  block_ids?: Array<string> | null;
  /**
   * List of properties associated with the identity.
   */
  properties?: Array<IdentityProperty> | null;
};

export type IdentityUpsert = {
  /**
   * External, user-generated identifier key of the identity.
   */
  identifier_key: string;
  /**
   * The name of the identity.
   */
  name: string;
  /**
   * The type of the identity.
   */
  identity_type: IdentityType;
  /**
   * The project id of the identity, if applicable.
   */
  project_id?: string | null;
  /**
   * The agent ids that are associated with the identity.
   */
  agent_ids?: Array<string> | null;
  /**
   * The IDs of the blocks associated with the identity.
   */
  block_ids?: Array<string> | null;
  /**
   * List of properties associated with the identity.
   */
  properties?: Array<IdentityProperty> | null;
};

export type ImageContent = {
  /**
   * The type of the message.
   */
  type?: 'image';
  /**
   * The source of the image.
   */
  source: UrlImage | Base64Image | LettaImage;
};

export type ImageURL = {
  url: string;
  detail?: 'auto' | 'low' | 'high';
};

export type detail = 'auto' | 'low' | 'high';

/**
 * Response model for imported agents
 */
export type ImportedAgentsResponse = {
  /**
   * List of IDs of the imported agents
   */
  agent_ids: Array<string>;
};

/**
 * Represents the initial tool rule configuration.
 */
export type InitToolRule = {
  /**
   * The name of the tool. Must exist in the database for the user's organization.
   */
  tool_name: string;
  type?: 'run_first';
  /**
   * Optional Jinja2 template for generating agent prompt about this tool rule. Template can use variables like 'tool_name' and rule-specific attributes.
   */
  prompt_template?: string | null;
};

export type InputAudio = {
  data: string;
  format: 'wav' | 'mp3';
};

export type format2 = 'wav' | 'mp3';

export type JSONSchema = {
  name: string;
  description?: string;
  schema?: {
    [key: string]: unknown;
  };
  strict?: boolean | null;
};

/**
 * Representation of offline jobs, used for tracking status of data loading tasks (involving parsing and embedding files).
 *
 * Parameters:
 * id (str): The unique identifier of the job.
 * status (JobStatus): The status of the job.
 * created_at (datetime): The unix timestamp of when the job was created.
 * completed_at (datetime): The unix timestamp of when the job was completed.
 * user_id (str): The unique identifier of the user associated with the.
 */
export type Job = {
  /**
   * The id of the user that made this object.
   */
  created_by_id?: string | null;
  /**
   * The id of the user that made this object.
   */
  last_updated_by_id?: string | null;
  /**
   * The timestamp when the object was created.
   */
  created_at?: string | null;
  /**
   * The timestamp when the object was last updated.
   */
  updated_at?: string | null;
  /**
   * The status of the job.
   */
  status?: JobStatus;
  /**
   * The unix timestamp of when the job was completed.
   */
  completed_at?: string | null;
  /**
   * The metadata of the job.
   */
  metadata?: {
    [key: string]: unknown;
  } | null;
  /**
   * The type of the job.
   */
  job_type?: JobType;
  /**
   * If set, POST to this URL when the job completes.
   */
  callback_url?: string | null;
  /**
   * Timestamp when the callback was last attempted.
   */
  callback_sent_at?: string | null;
  /**
   * HTTP status code returned by the callback endpoint.
   */
  callback_status_code?: number | null;
  /**
   * Optional error message from attempting to POST the callback endpoint.
   */
  callback_error?: string | null;
  /**
   * Time to first token for a run in nanoseconds
   */
  ttft_ns?: number | null;
  /**
   * Total run duration in nanoseconds
   */
  total_duration_ns?: number | null;
  /**
   * The human-friendly ID of the Job
   */
  id?: string;
  /**
   * The unique identifier of the user associated with the job.
   */
  user_id?: string | null;
};

/**
 * Status of the job.
 */
export type JobStatus =
  | 'created'
  | 'running'
  | 'completed'
  | 'failed'
  | 'pending'
  | 'cancelled'
  | 'expired';

export type JobType = 'job' | 'run' | 'batch';

/**
 * Response format for JSON object responses.
 */
export type JsonObjectResponseFormat = {
  /**
   * The type of the response format.
   */
  type?: 'json_object';
};

/**
 * Response format for JSON schema-based responses.
 */
export type JsonSchemaResponseFormat = {
  /**
   * The type of the response format.
   */
  type?: 'json_schema';
  /**
   * The JSON schema of the response.
   */
  json_schema: {
    [key: string]: unknown;
  };
};

/**
 * Configuration for Language Model (LLM) connection and generation parameters.
 */
export type LLMConfig = {
  /**
   * LLM model name.
   */
  model: string;
  /**
   * The endpoint type for the model.
   */
  model_endpoint_type:
    | 'openai'
    | 'anthropic'
    | 'cohere'
    | 'google_ai'
    | 'google_vertex'
    | 'azure'
    | 'groq'
    | 'ollama'
    | 'webui'
    | 'webui-legacy'
    | 'lmstudio'
    | 'lmstudio-legacy'
    | 'lmstudio-chatcompletions'
    | 'llamacpp'
    | 'koboldcpp'
    | 'vllm'
    | 'hugging-face'
    | 'mistral'
    | 'together'
    | 'bedrock'
    | 'deepseek'
    | 'xai';
  /**
   * The endpoint for the model.
   */
  model_endpoint?: string | null;
  /**
   * The provider name for the model.
   */
  provider_name?: string | null;
  /**
   * The provider category for the model.
   */
  provider_category?: ProviderCategory | null;
  /**
   * The wrapper for the model.
   */
  model_wrapper?: string | null;
  /**
   * The context window size for the model.
   */
  context_window: number;
  /**
   * Puts 'inner_thoughts' as a kwarg in the function call if this is set to True. This helps with function calling performance and also the generation of inner thoughts.
   */
  put_inner_thoughts_in_kwargs?: boolean | null;
  /**
   * The handle for this config, in the format provider/model-name.
   */
  handle?: string | null;
  /**
   * The temperature to use when generating text with the model. A higher temperature will result in more random text.
   */
  temperature?: number;
  /**
   * The maximum number of tokens to generate. If not set, the model will use its default value.
   */
  max_tokens?: number | null;
  /**
   * Whether or not the model should use extended thinking if it is a 'reasoning' style model
   */
  enable_reasoner?: boolean;
  /**
   * The reasoning effort to use when generating text reasoning models
   */
  reasoning_effort?: 'minimal' | 'low' | 'medium' | 'high' | null;
  /**
   * Configurable thinking budget for extended thinking. Used for enable_reasoner and also for Google Vertex models like Gemini 2.5 Flash. Minimum value is 1024 when used with enable_reasoner.
   */
  max_reasoning_tokens?: number;
  /**
   * Positive values penalize new tokens based on their existing frequency in the text so far, decreasing the model's likelihood to repeat the same line verbatim. From OpenAI: Number between -2.0 and 2.0.
   */
  frequency_penalty?: number | null;
  /**
   * The framework compatibility type for the model.
   */
  compatibility_type?: 'gguf' | 'mlx' | null;
};

/**
 * The endpoint type for the model.
 */
export type model_endpoint_type =
  | 'openai'
  | 'anthropic'
  | 'cohere'
  | 'google_ai'
  | 'google_vertex'
  | 'azure'
  | 'groq'
  | 'ollama'
  | 'webui'
  | 'webui-legacy'
  | 'lmstudio'
  | 'lmstudio-legacy'
  | 'lmstudio-chatcompletions'
  | 'llamacpp'
  | 'koboldcpp'
  | 'vllm'
  | 'hugging-face'
  | 'mistral'
  | 'together'
  | 'bedrock'
  | 'deepseek'
  | 'xai';

export type LettaAsyncRequest = {
  /**
   * The messages to be sent to the agent.
   */
  messages: Array<MessageCreate>;
  /**
   * Maximum number of steps the agent should take to process the request.
   */
  max_steps?: number;
  /**
   * Whether the server should parse specific tool call arguments (default `send_message`) as `AssistantMessage` objects.
   */
  use_assistant_message?: boolean;
  /**
   * The name of the designated message tool.
   */
  assistant_message_tool_name?: string;
  /**
   * The name of the message argument in the designated message tool.
   */
  assistant_message_tool_kwarg?: string;
  /**
   * Only return specified message types in the response. If `None` (default) returns all messages.
   */
  include_return_message_types?: Array<MessageType> | null;
  /**
   * If set to True, enables reasoning before responses or tool calls from the agent.
   */
  enable_thinking?: string;
  /**
   * Optional callback URL to POST to when the job completes
   */
  callback_url?: string | null;
};

export type LettaBatchMessages = {
  messages: Array<Message>;
};

export type LettaBatchRequest = {
  /**
   * The messages to be sent to the agent.
   */
  messages: Array<MessageCreate>;
  /**
   * Maximum number of steps the agent should take to process the request.
   */
  max_steps?: number;
  /**
   * Whether the server should parse specific tool call arguments (default `send_message`) as `AssistantMessage` objects.
   */
  use_assistant_message?: boolean;
  /**
   * The name of the designated message tool.
   */
  assistant_message_tool_name?: string;
  /**
   * The name of the message argument in the designated message tool.
   */
  assistant_message_tool_kwarg?: string;
  /**
   * Only return specified message types in the response. If `None` (default) returns all messages.
   */
  include_return_message_types?: Array<MessageType> | null;
  /**
   * If set to True, enables reasoning before responses or tool calls from the agent.
   */
  enable_thinking?: string;
  /**
   * The ID of the agent to send this batch request for
   */
  agent_id: string;
};

export type LettaImage = {
  /**
   * The source type for the image.
   */
  type?: 'letta';
  /**
   * The unique identifier of the image file persisted in storage.
   */
  file_id: string;
  /**
   * The media type for the image.
   */
  media_type?: string | null;
  /**
   * The base64 encoded image data.
   */
  data?: string | null;
  /**
   * What level of detail to use when processing and understanding the image (low, high, or auto to let the model decide)
   */
  detail?: string | null;
};

export type LettaRequest = {
  /**
   * The messages to be sent to the agent.
   */
  messages: Array<MessageCreate>;
  /**
   * Maximum number of steps the agent should take to process the request.
   */
  max_steps?: number;
  /**
   * Whether the server should parse specific tool call arguments (default `send_message`) as `AssistantMessage` objects.
   */
  use_assistant_message?: boolean;
  /**
   * The name of the designated message tool.
   */
  assistant_message_tool_name?: string;
  /**
   * The name of the message argument in the designated message tool.
   */
  assistant_message_tool_kwarg?: string;
  /**
   * Only return specified message types in the response. If `None` (default) returns all messages.
   */
  include_return_message_types?: Array<MessageType> | null;
  /**
   * If set to True, enables reasoning before responses or tool calls from the agent.
   */
  enable_thinking?: string;
};

export type LettaRequestConfig = {
  /**
   * Whether the server should parse specific tool call arguments (default `send_message`) as `AssistantMessage` objects.
   */
  use_assistant_message?: boolean;
  /**
   * The name of the designated message tool.
   */
  assistant_message_tool_name?: string;
  /**
   * The name of the message argument in the designated message tool.
   */
  assistant_message_tool_kwarg?: string;
  /**
   * Only return specified message types in the response. If `None` (default) returns all messages.
   */
  include_return_message_types?: Array<MessageType> | null;
};

/**
 * Response object from an agent interaction, consisting of the new messages generated by the agent and usage statistics.
 * The type of the returned messages can be either `Message` or `LettaMessage`, depending on what was specified in the request.
 *
 * Attributes:
 * messages (List[Union[Message, LettaMessage]]): The messages returned by the agent.
 * usage (LettaUsageStatistics): The usage statistics
 */
export type LettaResponse = {
  /**
   * The messages returned by the agent.
   */
  messages: Array<LettaMessageUnion>;
  stop_reason: LettaStopReason;
  /**
   * The usage statistics of the agent.
   */
  usage: LettaUsageStatistics;
};

/**
 * The stop reason from Letta indicating why agent loop stopped execution.
 */
export type LettaStopReason = {
  /**
   * The type of the message.
   */
  message_type?: 'stop_reason';
  /**
   * The reason why execution stopped.
   */
  stop_reason: StopReasonType;
};

export type LettaStreamingRequest = {
  /**
   * The messages to be sent to the agent.
   */
  messages: Array<MessageCreate>;
  /**
   * Maximum number of steps the agent should take to process the request.
   */
  max_steps?: number;
  /**
   * Whether the server should parse specific tool call arguments (default `send_message`) as `AssistantMessage` objects.
   */
  use_assistant_message?: boolean;
  /**
   * The name of the designated message tool.
   */
  assistant_message_tool_name?: string;
  /**
   * The name of the message argument in the designated message tool.
   */
  assistant_message_tool_kwarg?: string;
  /**
   * Only return specified message types in the response. If `None` (default) returns all messages.
   */
  include_return_message_types?: Array<MessageType> | null;
  /**
   * If set to True, enables reasoning before responses or tool calls from the agent.
   */
  enable_thinking?: string;
  /**
   * Flag to determine if individual tokens should be streamed. Set to True for token streaming (requires stream_steps = True).
   */
  stream_tokens?: boolean;
  /**
   * Whether to include periodic keepalive ping messages in the stream to prevent connection timeouts.
   */
  include_pings?: boolean;
};

/**
 * Usage statistics for the agent interaction.
 *
 * Attributes:
 * completion_tokens (int): The number of tokens generated by the agent.
 * prompt_tokens (int): The number of tokens in the prompt.
 * total_tokens (int): The total number of tokens processed by the agent.
 * step_count (int): The number of steps taken by the agent.
 */
export type LettaUsageStatistics = {
  message_type?: 'usage_statistics';
  /**
   * The number of tokens generated by the agent.
   */
  completion_tokens?: number;
  /**
   * The number of tokens in the prompt.
   */
  prompt_tokens?: number;
  /**
   * The total number of tokens processed by the agent.
   */
  total_tokens?: number;
  /**
   * The number of steps taken by the agent.
   */
  step_count?: number;
  /**
   * The messages generated per step
   */
  steps_messages?: Array<Array<Message>> | null;
  /**
   * The background task run IDs associated with the agent interaction
   */
  run_ids?: Array<string> | null;
};

export type LocalSandboxConfig = {
  /**
   * Directory for the sandbox environment.
   */
  sandbox_dir?: string | null;
  /**
   * Whether or not to use the venv, or run directly in the same run loop.
   */
  use_venv?: boolean;
  /**
   * The name for the venv in the sandbox directory. We first search for an existing venv with this name, otherwise, we make it from the requirements.txt.
   */
  venv_name?: string;
  /**
   * List of pip packages to install with mandatory name and optional version following semantic versioning. This only is considered when use_venv is True.
   */
  pip_requirements?: Array<PipRequirement>;
};

/**
 * MCP server schema for agent files with remapped ID.
 */
export type MCPServerSchema = {
  /**
   * Human-readable MCP server ID
   */
  id: string;
  server_type: string;
  server_name: string;
  server_url?: string | null;
  stdio_config?: {
    [key: string]: unknown;
  } | null;
  metadata_?: {
    [key: string]: unknown;
  } | null;
};

export type MCPServerType = 'sse' | 'stdio' | 'streamable_http';

/**
 * A simple wrapper around MCP's tool definition (to avoid conflict with our own)
 */
export type MCPTool = {
  name: string;
  title?: string | null;
  description?: string | null;
  inputSchema: {
    [key: string]: unknown;
  };
  outputSchema?: {
    [key: string]: unknown;
  } | null;
  annotations?: ToolAnnotations | null;
  _meta?: {
    [key: string]: unknown;
  } | null;
  [key: string]: unknown | string;
};

export type ManagerType =
  | 'round_robin'
  | 'supervisor'
  | 'dynamic'
  | 'sleeptime'
  | 'voice_sleeptime'
  | 'swarm';

/**
 * Represents a tool rule configuration which constrains the total number of times this tool can be invoked in a single step.
 */
export type MaxCountPerStepToolRule = {
  /**
   * The name of the tool. Must exist in the database for the user's organization.
   */
  tool_name: string;
  type?: 'max_count_per_step';
  /**
   * Optional Jinja2 template for generating agent prompt about this tool rule.
   */
  prompt_template?: string | null;
  /**
   * The max limit for the total number of times this tool can be invoked in a single step.
   */
  max_count_limit: number;
};

export type MaxCountPerStepToolRuleSchema = {
  tool_name: string;
  type: string;
  max_count_limit: number;
};

/**
 * Represents the in-context memory (i.e. Core memory) of the agent. This includes both the `Block` objects (labelled by sections), as well as tools to edit the blocks.
 */
export type Memory = {
  /**
   * Memory blocks contained in the agent's in-context memory
   */
  blocks: Array<Block>;
  /**
   * Special blocks representing the agent's in-context memory of an attached file
   */
  file_blocks?: Array<FileBlock>;
  /**
   * Jinja2 template for compiling memory blocks into a prompt string
   */
  prompt_template?: string;
};

/**
 *     Letta's internal representation of a message. Includes methods to convert to/from LLM provider formats.
 *
 * Attributes:
 * id (str): The unique identifier of the message.
 * role (MessageRole): The role of the participant.
 * text (str): The text of the message.
 * user_id (str): The unique identifier of the user.
 * agent_id (str): The unique identifier of the agent.
 * model (str): The model used to make the function call.
 * name (str): The name of the participant.
 * created_at (datetime): The time the message was created.
 * tool_calls (List[OpenAIToolCall,]): The list of tool calls requested.
 * tool_call_id (str): The id of the tool call.
 * step_id (str): The id of the step that this message was created in.
 * otid (str): The offline threading id associated with this message.
 * tool_returns (List[ToolReturn]): The list of tool returns requested.
 * group_id (str): The multi-agent group that the message was sent in.
 * sender_id (str): The id of the sender of the message, can be an identity id or agent id.
 * t
 */
export type Message = {
  /**
   * The id of the user that made this object.
   */
  created_by_id?: string | null;
  /**
   * The id of the user that made this object.
   */
  last_updated_by_id?: string | null;
  /**
   * The timestamp when the object was created.
   */
  created_at?: string;
  /**
   * The timestamp when the object was last updated.
   */
  updated_at?: string | null;
  /**
   * The human-friendly ID of the Message
   */
  id?: string;
  /**
   * The unique identifier of the agent.
   */
  agent_id?: string | null;
  /**
   * The model used to make the function call.
   */
  model?: string | null;
  /**
   * The role of the participant.
   */
  role: MessageRole;
  /**
   * The content of the message.
   */
  content?: Array<
    | TextContent
    | ImageContent
    | ToolCallContent
    | ToolReturnContent
    | ReasoningContent
    | RedactedReasoningContent
    | OmittedReasoningContent
  > | null;
  /**
   * For role user/assistant: the (optional) name of the participant. For role tool/function: the name of the function called.
   */
  name?: string | null;
  /**
   * The list of tool calls requested. Only applicable for role assistant.
   */
  tool_calls?: Array<ChatCompletionMessageToolCall> | null;
  /**
   * The ID of the tool call. Only applicable for role tool.
   */
  tool_call_id?: string | null;
  /**
   * The id of the step that this message was created in.
   */
  step_id?: string | null;
  /**
   * The offline threading id associated with this message
   */
  otid?: string | null;
  /**
   * Tool execution return information for prior tool calls
   */
  tool_returns?: Array<ToolReturn> | null;
  /**
   * The multi-agent group that the message was sent in
   */
  group_id?: string | null;
  /**
   * The id of the sender of the message, can be an identity id or agent id
   */
  sender_id?: string | null;
  /**
   * The id of the LLMBatchItem that this message is associated with
   */
  batch_item_id?: string | null;
  /**
   * Whether this message is part of an error step. Used only for debugging purposes.
   */
  is_err?: boolean | null;
};

/**
 * Request to create a message
 */
export type MessageCreate = {
  /**
   * The role of the participant.
   */
  role: 'user' | 'system' | 'assistant';
  /**
   * The content of the message.
   */
  content: Array<LettaMessageContentUnion> | string;
  /**
   * The name of the participant.
   */
  name?: string | null;
  /**
   * The offline threading id associated with this message
   */
  otid?: string | null;
  /**
   * The id of the sender of the message, can be an identity id or agent id
   */
  sender_id?: string | null;
  /**
   * The id of the LLMBatchItem that this message is associated with
   */
  batch_item_id?: string | null;
  /**
   * The multi-agent group that the message was sent in
   */
  group_id?: string | null;
};

/**
 * The role of the participant.
 */
export type role = 'user' | 'system' | 'assistant';

export type MessageRole = 'assistant' | 'user' | 'tool' | 'function' | 'system';

export type MessageType =
  | 'system_message'
  | 'user_message'
  | 'assistant_message'
  | 'reasoning_message'
  | 'hidden_reasoning_message'
  | 'tool_call_message'
  | 'tool_return_message';

export type ModalSandboxConfig = {
  /**
   * Time limit for the sandbox (in seconds).
   */
  timeout?: number;
  /**
   * A list of pip packages to install in the Modal sandbox
   */
  pip_requirements?: Array<string> | null;
  /**
   * A list of npm packages to install in the Modal sandbox
   */
  npm_requirements?: Array<string> | null;
  language?: 'python' | 'typescript';
};

export type language = 'python' | 'typescript';

export type NpmRequirement = {
  /**
   * Name of the npm package.
   */
  name: string;
  /**
   * Optional version of the package, following semantic versioning.
   */
  version?: string | null;
};

export type OmittedReasoningContent = {
  /**
   * Indicates this is an omitted reasoning step.
   */
  type?: 'omitted_reasoning';
};

export type Organization = {
  /**
   * The human-friendly ID of the Org
   */
  id?: string;
  /**
   * The name of the organization.
   */
  name?: string;
  /**
   * The creation date of the organization.
   */
  created_at?: string | null;
  /**
   * Whether the organization has access to privileged tools.
   */
  privileged_tools?: boolean;
};

export type OrganizationCreate = {
  /**
   * The name of the organization.
   */
  name?: string | null;
  /**
   * Whether the organization has access to privileged tools.
   */
  privileged_tools?: boolean | null;
};

/**
 * Complete metadata response for organization sources
 */
export type OrganizationSourcesStats = {
  /**
   * Total number of sources
   */
  total_sources?: number;
  /**
   * Total number of files across all sources
   */
  total_files?: number;
  /**
   * Total size of all files in bytes
   */
  total_size?: number;
  /**
   * List of source metadata
   */
  sources?: Array<SourceStats>;
};

export type OrganizationUpdate = {
  /**
   * The name of the organization.
   */
  name?: string | null;
  /**
   * Whether the organization has access to privileged tools.
   */
  privileged_tools?: boolean | null;
};

export type ParameterProperties = {
  type: string;
  description?: string | null;
};

export type ParametersSchema = {
  type?: string | null;
  properties: {
    [key: string]: ParameterProperties;
  };
  required?: Array<string>;
};

/**
 * A ToolRule that only allows a child tool to be called if the parent has been called.
 */
export type ParentToolRule = {
  /**
   * The name of the tool. Must exist in the database for the user's organization.
   */
  tool_name: string;
  type?: 'parent_last_tool';
  /**
   * Optional Jinja2 template for generating agent prompt about this tool rule.
   */
  prompt_template?: string | null;
  /**
   * The children tools that can be invoked.
   */
  children: Array<string>;
};

/**
 * Representation of a passage, which is stored in archival memory.
 *
 * Parameters:
 * text (str): The text of the passage.
 * embedding (List[float]): The embedding of the passage.
 * embedding_config (EmbeddingConfig): The embedding configuration used by the passage.
 * created_at (datetime): The creation date of the passage.
 * organization_id (str): The unique identifier of the organization associated with the passage.
 * archive_id (str): The unique identifier of the archive containing this passage.
 * source_id (str): The data source of the passage.
 * file_id (str): The unique identifier of the file associated with the passage.
 */
export type Passage = {
  /**
   * The id of the user that made this object.
   */
  created_by_id?: string | null;
  /**
   * The id of the user that made this object.
   */
  last_updated_by_id?: string | null;
  /**
   * The creation date of the passage.
   */
  created_at?: string;
  /**
   * The timestamp when the object was last updated.
   */
  updated_at?: string | null;
  /**
   * Whether this passage is deleted or not.
   */
  is_deleted?: boolean;
  /**
   * The unique identifier of the user associated with the passage.
   */
  organization_id?: string | null;
  /**
   * The unique identifier of the archive containing this passage.
   */
  archive_id?: string | null;
  /**
   * The data source of the passage.
   */
  source_id?: string | null;
  /**
   * The unique identifier of the file associated with the passage.
   */
  file_id?: string | null;
  /**
   * The name of the file (only for source passages).
   */
  file_name?: string | null;
  /**
   * The metadata of the passage.
   */
  metadata?: {
    [key: string]: unknown;
  } | null;
  /**
   * The human-friendly ID of the Passage
   */
  id?: string;
  /**
   * The text of the passage.
   */
  text: string;
  /**
   * The embedding of the passage.
   */
  embedding: Array<number> | null;
  /**
   * The embedding configuration used by the passage.
   */
  embedding_config: EmbeddingConfig | null;
};

export type PassageUpdate = {
  /**
   * The id of the user that made this object.
   */
  created_by_id?: string | null;
  /**
   * The id of the user that made this object.
   */
  last_updated_by_id?: string | null;
  /**
   * The timestamp when the object was created.
   */
  created_at?: string | null;
  /**
   * The timestamp when the object was last updated.
   */
  updated_at?: string | null;
  /**
   * Whether this passage is deleted or not.
   */
  is_deleted?: boolean;
  /**
   * The unique identifier of the user associated with the passage.
   */
  organization_id?: string | null;
  /**
   * The unique identifier of the archive containing this passage.
   */
  archive_id?: string | null;
  /**
   * The data source of the passage.
   */
  source_id?: string | null;
  /**
   * The unique identifier of the file associated with the passage.
   */
  file_id?: string | null;
  /**
   * The name of the file (only for source passages).
   */
  file_name?: string | null;
  /**
   * The metadata of the passage.
   */
  metadata_?: {
    [key: string]: unknown;
  } | null;
  /**
   * The text of the passage.
   */
  text?: string | null;
  /**
   * The embedding of the passage.
   */
  embedding?: Array<number> | null;
  /**
   * The embedding configuration used by the passage.
   */
  embedding_config?: EmbeddingConfig | null;
  /**
   * The unique identifier of the passage.
   */
  id: string;
};

export type PipRequirement = {
  /**
   * Name of the pip package.
   */
  name: string;
  /**
   * Optional version of the package, following semantic versioning.
   */
  version?: string | null;
};

export type Provider = {
  /**
   * The id of the provider, lazily created by the database manager.
   */
  id?: string | null;
  /**
   * The name of the provider
   */
  name: string;
  /**
   * The type of the provider
   */
  provider_type: ProviderType;
  /**
   * The category of the provider (base or byok)
   */
  provider_category: ProviderCategory;
  /**
   * API key or secret key used for requests to the provider.
   */
  api_key?: string | null;
  /**
   * Base URL for the provider.
   */
  base_url?: string | null;
  /**
   * Access key used for requests to the provider.
   */
  access_key?: string | null;
  /**
   * Region used for requests to the provider.
   */
  region?: string | null;
  /**
   * API version used for requests to the provider.
   */
  api_version?: string | null;
  /**
   * The organization id of the user
   */
  organization_id?: string | null;
  /**
   * The last update timestamp of the provider.
   */
  updated_at?: string | null;
};

export type ProviderCategory = 'base' | 'byok';

export type ProviderCheck = {
  /**
   * The type of the provider.
   */
  provider_type: ProviderType;
  /**
   * API key or secret key used for requests to the provider.
   */
  api_key: string;
  /**
   * Access key used for requests to the provider.
   */
  access_key?: string | null;
  /**
   * Region used for requests to the provider.
   */
  region?: string | null;
  /**
   * Base URL used for requests to the provider.
   */
  base_url?: string | null;
  /**
   * API version used for requests to the provider.
   */
  api_version?: string | null;
};

export type ProviderCreate = {
  /**
   * The name of the provider.
   */
  name: string;
  /**
   * The type of the provider.
   */
  provider_type: ProviderType;
  /**
   * API key or secret key used for requests to the provider.
   */
  api_key: string;
  /**
   * Access key used for requests to the provider.
   */
  access_key?: string | null;
  /**
   * Region used for requests to the provider.
   */
  region?: string | null;
  /**
   * Base URL used for requests to the provider.
   */
  base_url?: string | null;
  /**
   * API version used for requests to the provider.
   */
  api_version?: string | null;
};

/**
 * Letta's internal representation of a provider trace.
 *
 * Attributes:
 * id (str): The unique identifier of the provider trace.
 * request_json (Dict[str, Any]): JSON content of the provider request.
 * response_json (Dict[str, Any]): JSON content of the provider response.
 * step_id (str): ID of the step that this trace is associated with.
 * organization_id (str): The unique identifier of the organization.
 * created_at (datetime): The timestamp when the object was created.
 */
export type ProviderTrace = {
  /**
   * The id of the user that made this object.
   */
  created_by_id?: string | null;
  /**
   * The id of the user that made this object.
   */
  last_updated_by_id?: string | null;
  /**
   * The timestamp when the object was created.
   */
  created_at?: string;
  /**
   * The timestamp when the object was last updated.
   */
  updated_at?: string | null;
  /**
   * The human-friendly ID of the Provider_trace
   */
  id?: string;
  /**
   * JSON content of the provider request
   */
  request_json: {
    [key: string]: unknown;
  };
  /**
   * JSON content of the provider response
   */
  response_json: {
    [key: string]: unknown;
  };
  /**
   * ID of the step that this trace is associated with
   */
  step_id?: string | null;
  /**
   * The unique identifier of the organization.
   */
  organization_id: string;
};

export type ProviderType =
  | 'anthropic'
  | 'google_ai'
  | 'google_vertex'
  | 'openai'
  | 'letta'
  | 'deepseek'
  | 'cerebras'
  | 'lmstudio_openai'
  | 'xai'
  | 'mistral'
  | 'ollama'
  | 'groq'
  | 'together'
  | 'azure'
  | 'vllm'
  | 'bedrock'
  | 'cohere';

export type ProviderUpdate = {
  /**
   * API key or secret key used for requests to the provider.
   */
  api_key: string;
  /**
   * Access key used for requests to the provider.
   */
  access_key?: string | null;
  /**
   * Region used for requests to the provider.
   */
  region?: string | null;
  /**
   * Base URL used for requests to the provider.
   */
  base_url?: string | null;
  /**
   * API version used for requests to the provider.
   */
  api_version?: string | null;
};

export type ReasoningContent = {
  /**
   * Indicates this is a reasoning/intermediate step.
   */
  type?: 'reasoning';
  /**
   * Whether the reasoning content was generated by a reasoner model that processed this step.
   */
  is_native: boolean;
  /**
   * The intermediate reasoning or thought process content.
   */
  reasoning: string;
  /**
   * A unique identifier for this reasoning step.
   */
  signature?: string | null;
};

/**
 * Representation of an agent's internal reasoning.
 *
 * Args:
 * id (str): The ID of the message
 * date (datetime): The date the message was created in ISO format
 * name (Optional[str]): The name of the sender of the message
 * source (Literal["reasoner_model", "non_reasoner_model"]): Whether the reasoning
 * content was generated natively by a reasoner model or derived via prompting
 * reasoning (str): The internal reasoning of the agent
 * signature (Optional[str]): The model-generated signature of the reasoning step
 */
export type ReasoningMessage = {
  id: string;
  date: string;
  name?: string | null;
  /**
   * The type of the message.
   */
  message_type?: 'reasoning_message';
  otid?: string | null;
  sender_id?: string | null;
  step_id?: string | null;
  is_err?: boolean | null;
  source?: 'reasoner_model' | 'non_reasoner_model';
  reasoning: string;
  signature?: string | null;
};

export type source = 'reasoner_model' | 'non_reasoner_model';

export type RedactedReasoningContent = {
  /**
   * Indicates this is a redacted thinking step.
   */
  type?: 'redacted_reasoning';
  /**
   * The redacted or filtered intermediate reasoning content.
   */
  data: string;
};

/**
 * Represents a tool rule configuration where this tool must be called before the agent loop can exit.
 */
export type RequiredBeforeExitToolRule = {
  /**
   * The name of the tool. Must exist in the database for the user's organization.
   */
  tool_name: string;
  type?: 'required_before_exit';
  /**
   * Optional Jinja2 template for generating agent prompt about this tool rule.
   */
  prompt_template?: string | null;
};

export type ResponseFormatJSONObject = {
  type: 'json_object';
};

export type ResponseFormatJSONSchema = {
  json_schema: JSONSchema;
  type: 'json_schema';
};

export type ResponseFormatText = {
  type: 'text';
};

export type RoundRobinManager = {
  manager_type?: 'round_robin';
  max_turns?: number | null;
};

export type RoundRobinManagerUpdate = {
  manager_type?: 'round_robin';
  max_turns?: number | null;
};

/**
 * Representation of a run, which is a job with a 'run' prefix in its ID.
 * Inherits all fields and behavior from Job except for the ID prefix.
 *
 * Parameters:
 * id (str): The unique identifier of the run (prefixed with 'run-').
 * status (JobStatus): The status of the run.
 * created_at (datetime): The unix timestamp of when the run was created.
 * completed_at (datetime): The unix timestamp of when the run was completed.
 * user_id (str): The unique identifier of the user associated with the run.
 */
export type Run = {
  /**
   * The id of the user that made this object.
   */
  created_by_id?: string | null;
  /**
   * The id of the user that made this object.
   */
  last_updated_by_id?: string | null;
  /**
   * The timestamp when the object was created.
   */
  created_at?: string | null;
  /**
   * The timestamp when the object was last updated.
   */
  updated_at?: string | null;
  /**
   * The status of the job.
   */
  status?: JobStatus;
  /**
   * The unix timestamp of when the job was completed.
   */
  completed_at?: string | null;
  /**
   * The metadata of the job.
   */
  metadata?: {
    [key: string]: unknown;
  } | null;
  job_type?: JobType;
  /**
   * If set, POST to this URL when the job completes.
   */
  callback_url?: string | null;
  /**
   * Timestamp when the callback was last attempted.
   */
  callback_sent_at?: string | null;
  /**
   * HTTP status code returned by the callback endpoint.
   */
  callback_status_code?: number | null;
  /**
   * Optional error message from attempting to POST the callback endpoint.
   */
  callback_error?: string | null;
  /**
   * Time to first token for a run in nanoseconds
   */
  ttft_ns?: number | null;
  /**
   * Total run duration in nanoseconds
   */
  total_duration_ns?: number | null;
  /**
   * The human-friendly ID of the Run
   */
  id?: string;
  /**
   * The unique identifier of the user associated with the run.
   */
  user_id?: string | null;
  /**
   * The request configuration for the run.
   */
  request_config?: LettaRequestConfig | null;
};

/**
 * Configuration for an MCP server using SSE
 *
 * Authentication can be provided in multiple ways:
 * 1. Using auth_header + auth_token: Will add a specific header with the token
 * Example: auth_header="Authorization", auth_token="Bearer abc123"
 *
 * 2. Using the custom_headers dict: For more complex authentication scenarios
 * Example: custom_headers={"X-API-Key": "abc123", "X-Custom-Header": "value"}
 */
export type SSEServerConfig = {
  /**
   * The name of the server
   */
  server_name: string;
  type?: MCPServerType;
  /**
   * The URL of the server (MCP SSE client will connect to this URL)
   */
  server_url: string;
  /**
   * The name of the authentication header (e.g., 'Authorization')
   */
  auth_header?: string | null;
  /**
   * The authentication token or API key value
   */
  auth_token?: string | null;
  /**
   * Custom HTTP headers to include with SSE requests
   */
  custom_headers?: {
    [key: string]: string;
  } | null;
};

export type SandboxConfig = {
  /**
   * The id of the user that made this object.
   */
  created_by_id?: string | null;
  /**
   * The id of the user that made this object.
   */
  last_updated_by_id?: string | null;
  /**
   * The timestamp when the object was created.
   */
  created_at?: string | null;
  /**
   * The timestamp when the object was last updated.
   */
  updated_at?: string | null;
  /**
   * The human-friendly ID of the Sandbox
   */
  id?: string;
  /**
   * The type of sandbox.
   */
  type?: SandboxType;
  /**
   * The unique identifier of the organization associated with the sandbox.
   */
  organization_id?: string | null;
  /**
   * The JSON sandbox settings data.
   */
  config?: {
    [key: string]: unknown;
  };
};

export type SandboxConfigCreate = {
  /**
   * The configuration for the sandbox.
   */
  config: LocalSandboxConfig | E2BSandboxConfig | ModalSandboxConfig;
};

/**
 * Pydantic model for updating SandboxConfig fields.
 */
export type SandboxConfigUpdate = {
  /**
   * The JSON configuration data for the sandbox.
   */
  config?: LocalSandboxConfig | E2BSandboxConfig | ModalSandboxConfig;
};

export type SandboxEnvironmentVariable = {
  /**
   * The id of the user that made this object.
   */
  created_by_id?: string | null;
  /**
   * The id of the user that made this object.
   */
  last_updated_by_id?: string | null;
  /**
   * The timestamp when the object was created.
   */
  created_at?: string | null;
  /**
   * The timestamp when the object was last updated.
   */
  updated_at?: string | null;
  /**
   * The human-friendly ID of the Sandbox-env
   */
  id?: string;
  /**
   * The name of the environment variable.
   */
  key: string;
  /**
   * The value of the environment variable.
   */
  value: string;
  /**
   * An optional description of the environment variable.
   */
  description?: string | null;
  /**
   * The ID of the organization this environment variable belongs to.
   */
  organization_id?: string | null;
  /**
   * The ID of the sandbox config this environment variable belongs to.
   */
  sandbox_config_id: string;
};

export type SandboxEnvironmentVariableCreate = {
  /**
   * The name of the environment variable.
   */
  key: string;
  /**
   * The value of the environment variable.
   */
  value: string;
  /**
   * An optional description of the environment variable.
   */
  description?: string | null;
};

export type SandboxEnvironmentVariableUpdate = {
  /**
   * The name of the environment variable.
   */
  key?: string | null;
  /**
   * The value of the environment variable.
   */
  value?: string | null;
  /**
   * An optional description of the environment variable.
   */
  description?: string | null;
};

export type SandboxType = 'e2b' | 'modal' | 'local';

export type SleeptimeManager = {
  manager_type?: 'sleeptime';
  manager_agent_id: string;
  sleeptime_agent_frequency?: number | null;
};

export type SleeptimeManagerUpdate = {
  manager_type?: 'sleeptime';
  manager_agent_id?: string | null;
  sleeptime_agent_frequency?: number | null;
};

/**
 * Representation of a source, which is a collection of files and passages.
 *
 * Parameters:
 * id (str): The ID of the source
 * name (str): The name of the source.
 * embedding_config (EmbeddingConfig): The embedding configuration used by the source.
 * user_id (str): The ID of the user that created the source.
 * metadata (dict): Metadata associated with the source.
 * description (str): The description of the source.
 */
export type Source = {
  /**
   * The name of the source.
   */
  name: string;
  /**
   * The description of the source.
   */
  description?: string | null;
  /**
   * Instructions for how to use the source.
   */
  instructions?: string | null;
  /**
   * Metadata associated with the source.
   */
  metadata?: {
    [key: string]: unknown;
  } | null;
  /**
   * The human-friendly ID of the Source
   */
  id?: string;
  /**
   * The embedding configuration used by the source.
   */
  embedding_config: EmbeddingConfig;
  /**
   * The ID of the organization that created the source.
   */
  organization_id?: string | null;
  /**
   * The id of the user that made this Tool.
   */
  created_by_id?: string | null;
  /**
   * The id of the user that made this Tool.
   */
  last_updated_by_id?: string | null;
  /**
   * The timestamp when the source was created.
   */
  created_at?: string | null;
  /**
   * The timestamp when the source was last updated.
   */
  updated_at?: string | null;
};

/**
 * Schema for creating a new Source.
 */
export type SourceCreate = {
  /**
   * The name of the source.
   */
  name: string;
  /**
   * The description of the source.
   */
  description?: string | null;
  /**
   * Instructions for how to use the source.
   */
  instructions?: string | null;
  /**
   * Metadata associated with the source.
   */
  metadata?: {
    [key: string]: unknown;
  } | null;
  /**
   * The handle for the embedding config used by the source.
   */
  embedding?: string | null;
  /**
   * The chunk size of the embedding.
   */
  embedding_chunk_size?: number | null;
  /**
   * (Legacy) The embedding configuration used by the source.
   */
  embedding_config?: EmbeddingConfig | null;
};

/**
 * Source with human-readable ID for agent file
 */
export type SourceSchema = {
  /**
   * The name of the source.
   */
  name: string;
  /**
   * The description of the source.
   */
  description?: string | null;
  /**
   * Instructions for how to use the source.
   */
  instructions?: string | null;
  /**
   * Metadata associated with the source.
   */
  metadata?: {
    [key: string]: unknown;
  } | null;
  /**
   * The handle for the embedding config used by the source.
   */
  embedding?: string | null;
  /**
   * The chunk size of the embedding.
   */
  embedding_chunk_size?: number | null;
  /**
   * (Legacy) The embedding configuration used by the source.
   */
  embedding_config?: EmbeddingConfig | null;
  /**
   * Human-readable identifier for this source in the file
   */
  id: string;
};

/**
 * Aggregated metadata for a source
 */
export type SourceStats = {
  /**
   * Unique identifier of the source
   */
  source_id: string;
  /**
   * Name of the source
   */
  source_name: string;
  /**
   * Number of files in the source
   */
  file_count?: number;
  /**
   * Total size of all files in bytes
   */
  total_size?: number;
  /**
   * List of file statistics
   */
  files?: Array<FileStats>;
};

/**
 * Schema for updating an existing Source.
 */
export type SourceUpdate = {
  /**
   * The name of the source.
   */
  name?: string | null;
  /**
   * The description of the source.
   */
  description?: string | null;
  /**
   * Instructions for how to use the source.
   */
  instructions?: string | null;
  /**
   * Metadata associated with the source.
   */
  metadata?: {
    [key: string]: unknown;
  } | null;
  /**
   * The embedding configuration used by the source.
   */
  embedding_config?: EmbeddingConfig | null;
};

export type StdioServerConfig = {
  /**
   * The name of the server
   */
  server_name: string;
  type?: MCPServerType;
  /**
   * The command to run (MCP 'local' client will run this command)
   */
  command: string;
  /**
   * The arguments to pass to the command
   */
  args: Array<string>;
  /**
   * Environment variables to set
   */
  env?: {
    [key: string]: string;
  } | null;
};

export type Step = {
  /**
   * The id of the step. Assigned by the database.
   */
  id: string;
  /**
   * The surface that this agent step was initiated from.
   */
  origin?: string | null;
  /**
   * The unique identifier of the organization associated with the step.
   */
  organization_id?: string | null;
  /**
   * The unique identifier of the provider that was configured for this step
   */
  provider_id?: string | null;
  /**
   * The unique identifier of the job that this step belongs to. Only included for async calls.
   */
  job_id?: string | null;
  /**
   * The ID of the agent that performed the step.
   */
  agent_id?: string | null;
  /**
   * The name of the provider used for this step.
   */
  provider_name?: string | null;
  /**
   * The category of the provider used for this step.
   */
  provider_category?: string | null;
  /**
   * The name of the model used for this step.
   */
  model?: string | null;
  /**
   * The model endpoint url used for this step.
   */
  model_endpoint?: string | null;
  /**
   * The context window limit configured for this step.
   */
  context_window_limit?: number | null;
  /**
   * The number of tokens generated by the agent during this step.
   */
  completion_tokens?: number | null;
  /**
   * The number of tokens in the prompt during this step.
   */
  prompt_tokens?: number | null;
  /**
   * The total number of tokens processed by the agent during this step.
   */
  total_tokens?: number | null;
  /**
   * Metadata for the agent.
   */
  completion_tokens_details?: {
    [key: string]: unknown;
  } | null;
  /**
   * The stop reason associated with the step.
   */
  stop_reason?: StopReasonType | null;
  /**
   * Metadata tags.
   */
  tags?: Array<string>;
  /**
   * The unique identifier of the transaction that processed this step.
   */
  tid?: string | null;
  /**
   * The trace id of the agent step.
   */
  trace_id?: string | null;
  /**
   * The messages generated during this step.
   */
  messages?: Array<Message>;
  /**
   * The feedback for this step. Must be either 'positive' or 'negative'.
   */
  feedback?: 'positive' | 'negative' | null;
  /**
   * The project that the agent that executed this step belongs to (cloud only).
   */
  project_id?: string | null;
  /**
   * The type/class of the error that occurred
   */
  error_type?: string | null;
  /**
   * Error details including message, traceback, and additional context
   */
  error_data?: {
    [key: string]: unknown;
  } | null;
  /**
   * Step status: pending, success, or failed
   */
  status?: StepStatus | null;
};

/**
 * Status of a step execution
 */
export type StepStatus = 'pending' | 'success' | 'failed' | 'cancelled';

export type StopReasonType =
  | 'end_turn'
  | 'error'
  | 'invalid_tool_call'
  | 'max_steps'
  | 'no_tool_call'
  | 'tool_rule'
  | 'cancelled';

/**
 * Configuration for an MCP server using Streamable HTTP
 *
 * Authentication can be provided in multiple ways:
 * 1. Using auth_header + auth_token: Will add a specific header with the token
 * Example: auth_header="Authorization", auth_token="Bearer abc123"
 *
 * 2. Using the custom_headers dict: For more complex authentication scenarios
 * Example: custom_headers={"X-API-Key": "abc123", "X-Custom-Header": "value"}
 */
export type StreamableHTTPServerConfig = {
  /**
   * The name of the server
   */
  server_name: string;
  type?: MCPServerType;
  /**
   * The URL path for the streamable HTTP server (e.g., 'example/mcp')
   */
  server_url: string;
  /**
   * The name of the authentication header (e.g., 'Authorization')
   */
  auth_header?: string | null;
  /**
   * The authentication token or API key value
   */
  auth_token?: string | null;
  /**
   * Custom HTTP headers to include with streamable HTTP requests
   */
  custom_headers?: {
    [key: string]: string;
  } | null;
};

export type SupervisorManager = {
  manager_type?: 'supervisor';
  manager_agent_id: string;
};

export type SupervisorManagerUpdate = {
  manager_type?: 'supervisor';
  manager_agent_id: string | null;
};

/**
 * A message generated by the system. Never streamed back on a response, only used for cursor pagination.
 *
 * Args:
 * id (str): The ID of the message
 * date (datetime): The date the message was created in ISO format
 * name (Optional[str]): The name of the sender of the message
 * content (str): The message content sent by the system
 */
export type SystemMessage = {
  id: string;
  date: string;
  name?: string | null;
  /**
   * The type of the message.
   */
  message_type?: 'system_message';
  otid?: string | null;
  sender_id?: string | null;
  step_id?: string | null;
  is_err?: boolean | null;
  /**
   * The message content sent by the system
   */
  content: string;
};

export type TagSchema = {
  tag: string;
};

/**
 * Represents a terminal tool rule configuration where if this tool gets called, it must end the agent loop.
 */
export type TerminalToolRule = {
  /**
   * The name of the tool. Must exist in the database for the user's organization.
   */
  tool_name: string;
  type?: 'exit_loop';
  /**
   * Optional Jinja2 template for generating agent prompt about this tool rule.
   */
  prompt_template?: string | null;
};

export type TextContent = {
  /**
   * The type of the message.
   */
  type?: 'text';
  /**
   * The text content of the message.
   */
  text: string;
};

/**
 * Response format for plain text responses.
 */
export type TextResponseFormat = {
  /**
   * The type of the response format.
   */
  type?: 'text';
};

/**
 * Representation of a tool, which is a function that can be called by the agent.
 *
 * Parameters:
 * id (str): The unique identifier of the tool.
 * name (str): The name of the function.
 * tags (List[str]): Metadata tags.
 * source_code (str): The source code of the function.
 * json_schema (Dict): The JSON schema of the function.
 */
export type Tool = {
  /**
   * The human-friendly ID of the Tool
   */
  id?: string;
  /**
   * The type of the tool.
   */
  tool_type?: ToolType;
  /**
   * The description of the tool.
   */
  description?: string | null;
  /**
   * The type of the source code.
   */
  source_type?: string | null;
  /**
   * The name of the function.
   */
  name?: string | null;
  /**
   * Metadata tags.
   */
  tags?: Array<string>;
  /**
   * The source code of the function.
   */
  source_code?: string | null;
  /**
   * The JSON schema of the function.
   */
  json_schema?: {
    [key: string]: unknown;
  } | null;
  /**
   * The args JSON schema of the function.
   */
  args_json_schema?: {
    [key: string]: unknown;
  } | null;
  /**
   * The maximum number of characters in the response.
   */
  return_char_limit?: number;
  /**
   * Optional list of pip packages required by this tool.
   */
  pip_requirements?: Array<PipRequirement> | null;
  /**
   * Optional list of npm packages required by this tool.
   */
  npm_requirements?: Array<NpmRequirement> | null;
  /**
   * The id of the user that made this Tool.
   */
  created_by_id?: string | null;
  /**
   * The id of the user that made this Tool.
   */
  last_updated_by_id?: string | null;
  /**
   * A dictionary of additional metadata for the tool.
   */
  metadata_?: {
    [key: string]: unknown;
  } | null;
};

/**
 * Additional properties describing a Tool to clients.
 *
 * NOTE: all properties in ToolAnnotations are **hints**.
 * They are not guaranteed to provide a faithful description of
 * tool behavior (including descriptive properties like `title`).
 *
 * Clients should never make tool use decisions based on ToolAnnotations
 * received from untrusted servers.
 */
export type ToolAnnotations = {
  title?: string | null;
  readOnlyHint?: boolean | null;
  destructiveHint?: boolean | null;
  idempotentHint?: boolean | null;
  openWorldHint?: boolean | null;
  [key: string]: unknown;
};

export type ToolCall = {
  name: string;
  arguments: string;
  tool_call_id: string;
};

export type ToolCallContent = {
  /**
   * Indicates this content represents a tool call event.
   */
  type?: 'tool_return';
  /**
   * A unique identifier for this specific tool call instance.
   */
  id: string;
  /**
   * The name of the tool being called.
   */
  name: string;
  /**
   * The parameters being passed to the tool, structured as a dictionary of parameter names to values.
   */
  input: {
    [key: string]: unknown;
  };
};

export type ToolCallDelta = {
  name?: string | null;
  arguments?: string | null;
  tool_call_id?: string | null;
};

/**
 * A message representing a request to call a tool (generated by the LLM to trigger tool execution).
 *
 * Args:
 * id (str): The ID of the message
 * date (datetime): The date the message was created in ISO format
 * name (Optional[str]): The name of the sender of the message
 * tool_call (Union[ToolCall, ToolCallDelta]): The tool call
 */
export type ToolCallMessage = {
  id: string;
  date: string;
  name?: string | null;
  /**
   * The type of the message.
   */
  message_type?: 'tool_call_message';
  otid?: string | null;
  sender_id?: string | null;
  step_id?: string | null;
  is_err?: boolean | null;
  tool_call: ToolCall | ToolCallDelta;
};

export type ToolCreate = {
  /**
   * The description of the tool.
   */
  description?: string | null;
  /**
   * Metadata tags.
   */
  tags?: Array<string>;
  /**
   * The source code of the function.
   */
  source_code: string;
  /**
   * The source type of the function.
   */
  source_type?: string;
  /**
   * The JSON schema of the function (auto-generated from source_code if not provided)
   */
  json_schema?: {
    [key: string]: unknown;
  } | null;
  /**
   * The args JSON schema of the function.
   */
  args_json_schema?: {
    [key: string]: unknown;
  } | null;
  /**
   * The maximum number of characters in the response.
   */
  return_char_limit?: number;
  /**
   * Optional list of pip packages required by this tool.
   */
  pip_requirements?: Array<PipRequirement> | null;
  /**
   * Optional list of npm packages required by this tool.
   */
  npm_requirements?: Array<NpmRequirement> | null;
};

export type ToolEnvVarSchema = {
  created_at: string;
  description: string | null;
  key: string;
  updated_at: string;
  value: string;
};

export type ToolJSONSchema = {
  name: string;
  description: string;
  parameters: ParametersSchema;
  type?: string | null;
  required?: Array<string> | null;
};

export type ToolReturn = {
  /**
   * The status of the tool call
   */
  status: 'success' | 'error';
  /**
   * Captured stdout (e.g. prints, logs) from the tool invocation
   */
  stdout?: Array<string> | null;
  /**
   * Captured stderr from the tool invocation
   */
  stderr?: Array<string> | null;
};

/**
 * The status of the tool call
 */
export type status = 'success' | 'error';

export type ToolReturnContent = {
  /**
   * Indicates this content represents a tool return event.
   */
  type?: 'ToolReturnContent';
  /**
   * References the ID of the ToolCallContent that initiated this tool call.
   */
  tool_call_id: string;
  /**
   * The content returned by the tool execution.
   */
  content: string;
  /**
   * Indicates whether the tool execution resulted in an error.
   */
  is_error: boolean;
};

/**
 * A message representing the return value of a tool call (generated by Letta executing the requested tool).
 *
 * Args:
 * id (str): The ID of the message
 * date (datetime): The date the message was created in ISO format
 * name (Optional[str]): The name of the sender of the message
 * tool_return (str): The return value of the tool
 * status (Literal["success", "error"]): The status of the tool call
 * tool_call_id (str): A unique identifier for the tool call that generated this message
 * stdout (Optional[List(str)]): Captured stdout (e.g. prints, logs) from the tool invocation
 * stderr (Optional[List(str)]): Captured stderr from the tool invocation
 */
export type ToolReturnMessage = {
  id: string;
  date: string;
  name?: string | null;
  /**
   * The type of the message.
   */
  message_type?: 'tool_return_message';
  otid?: string | null;
  sender_id?: string | null;
  step_id?: string | null;
  is_err?: boolean | null;
  tool_return: string;
  status: 'success' | 'error';
  tool_call_id: string;
  stdout?: Array<string> | null;
  stderr?: Array<string> | null;
};

export type ToolRunFromSource = {
  /**
   * The source code of the function.
   */
  source_code: string;
  /**
   * The arguments to pass to the tool.
   */
  args: {
    [key: string]: unknown;
  };
  /**
   * The environment variables to pass to the tool.
   */
  env_vars?: {
    [key: string]: string;
  };
  /**
   * The name of the tool to run.
   */
  name?: string | null;
  /**
   * The type of the source code.
   */
  source_type?: string | null;
  /**
   * The args JSON schema of the function.
   */
  args_json_schema?: {
    [key: string]: unknown;
  } | null;
  /**
   * The JSON schema of the function (auto-generated from source_code if not provided)
   */
  json_schema?: {
    [key: string]: unknown;
  } | null;
  /**
   * Optional list of pip packages required by this tool.
   */
  pip_requirements?: Array<PipRequirement> | null;
  /**
   * Optional list of npm packages required by this tool.
   */
  npm_requirements?: Array<NpmRequirement> | null;
};

export type ToolType =
  | 'custom'
  | 'letta_core'
  | 'letta_memory_core'
  | 'letta_multi_agent_core'
  | 'letta_sleeptime_core'
  | 'letta_voice_sleeptime_core'
  | 'letta_builtin'
  | 'letta_files_core'
  | 'external_composio'
  | 'external_langchain'
  | 'external_mcp';

export type ToolUpdate = {
  /**
   * The description of the tool.
   */
  description?: string | null;
  /**
   * Metadata tags.
   */
  tags?: Array<string> | null;
  /**
   * The source code of the function.
   */
  source_code?: string | null;
  /**
   * The type of the source code.
   */
  source_type?: string | null;
  /**
   * The JSON schema of the function (auto-generated from source_code if not provided)
   */
  json_schema?: {
    [key: string]: unknown;
  } | null;
  /**
   * The args JSON schema of the function.
   */
  args_json_schema?: {
    [key: string]: unknown;
  } | null;
  /**
   * The maximum number of characters in the response.
   */
  return_char_limit?: number | null;
  /**
   * Optional list of pip packages required by this tool.
   */
  pip_requirements?: Array<PipRequirement> | null;
  /**
   * Optional list of npm packages required by this tool.
   */
  npm_requirements?: Array<NpmRequirement> | null;
};

export type UpdateAgent = {
  /**
   * The name of the agent.
   */
  name?: string | null;
  /**
   * The ids of the tools used by the agent.
   */
  tool_ids?: Array<string> | null;
  /**
   * The ids of the sources used by the agent.
   */
  source_ids?: Array<string> | null;
  /**
   * The ids of the blocks used by the agent.
   */
  block_ids?: Array<string> | null;
  /**
   * The tags associated with the agent.
   */
  tags?: Array<string> | null;
  /**
   * The system prompt used by the agent.
   */
  system?: string | null;
  /**
   * The tool rules governing the agent.
   */
  tool_rules?: Array<
    | ChildToolRule
    | InitToolRule
    | TerminalToolRule
    | ConditionalToolRule
    | ContinueToolRule
    | RequiredBeforeExitToolRule
    | MaxCountPerStepToolRule
    | ParentToolRule
  > | null;
  /**
   * The LLM configuration used by the agent.
   */
  llm_config?: LLMConfig | null;
  /**
   * The embedding configuration used by the agent.
   */
  embedding_config?: EmbeddingConfig | null;
  /**
   * The ids of the messages in the agent's in-context memory.
   */
  message_ids?: Array<string> | null;
  /**
   * The description of the agent.
   */
  description?: string | null;
  /**
   * The metadata of the agent.
   */
  metadata?: {
    [key: string]: unknown;
  } | null;
  /**
   * The environment variables for tool execution specific to this agent.
   */
  tool_exec_environment_variables?: {
    [key: string]: string;
  } | null;
  /**
   * The id of the project the agent belongs to.
   */
  project_id?: string | null;
  /**
   * The id of the template the agent belongs to.
   */
  template_id?: string | null;
  /**
   * The base template id of the agent.
   */
  base_template_id?: string | null;
  /**
   * The ids of the identities associated with this agent.
   */
  identity_ids?: Array<string> | null;
  /**
   * If set to True, the agent will not remember previous messages (though the agent will still retain state via core memory blocks and archival/recall memory). Not recommended unless you have an advanced use case.
   */
  message_buffer_autoclear?: boolean | null;
  /**
   * The LLM configuration handle used by the agent, specified in the format provider/model-name, as an alternative to specifying llm_config.
   */
  model?: string | null;
  /**
   * The embedding configuration handle used by the agent, specified in the format provider/model-name.
   */
  embedding?: string | null;
  /**
   * Whether to enable reasoning for this agent.
   */
  reasoning?: boolean | null;
  /**
   * If set to True, memory management will move to a background agent thread.
   */
  enable_sleeptime?: boolean | null;
  /**
   * The response format for the agent.
   */
  response_format?:
    | TextResponseFormat
    | JsonSchemaResponseFormat
    | JsonObjectResponseFormat
    | null;
  /**
   * The timestamp when the agent last completed a run.
   */
  last_run_completion?: string | null;
  /**
   * The duration in milliseconds of the agent's last run.
   */
  last_run_duration_ms?: number | null;
  /**
   * The timezone of the agent (IANA format).
   */
  timezone?: string | null;
  /**
   * Maximum number of files that can be open at once for this agent. Setting this too high may exceed the context window, which will break the agent.
   */
  max_files_open?: number | null;
  /**
   * The per-file view window character limit for this agent. Setting this too high may exceed the context window, which will break the agent.
   */
  per_file_view_window_char_limit?: number | null;
  /**
   * If set to True, the agent will be hidden.
   */
  hidden?: boolean | null;
};

export type UpdateAssistantMessage = {
  message_type?: 'assistant_message';
  /**
   * The message content sent by the assistant (can be a string or an array of content parts)
   */
  content: Array<LettaAssistantMessageContentUnion> | string;
};

export type UpdateReasoningMessage = {
  reasoning: string;
  message_type?: 'reasoning_message';
};

/**
 * Update an SSE MCP server
 */
export type UpdateSSEMCPServer = {
  /**
   * The name of the server
   */
  server_name?: string | null;
  /**
   * The URL of the server (MCP SSE client will connect to this URL)
   */
  server_url?: string | null;
  /**
   * The access token or API key for the MCP server (used for SSE authentication)
   */
  token?: string | null;
  /**
   * Custom authentication headers as key-value pairs
   */
  custom_headers?: {
    [key: string]: string;
  } | null;
};

/**
 * Update a Stdio MCP server
 */
export type UpdateStdioMCPServer = {
  /**
   * The name of the server
   */
  server_name?: string | null;
  /**
   * The configuration for the server (MCP 'local' client will run this command)
   */
  stdio_config?: StdioServerConfig | null;
};

/**
 * Update a Streamable HTTP MCP server
 */
export type UpdateStreamableHTTPMCPServer = {
  /**
   * The name of the server
   */
  server_name?: string | null;
  /**
   * The URL path for the streamable HTTP server (e.g., 'example/mcp')
   */
  server_url?: string | null;
  /**
   * The name of the authentication header (e.g., 'Authorization')
   */
  auth_header?: string | null;
  /**
   * The authentication token or API key value
   */
  auth_token?: string | null;
  /**
   * Custom authentication headers as key-value pairs
   */
  custom_headers?: {
    [key: string]: string;
  } | null;
};

export type UpdateSystemMessage = {
  message_type?: 'system_message';
  /**
   * The message content sent by the system (can be a string or an array of multi-modal content parts)
   */
  content: string;
};

export type UpdateUserMessage = {
  message_type?: 'user_message';
  /**
   * The message content sent by the user (can be a string or an array of multi-modal content parts)
   */
  content: Array<LettaUserMessageContentUnion> | string;
};

export type UrlImage = {
  /**
   * The source type for the image.
   */
  type?: 'url';
  /**
   * The URL of the image.
   */
  url: string;
};

export type UsageStatistics = {
  completion_tokens?: number;
  prompt_tokens?: number;
  total_tokens?: number;
  prompt_tokens_details?: UsageStatisticsPromptTokenDetails | null;
  completion_tokens_details?: UsageStatisticsCompletionTokenDetails | null;
};

export type UsageStatisticsCompletionTokenDetails = {
  reasoning_tokens?: number;
};

export type UsageStatisticsPromptTokenDetails = {
  cached_tokens?: number;
};

/**
 * Representation of a user.
 *
 * Parameters:
 * id (str): The unique identifier of the user.
 * name (str): The name of the user.
 * created_at (datetime): The creation date of the user.
 */
export type User = {
  /**
   * The human-friendly ID of the User
   */
  id?: string;
  /**
   * The organization id of the user
   */
  organization_id?: string | null;
  /**
   * The name of the user.
   */
  name: string;
  /**
   * The creation date of the user.
   */
  created_at?: string | null;
  /**
   * The update date of the user.
   */
  updated_at?: string | null;
  /**
   * Whether this user is deleted or not.
   */
  is_deleted?: boolean;
};

export type UserCreate = {
  /**
   * The name of the user.
   */
  name: string;
  /**
   * The organization id of the user.
   */
  organization_id: string;
};

/**
 * A message sent by the user. Never streamed back on a response, only used for cursor pagination.
 *
 * Args:
 * id (str): The ID of the message
 * date (datetime): The date the message was created in ISO format
 * name (Optional[str]): The name of the sender of the message
 * content (Union[str, List[LettaUserMessageContentUnion]]): The message content sent by the user (can be a string or an array of multi-modal content parts)
 */
export type UserMessage = {
  id: string;
  date: string;
  name?: string | null;
  /**
   * The type of the message.
   */
  message_type?: 'user_message';
  otid?: string | null;
  sender_id?: string | null;
  step_id?: string | null;
  is_err?: boolean | null;
  /**
   * The message content sent by the user (can be a string or an array of multi-modal content parts)
   */
  content: Array<LettaUserMessageContentUnion> | string;
};

export type UserUpdate = {
  /**
   * The id of the user to update.
   */
  id: string;
  /**
   * The new name of the user.
   */
  name?: string | null;
  /**
   * The new organization id of the user.
   */
  organization_id?: string | null;
};

export type ValidationError = {
  loc: Array<string | number>;
  msg: string;
  type: string;
};

export type VoiceSleeptimeManager = {
  manager_type?: 'voice_sleeptime';
  manager_agent_id: string;
  /**
   * The desired maximum length of messages in the context window of the convo agent. This is a best effort, and may be off slightly due to user/assistant interleaving.
   */
  max_message_buffer_length?: number | null;
  /**
   * The desired minimum length of messages in the context window of the convo agent. This is a best effort, and may be off-by-one due to user/assistant interleaving.
   */
  min_message_buffer_length?: number | null;
};

export type VoiceSleeptimeManagerUpdate = {
  manager_type?: 'voice_sleeptime';
  manager_agent_id?: string | null;
  /**
   * The desired maximum length of messages in the context window of the convo agent. This is a best effort, and may be off slightly due to user/assistant interleaving.
   */
  max_message_buffer_length?: number | null;
  /**
   * The desired minimum length of messages in the context window of the convo agent. This is a best effort, and may be off-by-one due to user/assistant interleaving.
   */
  min_message_buffer_length?: number | null;
};

export type WebSearchOptions = {
  search_context_size?: 'low' | 'medium' | 'high';
  user_location?: WebSearchOptionsUserLocation | null;
};

export type search_context_size = 'low' | 'medium' | 'high';

export type WebSearchOptionsUserLocation = {
  approximate: WebSearchOptionsUserLocationApproximate;
  type: 'approximate';
};

export type WebSearchOptionsUserLocationApproximate = {
  city?: string;
  country?: string;
  region?: string;
  timezone?: string;
};

/**
 * Agent with human-readable ID for agent file
 */
export type letta__schemas__agent_file__AgentSchema = {
  /**
   * The name of the agent.
   */
  name?: string;
  /**
   * The blocks to create in the agent's in-context memory.
   */
  memory_blocks?: Array<CreateBlock> | null;
  /**
   * The tools used by the agent.
   */
  tools?: Array<string> | null;
  /**
   * The ids of the tools used by the agent.
   */
  tool_ids?: Array<string> | null;
  /**
   * The ids of the sources used by the agent.
   */
  source_ids?: Array<string> | null;
  /**
   * The ids of the blocks used by the agent.
   */
  block_ids?: Array<string> | null;
  /**
   * The tool rules governing the agent.
   */
  tool_rules?: Array<
    | ChildToolRule
    | InitToolRule
    | TerminalToolRule
    | ConditionalToolRule
    | ContinueToolRule
    | RequiredBeforeExitToolRule
    | MaxCountPerStepToolRule
    | ParentToolRule
  > | null;
  /**
   * The tags associated with the agent.
   */
  tags?: Array<string> | null;
  /**
   * The system prompt used by the agent.
   */
  system?: string | null;
  /**
   * The type of agent.
   */
  agent_type?: AgentType;
  /**
   * The LLM configuration used by the agent.
   */
  llm_config?: LLMConfig | null;
  /**
   * The embedding configuration used by the agent.
   */
  embedding_config?: EmbeddingConfig | null;
  /**
   * The initial set of messages to put in the agent's in-context memory.
   */
  initial_message_sequence?: Array<MessageCreate> | null;
  /**
   * If true, attaches the Letta core tools (e.g. core_memory related functions).
   */
  include_base_tools?: boolean;
  /**
   * If true, attaches the Letta multi-agent tools (e.g. sending a message to another agent).
   */
  include_multi_agent_tools?: boolean;
  /**
   * If true, attaches the Letta base tool rules (e.g. deny all tools not explicitly allowed).
   */
  include_base_tool_rules?: boolean | null;
  /**
   * If true, automatically creates and attaches a default data source for this agent.
   */
  include_default_source?: boolean;
  /**
   * The description of the agent.
   */
  description?: string | null;
  /**
   * The metadata of the agent.
   */
  metadata?: {
    [key: string]: unknown;
  } | null;
  /**
   * The LLM configuration handle used by the agent, specified in the format provider/model-name, as an alternative to specifying llm_config.
   */
  model?: string | null;
  /**
   * The embedding configuration handle used by the agent, specified in the format provider/model-name.
   */
  embedding?: string | null;
  /**
   * The context window limit used by the agent.
   */
  context_window_limit?: number | null;
  /**
   * The embedding chunk size used by the agent.
   */
  embedding_chunk_size?: number | null;
  /**
   * The maximum number of tokens to generate, including reasoning step. If not set, the model will use its default value.
   */
  max_tokens?: number | null;
  /**
   * The maximum number of tokens to generate for reasoning step. If not set, the model will use its default value.
   */
  max_reasoning_tokens?: number | null;
  /**
   * Whether to enable internal extended thinking step for a reasoner model.
   */
  enable_reasoner?: boolean | null;
  /**
   * Whether to enable reasoning for this agent.
   */
  reasoning?: boolean | null;
  /**
   * The template id used to configure the agent
   */
  from_template?: string | null;
  /**
   * Whether the agent is a template
   */
  template?: boolean;
  /**
   * Deprecated: Project should now be passed via the X-Project header instead of in the request body. If using the sdk, this can be done via the new x_project field below.
   * @deprecated
   */
  project?: string | null;
  /**
   * The environment variables for tool execution specific to this agent.
   */
  tool_exec_environment_variables?: {
    [key: string]: string;
  } | null;
  /**
   * The variables that should be set for the agent.
   */
  memory_variables?: {
    [key: string]: string;
  } | null;
  /**
   * The id of the project the agent belongs to.
   */
  project_id?: string | null;
  /**
   * The id of the template the agent belongs to.
   */
  template_id?: string | null;
  /**
   * The base template id of the agent.
   */
  base_template_id?: string | null;
  /**
   * The ids of the identities associated with this agent.
   */
  identity_ids?: Array<string> | null;
  /**
   * If set to True, the agent will not remember previous messages (though the agent will still retain state via core memory blocks and archival/recall memory). Not recommended unless you have an advanced use case.
   */
  message_buffer_autoclear?: boolean;
  /**
   * If set to True, memory management will move to a background agent thread.
   */
  enable_sleeptime?: boolean | null;
  /**
   * The response format for the agent.
   */
  response_format?:
    | TextResponseFormat
    | JsonSchemaResponseFormat
    | JsonObjectResponseFormat
    | null;
  /**
   * The timezone of the agent (IANA format).
   */
  timezone?: string | null;
  /**
   * Maximum number of files that can be open at once for this agent. Setting this too high may exceed the context window, which will break the agent.
   */
  max_files_open?: number | null;
  /**
   * The per-file view window character limit for this agent. Setting this too high may exceed the context window, which will break the agent.
   */
  per_file_view_window_char_limit?: number | null;
  /**
   * If set to True, the agent will be hidden.
   */
  hidden?: boolean | null;
  /**
   * Human-readable identifier for this agent in the file
   */
  id: string;
  /**
   * List of message IDs that are currently in the agent's context
   */
  in_context_message_ids?: Array<string>;
  /**
   * List of messages in the agent's conversation history
   */
  messages?: Array<letta__schemas__agent_file__MessageSchema>;
  /**
   * List of file-agent relationships for this agent
   */
  files_agents?: Array<FileAgentSchema>;
  /**
   * List of groups that the agent manages
   */
  group_ids?: Array<string>;
};

/**
 * Message with human-readable ID for agent file
 */
export type letta__schemas__agent_file__MessageSchema = {
  /**
   * The role of the participant.
   */
  role: MessageRole;
  /**
   * The content of the message.
   */
  content: Array<LettaMessageContentUnion> | string;
  /**
   * The name of the participant.
   */
  name?: string | null;
  /**
   * The offline threading id associated with this message
   */
  otid?: string | null;
  /**
   * The id of the sender of the message, can be an identity id or agent id
   */
  sender_id?: string | null;
  /**
   * The id of the LLMBatchItem that this message is associated with
   */
  batch_item_id?: string | null;
  /**
   * The multi-agent group that the message was sent in
   */
  group_id?: string | null;
  /**
   * Human-readable identifier for this message in the file
   */
  id: string;
  /**
   * The model used to make the function call
   */
  model?: string | null;
  /**
   * The unique identifier of the agent
   */
  agent_id?: string | null;
};

/**
 * Tool with human-readable ID for agent file
 */
export type letta__schemas__agent_file__ToolSchema = {
  /**
   * Human-readable identifier for this tool in the file
   */
  id: string;
  /**
   * The type of the tool.
   */
  tool_type?: ToolType;
  /**
   * The description of the tool.
   */
  description?: string | null;
  /**
   * The type of the source code.
   */
  source_type?: string | null;
  /**
   * The name of the function.
   */
  name?: string | null;
  /**
   * Metadata tags.
   */
  tags?: Array<string>;
  /**
   * The source code of the function.
   */
  source_code?: string | null;
  /**
   * The JSON schema of the function.
   */
  json_schema?: {
    [key: string]: unknown;
  } | null;
  /**
   * The args JSON schema of the function.
   */
  args_json_schema?: {
    [key: string]: unknown;
  } | null;
  /**
   * The maximum number of characters in the response.
   */
  return_char_limit?: number;
  /**
   * Optional list of pip packages required by this tool.
   */
  pip_requirements?: Array<PipRequirement> | null;
  /**
   * Optional list of npm packages required by this tool.
   */
  npm_requirements?: Array<NpmRequirement> | null;
  /**
   * The id of the user that made this Tool.
   */
  created_by_id?: string | null;
  /**
   * The id of the user that made this Tool.
   */
  last_updated_by_id?: string | null;
  /**
   * A dictionary of additional metadata for the tool.
   */
  metadata_?: {
    [key: string]: unknown;
  } | null;
};

export type letta__serialize_schemas__pydantic_agent_schema__AgentSchema = {
  agent_type: string;
  core_memory: Array<CoreMemoryBlockSchema>;
  created_at: string;
  description: string | null;
  embedding_config: EmbeddingConfig;
  llm_config: LLMConfig;
  message_buffer_autoclear: boolean;
  in_context_message_indices: Array<number>;
  messages: Array<letta__serialize_schemas__pydantic_agent_schema__MessageSchema>;
  metadata_?: {
    [key: string]: unknown;
  } | null;
  multi_agent_group: unknown | null;
  name: string;
  system: string;
  tags: Array<TagSchema>;
  tool_exec_environment_variables: Array<ToolEnvVarSchema>;
  tool_rules: Array<
    | BaseToolRuleSchema
    | ChildToolRuleSchema
    | MaxCountPerStepToolRuleSchema
    | ConditionalToolRuleSchema
  >;
  tools: Array<letta__serialize_schemas__pydantic_agent_schema__ToolSchema>;
  updated_at: string;
  version: string;
};

export type letta__serialize_schemas__pydantic_agent_schema__MessageSchema = {
  created_at: string;
  group_id: string | null;
  model: string | null;
  name: string | null;
  role: string;
  content: Array<LettaMessageContentUnion>;
  tool_call_id: string | null;
  tool_calls: Array<unknown>;
  tool_returns: Array<unknown>;
  updated_at: string;
};

export type letta__serialize_schemas__pydantic_agent_schema__ToolSchema = {
  args_json_schema: unknown | null;
  created_at: string;
  description: string;
  json_schema: ToolJSONSchema;
  name: string;
  return_char_limit: number;
  source_code: string | null;
  source_type: string;
  tags: Array<string>;
  tool_type: string;
  updated_at: string;
  metadata_?: {
    [key: string]: unknown;
  } | null;
};

export type openai__types__chat__chat_completion_message_tool_call_param__Function =
  {
    arguments: string;
    name: string;
  };

export type openai__types__chat__chat_completion_named_tool_choice_param__Function =
  {
    name: string;
  };

export type openai__types__chat__completion_create_params__Function = {
  name: string;
  description?: string;
  parameters?: {
    [key: string]: unknown;
  };
};

export type LettaMessageUnion =
  | SystemMessage
  | UserMessage
  | ReasoningMessage
  | HiddenReasoningMessage
  | ToolCallMessage
  | ToolReturnMessage
  | AssistantMessage;

export type LettaMessageContentUnion =
  | TextContent
  | ImageContent
  | ToolCallContent
  | ToolReturnContent
  | ReasoningContent
  | RedactedReasoningContent
  | OmittedReasoningContent;

export type LettaAssistantMessageContentUnion = TextContent;

export type LettaUserMessageContentUnion = TextContent | ImageContent;

/**
 * Ping messages are a keep-alive to prevent SSE streams from timing out during long running requests.
 */
export type LettaPing = {
  /**
   * The type of the message.
   */
  message_type: 'ping';
};

export type DeleteToolData = {
  toolId: string;
  userId?: string | null;
};

export type DeleteToolResponse = unknown;

export type RetrieveToolData = {
  toolId: string;
  userId?: string | null;
};

export type RetrieveToolResponse = Tool;

export type ModifyToolData = {
  requestBody: ToolUpdate;
  toolId: string;
  userId?: string | null;
};

export type ModifyToolResponse = Tool;

export type CountToolsData = {
  /**
   * Include built-in Letta tools in the count
   */
  includeBaseTools?: boolean | null;
  userId?: string | null;
};

export type CountToolsResponse = number;

export type ListToolsData = {
  after?: string | null;
  limit?: number | null;
  name?: string | null;
  userId?: string | null;
};

export type ListToolsResponse = Array<Tool>;

export type CreateToolData = {
  requestBody: ToolCreate;
  userId?: string | null;
};

export type CreateToolResponse = Tool;

export type UpsertToolData = {
  requestBody: ToolCreate;
  userId?: string | null;
};

export type UpsertToolResponse = Tool;

export type AddBaseToolsData = {
  userId?: string | null;
};

export type AddBaseToolsResponse = Array<Tool>;

export type RunToolFromSourceData = {
  requestBody: ToolRunFromSource;
  userId?: string | null;
};

export type RunToolFromSourceResponse = ToolReturnMessage;

export type ListComposioAppsData = {
  userId?: string | null;
};

export type ListComposioAppsResponse = Array<AppModel>;

export type ListComposioActionsByAppData = {
  composioAppName: string;
  userId?: string | null;
};

export type ListComposioActionsByAppResponse = Array<ActionModel>;

export type AddComposioToolData = {
  composioActionName: string;
  userId?: string | null;
};

export type AddComposioToolResponse = Tool;

export type ListMcpServersData = {
  userId?: string | null;
};

export type ListMcpServersResponse = {
  [key: string]:
    | SSEServerConfig
    | StdioServerConfig
    | StreamableHTTPServerConfig;
};

export type AddMcpServerData = {
  requestBody: StdioServerConfig | SSEServerConfig | StreamableHTTPServerConfig;
  userId?: string | null;
};

export type AddMcpServerResponse = Array<
  StdioServerConfig | SSEServerConfig | StreamableHTTPServerConfig
>;

export type ListMcpToolsByServerData = {
  mcpServerName: string;
  userId?: string | null;
};

export type ListMcpToolsByServerResponse = Array<MCPTool>;

export type AddMcpToolData = {
  mcpServerName: string;
  mcpToolName: string;
  userId?: string | null;
};

export type AddMcpToolResponse = Tool;

export type UpdateMcpServerData = {
  mcpServerName: string;
  requestBody:
    | UpdateStdioMCPServer
    | UpdateSSEMCPServer
    | UpdateStreamableHTTPMCPServer;
  userId?: string | null;
};

export type UpdateMcpServerResponse =
  | StdioServerConfig
  | SSEServerConfig
  | StreamableHTTPServerConfig;

export type DeleteMcpServerData = {
  mcpServerName: string;
  userId?: string | null;
};

export type DeleteMcpServerResponse = Array<
  StdioServerConfig | SSEServerConfig | StreamableHTTPServerConfig
>;

export type TestMcpServerData = {
  requestBody: StdioServerConfig | SSEServerConfig | StreamableHTTPServerConfig;
  userId?: string | null;
};

export type TestMcpServerResponse = unknown;

export type ConnectMcpServerData = {
  requestBody: StdioServerConfig | SSEServerConfig | StreamableHTTPServerConfig;
  userId?: string | null;
};

export type ConnectMcpServerResponse = unknown;

export type GenerateJsonSchemaData = {
  requestBody: CodeInput;
  userId?: string | null;
};

export type GenerateJsonSchemaResponse = {
  [key: string]: unknown;
};

export type McpOauthCallbackData = {
  /**
   * OAuth authorization code
   */
  code?: string | null;
  /**
   * OAuth error
   */
  error?: string | null;
  /**
   * OAuth error description
   */
  errorDescription?: string | null;
  sessionId: string;
  /**
   * OAuth state parameter
   */
  state?: string | null;
};

export type McpOauthCallbackResponse = unknown;

export type GenerateToolData = {
  requestBody: GenerateToolInput;
  userId?: string | null;
};

export type GenerateToolResponse = GenerateToolOutput;

export type CountSourcesData = {
  userId?: string | null;
};

export type CountSourcesResponse = number;

export type RetrieveSourceData = {
  sourceId: string;
  userId?: string | null;
};

export type RetrieveSourceResponse = Source;

export type ModifySourceData = {
  requestBody: SourceUpdate;
  sourceId: string;
  userId?: string | null;
};

export type ModifySourceResponse = Source;

export type DeleteSourceData = {
  sourceId: string;
  userId?: string | null;
};

export type DeleteSourceResponse = unknown;

export type GetSourceIdByNameData = {
  sourceName: string;
  userId?: string | null;
};

export type GetSourceIdByNameResponse = string;

export type GetSourcesMetadataData = {
  includeDetailedPerSourceMetadata?: boolean;
  userId?: string | null;
};

export type GetSourcesMetadataResponse = OrganizationSourcesStats;

export type ListSourcesData = {
  userId?: string | null;
};

export type ListSourcesResponse = Array<Source>;

export type CreateSourceData = {
  requestBody: SourceCreate;
  userId?: string | null;
};

export type CreateSourceResponse = Source;

export type UploadFileToSourceData = {
  /**
   * How to handle duplicate filenames
   */
  duplicateHandling?: DuplicateFileHandling;
  formData: Body_upload_file_to_source;
  sourceId: string;
  userId?: string | null;
};

export type UploadFileToSourceResponse = FileMetadata;

export type GetAgentsForSourceData = {
  sourceId: string;
  userId?: string | null;
};

export type GetAgentsForSourceResponse = Array<string>;

export type ListSourcePassagesData = {
  /**
   * Message after which to retrieve the returned messages.
   */
  after?: string | null;
  /**
   * Message before which to retrieve the returned messages.
   */
  before?: string | null;
  /**
   * Maximum number of messages to retrieve.
   */
  limit?: number;
  sourceId: string;
  userId?: string | null;
};

export type ListSourcePassagesResponse = Array<Passage>;

export type ListSourceFilesData = {
  /**
   * Pagination cursor to fetch the next set of results
   */
  after?: string | null;
  /**
   * Whether to include full file content
   */
  includeContent?: boolean;
  /**
   * Number of files to return
   */
  limit?: number;
  sourceId: string;
  userId?: string | null;
};

export type ListSourceFilesResponse = Array<FileMetadata>;

export type GetFileMetadataData = {
  fileId: string;
  /**
   * Whether to include full file content
   */
  includeContent?: boolean;
  sourceId: string;
  userId?: string | null;
};

export type GetFileMetadataResponse = FileMetadata;

export type DeleteFileFromSourceData = {
  fileId: string;
  sourceId: string;
  userId?: string | null;
};

export type DeleteFileFromSourceResponse = void;

export type CountFoldersData = {
  userId?: string | null;
};

export type CountFoldersResponse = number;

export type RetrieveFolderData = {
  folderId: string;
  userId?: string | null;
};

export type RetrieveFolderResponse = Folder;

export type ModifyFolderData = {
  folderId: string;
  requestBody: SourceUpdate;
  userId?: string | null;
};

export type ModifyFolderResponse = Folder;

export type DeleteFolderData = {
  folderId: string;
  userId?: string | null;
};

export type DeleteFolderResponse = unknown;

export type GetFolderIdByNameData = {
  folderName: string;
  userId?: string | null;
};

export type GetFolderIdByNameResponse = string;

export type GetFoldersMetadataData = {
  includeDetailedPerSourceMetadata?: boolean;
  userId?: string | null;
};

export type GetFoldersMetadataResponse = OrganizationSourcesStats;

export type ListFoldersData = {
  userId?: string | null;
};

export type ListFoldersResponse = Array<Folder>;

export type CreateFolderData = {
  requestBody: SourceCreate;
  userId?: string | null;
};

export type CreateFolderResponse = Folder;

export type UploadFileToFolderData = {
  /**
   * How to handle duplicate filenames
   */
  duplicateHandling?: DuplicateFileHandling;
  folderId: string;
  formData: Body_upload_file_to_folder;
  userId?: string | null;
};

export type UploadFileToFolderResponse = FileMetadata;

export type GetAgentsForFolderData = {
  folderId: string;
  userId?: string | null;
};

export type GetAgentsForFolderResponse = Array<string>;

export type ListFolderPassagesData = {
  /**
   * Message after which to retrieve the returned messages.
   */
  after?: string | null;
  /**
   * Message before which to retrieve the returned messages.
   */
  before?: string | null;
  folderId: string;
  /**
   * Maximum number of messages to retrieve.
   */
  limit?: number;
  userId?: string | null;
};

export type ListFolderPassagesResponse = Array<Passage>;

export type ListFolderFilesData = {
  /**
   * Pagination cursor to fetch the next set of results
   */
  after?: string | null;
  folderId: string;
  /**
   * Whether to include full file content
   */
  includeContent?: boolean;
  /**
   * Number of files to return
   */
  limit?: number;
  userId?: string | null;
};

export type ListFolderFilesResponse = Array<FileMetadata>;

export type DeleteFileFromFolderData = {
  fileId: string;
  folderId: string;
  userId?: string | null;
};

export type DeleteFileFromFolderResponse = void;

export type ListAgentsData = {
  /**
   * Cursor for pagination
   */
  after?: string | null;
  /**
   * Whether to sort agents oldest to newest (True) or newest to oldest (False, default)
   */
  ascending?: boolean;
  /**
   * Search agents by base template ID
   */
  baseTemplateId?: string | null;
  /**
   * Cursor for pagination
   */
  before?: string | null;
  /**
   * Search agents by identifier keys
   */
  identifierKeys?: Array<string> | null;
  /**
   * Search agents by identity ID
   */
  identityId?: string | null;
  /**
   * Specify which relational fields (e.g., 'tools', 'sources', 'memory') to include in the response. If not provided, all relationships are loaded by default. Using this can optimize performance by reducing unnecessary joins.
   */
  includeRelationships?: Array<string> | null;
  /**
   * Limit for pagination
   */
  limit?: number | null;
  /**
   * If True, only returns agents that match ALL given tags. Otherwise, return agents that have ANY of the passed-in tags.
   */
  matchAllTags?: boolean;
  /**
   * Name of the agent
   */
  name?: string | null;
  /**
   * Search agents by project ID - this will default to your default project on cloud
   */
  projectId?: string | null;
  /**
   * Search agents by name
   */
  queryText?: string | null;
  /**
   * Field to sort by. Options: 'created_at' (default), 'last_run_completion'
   */
  sortBy?: string | null;
  /**
   * List of tags to filter agents by
   */
  tags?: Array<string> | null;
  /**
   * Search agents by template ID
   */
  templateId?: string | null;
  userId?: string | null;
};

export type ListAgentsResponse = Array<AgentState>;

export type CreateAgentData = {
  requestBody: CreateAgentRequest;
  userId?: string | null;
  /**
   * The project slug to associate with the agent (cloud only).
   */
  xProject?: string | null;
};

export type CreateAgentResponse = AgentState;

export type CountAgentsData = {
  userId?: string | null;
};

export type CountAgentsResponse = number;

export type ExportAgentSerializedData = {
  agentId: string;
  maxSteps?: number;
  requestBody?: Body_export_agent_serialized;
  /**
   * If true, exports using the legacy single-agent format. If false, exports using the new multi-entity format.
   */
  useLegacyFormat?: boolean;
  userId?: string | null;
};

export type ExportAgentSerializedResponse = string;

export type ImportAgentSerializedData = {
  formData: Body_import_agent_serialized;
  userId?: string | null;
};

export type ImportAgentSerializedResponse = ImportedAgentsResponse;

export type RetrieveAgentContextWindowData = {
  agentId: string;
  userId?: string | null;
};

export type RetrieveAgentContextWindowResponse = ContextWindowOverview;

export type ModifyAgentData = {
  agentId: string;
  requestBody: UpdateAgent;
  userId?: string | null;
};

export type ModifyAgentResponse = AgentState;

export type RetrieveAgentData = {
  agentId: string;
  /**
   * Specify which relational fields (e.g., 'tools', 'sources', 'memory') to include in the response. If not provided, all relationships are loaded by default. Using this can optimize performance by reducing unnecessary joins.
   */
  includeRelationships?: Array<string> | null;
  userId?: string | null;
};

export type RetrieveAgentResponse = AgentState;

export type DeleteAgentData = {
  agentId: string;
  userId?: string | null;
};

export type DeleteAgentResponse = unknown;

export type ListAgentToolsData = {
  agentId: string;
  userId?: string | null;
};

export type ListAgentToolsResponse = Array<Tool>;

export type AttachToolData = {
  agentId: string;
  toolId: string;
  userId?: string | null;
};

export type AttachToolResponse = AgentState;

export type DetachToolData = {
  agentId: string;
  toolId: string;
  userId?: string | null;
};

export type DetachToolResponse = AgentState;

export type AttachSourceToAgentData = {
  agentId: string;
  sourceId: string;
  userId?: string | null;
};

export type AttachSourceToAgentResponse = AgentState;

export type AttachFolderToAgentData = {
  agentId: string;
  folderId: string;
  userId?: string | null;
};

export type AttachFolderToAgentResponse = AgentState;

export type DetachSourceFromAgentData = {
  agentId: string;
  sourceId: string;
  userId?: string | null;
};

export type DetachSourceFromAgentResponse = AgentState;

export type DetachFolderFromAgentData = {
  agentId: string;
  folderId: string;
  userId?: string | null;
};

export type DetachFolderFromAgentResponse = AgentState;

export type CloseAllOpenFilesData = {
  agentId: string;
  userId?: string | null;
};

export type CloseAllOpenFilesResponse = Array<string>;

export type OpenFileData = {
  agentId: string;
  fileId: string;
  userId?: string | null;
};

export type OpenFileResponse = Array<string>;

export type CloseFileData = {
  agentId: string;
  fileId: string;
  userId?: string | null;
};

export type CloseFileResponse = unknown;

export type ListAgentSourcesData = {
  agentId: string;
  userId?: string | null;
};

export type ListAgentSourcesResponse = Array<Source>;

export type ListAgentFoldersData = {
  agentId: string;
  userId?: string | null;
};

export type ListAgentFoldersResponse = Array<Source>;

export type RetrieveAgentMemoryData = {
  agentId: string;
  userId?: string | null;
};

export type RetrieveAgentMemoryResponse = Memory;

export type RetrieveCoreMemoryBlockData = {
  agentId: string;
  blockLabel: string;
  userId?: string | null;
};

export type RetrieveCoreMemoryBlockResponse = Block;

export type ModifyCoreMemoryBlockData = {
  agentId: string;
  blockLabel: string;
  requestBody: BlockUpdate;
  userId?: string | null;
};

export type ModifyCoreMemoryBlockResponse = Block;

export type ListCoreMemoryBlocksData = {
  agentId: string;
  userId?: string | null;
};

export type ListCoreMemoryBlocksResponse = Array<Block>;

export type AttachCoreMemoryBlockData = {
  agentId: string;
  blockId: string;
  userId?: string | null;
};

export type AttachCoreMemoryBlockResponse = AgentState;

export type DetachCoreMemoryBlockData = {
  agentId: string;
  blockId: string;
  userId?: string | null;
};

export type DetachCoreMemoryBlockResponse = AgentState;

export type ListPassagesData = {
  /**
   * Unique ID of the memory to start the query range at.
   */
  after?: string | null;
  agentId: string;
  /**
   * Whether to sort passages oldest to newest (True, default) or newest to oldest (False)
   */
  ascending?: boolean | null;
  /**
   * Unique ID of the memory to end the query range at.
   */
  before?: string | null;
  /**
   * How many results to include in the response.
   */
  limit?: number | null;
  /**
   * Search passages by text
   */
  search?: string | null;
  userId?: string | null;
};

export type ListPassagesResponse = Array<Passage>;

export type CreatePassageData = {
  agentId: string;
  requestBody: CreateArchivalMemory;
  userId?: string | null;
};

export type CreatePassageResponse = Array<Passage>;

export type ModifyPassageData = {
  agentId: string;
  memoryId: string;
  requestBody: PassageUpdate;
  userId?: string | null;
};

export type ModifyPassageResponse = Array<Passage>;

export type DeletePassageData = {
  agentId: string;
  memoryId: string;
  userId?: string | null;
};

export type DeletePassageResponse = unknown;

export type ListMessagesData = {
  /**
   * Message after which to retrieve the returned messages.
   */
  after?: string | null;
  agentId: string;
  /**
   * The name of the message argument.
   */
  assistantMessageToolKwarg?: string;
  /**
   * The name of the designated message tool.
   */
  assistantMessageToolName?: string;
  /**
   * Message before which to retrieve the returned messages.
   */
  before?: string | null;
  /**
   * Group ID to filter messages by.
   */
  groupId?: string | null;
  /**
   * Whether to include error messages and error statuses. For debugging purposes only.
   */
  includeErr?: boolean | null;
  /**
   * Maximum number of messages to retrieve.
   */
  limit?: number;
  /**
   * Whether to use assistant messages
   */
  useAssistantMessage?: boolean;
  userId?: string | null;
};

export type ListMessagesResponse = Array<LettaMessageUnion>;

export type SendMessageData = {
  agentId: string;
  requestBody: LettaRequest;
  userId?: string | null;
};

export type SendMessageResponse = LettaResponse;

export type ModifyMessageData = {
  agentId: string;
  messageId: string;
  requestBody:
    | UpdateSystemMessage
    | UpdateUserMessage
    | UpdateReasoningMessage
    | UpdateAssistantMessage;
  userId?: string | null;
};

export type ModifyMessageResponse =
  | SystemMessage
  | UserMessage
  | ReasoningMessage
  | HiddenReasoningMessage
  | ToolCallMessage
  | ToolReturnMessage
  | AssistantMessage;

export type CreateAgentMessageStreamData = {
  agentId: string;
  requestBody: LettaStreamingRequest;
  userId?: string | null;
};

export type CreateAgentMessageStreamResponse = unknown;

export type CancelAgentRunData = {
  agentId: string;
  requestBody?: Array<string> | null;
  userId?: string | null;
};

export type CancelAgentRunResponse = {
  [key: string]: unknown;
};

export type CreateAgentMessageAsyncData = {
  agentId: string;
  requestBody: LettaAsyncRequest;
  userId?: string | null;
};

export type CreateAgentMessageAsyncResponse = Run;

export type ResetMessagesData = {
  /**
   * If true, adds the default initial messages after resetting.
   */
  addDefaultInitialMessages?: boolean;
  agentId: string;
  userId?: string | null;
};

export type ResetMessagesResponse = AgentState;

export type ListAgentGroupsData = {
  agentId: string;
  /**
   * Manager type to filter groups by
   */
  managerType?: string | null;
  userId?: string | null;
};

export type ListAgentGroupsResponse = Array<Group>;

export type PreviewRawPayloadData = {
  agentId: string;
  requestBody: LettaRequest | LettaStreamingRequest;
  userId?: string | null;
};

export type PreviewRawPayloadResponse = {
  [key: string]: unknown;
};

export type SummarizeAgentConversationData = {
  agentId: string;
  /**
   * Maximum number of messages to retain after summarization.
   */
  maxMessageLength: number;
  userId?: string | null;
};

export type SummarizeAgentConversationResponse = void;

export type ListGroupsData = {
  /**
   * Cursor for pagination
   */
  after?: string | null;
  /**
   * Cursor for pagination
   */
  before?: string | null;
  /**
   * Limit for pagination
   */
  limit?: number | null;
  /**
   * Search groups by manager type
   */
  managerType?: ManagerType | null;
  /**
   * Search groups by project id
   */
  projectId?: string | null;
  userId?: string | null;
};

export type ListGroupsResponse = Array<Group>;

export type CreateGroupData = {
  requestBody: GroupCreate;
  userId?: string | null;
  /**
   * The project slug to associate with the group (cloud only).
   */
  xProject?: string | null;
};

export type CreateGroupResponse = Group;

export type CountGroupsData = {
  userId?: string | null;
};

export type CountGroupsResponse = number;

export type RetrieveGroupData = {
  groupId: string;
  userId?: string | null;
};

export type RetrieveGroupResponse = Group;

export type ModifyGroupData = {
  groupId: string;
  requestBody: GroupUpdate;
  userId?: string | null;
  /**
   * The project slug to associate with the group (cloud only).
   */
  xProject?: string | null;
};

export type ModifyGroupResponse = Group;

export type DeleteGroupData = {
  groupId: string;
  userId?: string | null;
};

export type DeleteGroupResponse = unknown;

export type SendGroupMessageData = {
  groupId: string;
  requestBody: LettaRequest;
  userId?: string | null;
};

export type SendGroupMessageResponse = LettaResponse;

export type ListGroupMessagesData = {
  /**
   * Message after which to retrieve the returned messages.
   */
  after?: string | null;
  /**
   * The name of the message argument.
   */
  assistantMessageToolKwarg?: string;
  /**
   * The name of the designated message tool.
   */
  assistantMessageToolName?: string;
  /**
   * Message before which to retrieve the returned messages.
   */
  before?: string | null;
  groupId: string;
  /**
   * Maximum number of messages to retrieve.
   */
  limit?: number;
  /**
   * Whether to use assistant messages
   */
  useAssistantMessage?: boolean;
  userId?: string | null;
};

export type ListGroupMessagesResponse = Array<LettaMessageUnion>;

export type SendGroupMessageStreamingData = {
  groupId: string;
  requestBody: LettaStreamingRequest;
  userId?: string | null;
};

export type SendGroupMessageStreamingResponse = unknown;

export type ModifyGroupMessageData = {
  groupId: string;
  messageId: string;
  requestBody:
    | UpdateSystemMessage
    | UpdateUserMessage
    | UpdateReasoningMessage
    | UpdateAssistantMessage;
  userId?: string | null;
};

export type ModifyGroupMessageResponse =
  | SystemMessage
  | UserMessage
  | ReasoningMessage
  | HiddenReasoningMessage
  | ToolCallMessage
  | ToolReturnMessage
  | AssistantMessage;

export type ResetGroupMessagesData = {
  groupId: string;
  userId?: string | null;
};

export type ResetGroupMessagesResponse = unknown;

export type ListIdentitiesData = {
  after?: string | null;
  before?: string | null;
  identifierKey?: string | null;
  identityType?: IdentityType | null;
  limit?: number | null;
  name?: string | null;
  projectId?: string | null;
  userId?: string | null;
};

export type ListIdentitiesResponse = Array<Identity>;

export type CreateIdentityData = {
  requestBody: IdentityCreate;
  userId?: string | null;
  /**
   * The project slug to associate with the identity (cloud only).
   */
  xProject?: string | null;
};

export type CreateIdentityResponse = Identity;

export type UpsertIdentityData = {
  requestBody: IdentityUpsert;
  userId?: string | null;
  /**
   * The project slug to associate with the identity (cloud only).
   */
  xProject?: string | null;
};

export type UpsertIdentityResponse = Identity;

export type CountIdentitiesData = {
  userId?: string | null;
};

export type CountIdentitiesResponse = number;

export type RetrieveIdentityData = {
  identityId: string;
  userId?: string | null;
};

export type RetrieveIdentityResponse = Identity;

export type UpdateIdentityData = {
  identityId: string;
  requestBody: IdentityUpdate;
  userId?: string | null;
};

export type UpdateIdentityResponse = Identity;

export type DeleteIdentityData = {
  identityId: string;
  userId?: string | null;
};

export type DeleteIdentityResponse = unknown;

export type UpsertIdentityPropertiesData = {
  identityId: string;
  requestBody: Array<IdentityProperty>;
  userId?: string | null;
};

export type UpsertIdentityPropertiesResponse = unknown;

export type ListModelsData = {
  providerCategory?: Array<ProviderCategory> | null;
  providerName?: string | null;
  providerType?: ProviderType | null;
  userId?: string | null;
};

export type ListModelsResponse = Array<LLMConfig>;

export type ListEmbeddingModelsData = {
  userId?: string | null;
};

export type ListEmbeddingModelsResponse = Array<EmbeddingConfig>;

export type ListBlocksData = {
  /**
   * Cursor for pagination. If provided, returns blocks after this cursor.
   */
  after?: string | null;
  /**
   * Cursor for pagination. If provided, returns blocks before this cursor.
   */
  before?: string | null;
  /**
   * Filter blocks by the exact number of connected agents. If provided, returns blocks that have exactly this number of connected agents.
   */
  connectedToAgentsCountEq?: Array<number> | null;
  /**
   * Filter blocks by the number of connected agents. If provided, returns blocks that have more than this number of connected agents.
   */
  connectedToAgentsCountGt?: number | null;
  /**
   * Filter blocks by the number of connected agents. If provided, returns blocks that have less than this number of connected agents.
   */
  connectedToAgentsCountLt?: number | null;
  /**
   * Search blocks by description. If provided, returns blocks that match this description. This is a full-text search on block descriptions.
   */
  descriptionSearch?: string | null;
  /**
   * Search agents by identifier keys
   */
  identifierKeys?: Array<string> | null;
  /**
   * Search agents by identifier id
   */
  identityId?: string | null;
  /**
   * Labels to include (e.g. human, persona)
   */
  label?: string | null;
  /**
   * Search blocks by label. If provided, returns blocks that match this label. This is a full-text search on labels.
   */
  labelSearch?: string | null;
  /**
   * Number of blocks to return
   */
  limit?: number | null;
  /**
   * Name of the block
   */
  name?: string | null;
  /**
   * Search blocks by project id
   */
  projectId?: string | null;
  /**
   * Whether to include only templates
   */
  templatesOnly?: boolean;
  userId?: string | null;
  /**
   * Search blocks by value. If provided, returns blocks that match this value.
   */
  valueSearch?: string | null;
};

export type ListBlocksResponse = Array<Block>;

export type CreateBlockData = {
  requestBody: CreateBlock;
  userId?: string | null;
};

export type CreateBlockResponse = Block;

export type CountBlocksData = {
  userId?: string | null;
};

export type CountBlocksResponse = number;

export type ModifyBlockData = {
  blockId: string;
  requestBody: BlockUpdate;
  userId?: string | null;
};

export type ModifyBlockResponse = Block;

export type DeleteBlockData = {
  blockId: string;
  userId?: string | null;
};

export type DeleteBlockResponse = unknown;

export type RetrieveBlockData = {
  blockId: string;
  userId?: string | null;
};

export type RetrieveBlockResponse = Block;

export type ListAgentsForBlockData = {
  blockId: string;
  /**
   * Specify which relational fields (e.g., 'tools', 'sources', 'memory') to include in the response. If not provided, all relationships are loaded by default. Using this can optimize performance by reducing unnecessary joins.
   */
  includeRelationships?: Array<string> | null;
  userId?: string | null;
};

export type ListAgentsForBlockResponse = Array<AgentState>;

export type ListJobsData = {
  /**
   * Cursor for pagination
   */
  after?: string | null;
  /**
   * Whether to sort jobs oldest to newest (True, default) or newest to oldest (False)
   */
  ascending?: boolean;
  /**
   * Cursor for pagination
   */
  before?: string | null;
  /**
   * Limit for pagination
   */
  limit?: number | null;
  /**
   * Only list jobs associated with the source.
   */
  sourceId?: string | null;
  userId?: string | null;
};

export type ListJobsResponse = Array<Job>;

export type ListActiveJobsData = {
  /**
   * Cursor for pagination
   */
  after?: string | null;
  /**
   * Whether to sort jobs oldest to newest (True, default) or newest to oldest (False)
   */
  ascending?: boolean;
  /**
   * Cursor for pagination
   */
  before?: string | null;
  /**
   * Limit for pagination
   */
  limit?: number | null;
  /**
   * Only list jobs associated with the source.
   */
  sourceId?: string | null;
  userId?: string | null;
};

export type ListActiveJobsResponse = Array<Job>;

export type RetrieveJobData = {
  jobId: string;
  userId?: string | null;
};

export type RetrieveJobResponse = Job;

export type DeleteJobData = {
  jobId: string;
  userId?: string | null;
};

export type DeleteJobResponse = Job;

export type CancelJobData = {
  jobId: string;
  userId?: string | null;
};

export type CancelJobResponse = Job;

export type HealthCheckResponse = Health;

export type CreateSandboxConfigV1SandboxConfigPostData = {
  requestBody: SandboxConfigCreate;
  userId?: string | null;
};

export type CreateSandboxConfigV1SandboxConfigPostResponse = SandboxConfig;

export type ListSandboxConfigsV1SandboxConfigGetData = {
  /**
   * Pagination cursor to fetch the next set of results
   */
  after?: string | null;
  /**
   * Number of results to return
   */
  limit?: number;
  /**
   * Filter for this specific sandbox type
   */
  sandboxType?: SandboxType | null;
  userId?: string | null;
};

export type ListSandboxConfigsV1SandboxConfigGetResponse = Array<SandboxConfig>;

export type CreateDefaultE2bSandboxConfigV1SandboxConfigE2bDefaultPostData = {
  userId?: string | null;
};

export type CreateDefaultE2bSandboxConfigV1SandboxConfigE2bDefaultPostResponse =
  SandboxConfig;

export type CreateDefaultLocalSandboxConfigV1SandboxConfigLocalDefaultPostData =
  {
    userId?: string | null;
  };

export type CreateDefaultLocalSandboxConfigV1SandboxConfigLocalDefaultPostResponse =
  SandboxConfig;

export type CreateCustomLocalSandboxConfigV1SandboxConfigLocalPostData = {
  requestBody: LocalSandboxConfig;
  userId?: string | null;
};

export type CreateCustomLocalSandboxConfigV1SandboxConfigLocalPostResponse =
  SandboxConfig;

export type UpdateSandboxConfigV1SandboxConfigSandboxConfigIdPatchData = {
  requestBody: SandboxConfigUpdate;
  sandboxConfigId: string;
  userId?: string | null;
};

export type UpdateSandboxConfigV1SandboxConfigSandboxConfigIdPatchResponse =
  SandboxConfig;

export type DeleteSandboxConfigV1SandboxConfigSandboxConfigIdDeleteData = {
  sandboxConfigId: string;
  userId?: string | null;
};

export type DeleteSandboxConfigV1SandboxConfigSandboxConfigIdDeleteResponse =
  void;

export type ForceRecreateLocalSandboxVenvV1SandboxConfigLocalRecreateVenvPostData =
  {
    userId?: string | null;
  };

export type ForceRecreateLocalSandboxVenvV1SandboxConfigLocalRecreateVenvPostResponse =
  SandboxConfig;

export type CreateSandboxEnvVarV1SandboxConfigSandboxConfigIdEnvironmentVariablePostData =
  {
    requestBody: SandboxEnvironmentVariableCreate;
    sandboxConfigId: string;
    userId?: string | null;
  };

export type CreateSandboxEnvVarV1SandboxConfigSandboxConfigIdEnvironmentVariablePostResponse =
  SandboxEnvironmentVariable;

export type ListSandboxEnvVarsV1SandboxConfigSandboxConfigIdEnvironmentVariableGetData =
  {
    /**
     * Pagination cursor to fetch the next set of results
     */
    after?: string | null;
    /**
     * Number of results to return
     */
    limit?: number;
    sandboxConfigId: string;
    userId?: string | null;
  };

export type ListSandboxEnvVarsV1SandboxConfigSandboxConfigIdEnvironmentVariableGetResponse =
  Array<SandboxEnvironmentVariable>;

export type UpdateSandboxEnvVarV1SandboxConfigEnvironmentVariableEnvVarIdPatchData =
  {
    envVarId: string;
    requestBody: SandboxEnvironmentVariableUpdate;
    userId?: string | null;
  };

export type UpdateSandboxEnvVarV1SandboxConfigEnvironmentVariableEnvVarIdPatchResponse =
  SandboxEnvironmentVariable;

export type DeleteSandboxEnvVarV1SandboxConfigEnvironmentVariableEnvVarIdDeleteData =
  {
    envVarId: string;
    userId?: string | null;
  };

export type DeleteSandboxEnvVarV1SandboxConfigEnvironmentVariableEnvVarIdDeleteResponse =
  void;

export type ListProvidersData = {
  after?: string | null;
  limit?: number | null;
  name?: string | null;
  providerType?: ProviderType | null;
  userId?: string | null;
};

export type ListProvidersResponse = Array<Provider>;

export type CreateProviderData = {
  requestBody: ProviderCreate;
  userId?: string | null;
};

export type CreateProviderResponse = Provider;

export type ModifyProviderData = {
  providerId: string;
  requestBody: ProviderUpdate;
  userId?: string | null;
};

export type ModifyProviderResponse = Provider;

export type DeleteProviderData = {
  providerId: string;
  userId?: string | null;
};

export type DeleteProviderResponse = unknown;

export type CheckProviderData = {
  requestBody: ProviderCheck;
};

export type CheckProviderResponse = unknown;

export type ListRunsData = {
  /**
   * The unique identifier of the agent associated with the run.
   */
  agentIds?: Array<string> | null;
  userId?: string | null;
};

export type ListRunsResponse = Array<Run>;

export type ListActiveRunsData = {
  /**
   * The unique identifier of the agent associated with the run.
   */
  agentIds?: Array<string> | null;
  userId?: string | null;
};

export type ListActiveRunsResponse = Array<Run>;

export type RetrieveRunData = {
  runId: string;
  userId?: string | null;
};

export type RetrieveRunResponse = Run;

export type DeleteRunData = {
  runId: string;
  userId?: string | null;
};

export type DeleteRunResponse = Run;

export type ListRunMessagesData = {
  /**
   * Cursor for pagination
   */
  after?: string | null;
  /**
   * Cursor for pagination
   */
  before?: string | null;
  /**
   * Maximum number of messages to return
   */
  limit?: number | null;
  /**
   * Sort order by the created_at timestamp of the objects. asc for ascending order and desc for descending order.
   */
  order?: string;
  /**
   * Filter by role
   */
  role?: MessageRole | null;
  runId: string;
  userId?: string | null;
};

export type ListRunMessagesResponse = Array<LettaMessageUnion>;

export type RetrieveRunUsageData = {
  runId: string;
  userId?: string | null;
};

export type RetrieveRunUsageResponse = UsageStatistics;

export type ListRunStepsData = {
  /**
   * Cursor for pagination
   */
  after?: string | null;
  /**
   * Cursor for pagination
   */
  before?: string | null;
  /**
   * Maximum number of messages to return
   */
  limit?: number | null;
  /**
   * Sort order by the created_at timestamp of the objects. asc for ascending order and desc for descending order.
   */
  order?: string;
  runId: string;
  userId?: string | null;
};

export type ListRunStepsResponse = Array<Step>;

export type ListStepsData = {
  /**
   * Return steps after this step ID
   */
  after?: string | null;
  /**
   * Filter by the ID of the agent that performed the step
   */
  agentId?: string | null;
  /**
   * Return steps before this step ID
   */
  before?: string | null;
  /**
   * Return steps before this ISO datetime (e.g. "2025-01-29T15:01:19-08:00")
   */
  endDate?: string | null;
  /**
   * Filter by feedback
   */
  feedback?: 'positive' | 'negative' | null;
  /**
   * Filter by whether steps have feedback (true) or not (false)
   */
  hasFeedback?: boolean | null;
  /**
   * Maximum number of steps to return
   */
  limit?: number | null;
  /**
   * Filter by the name of the model used for the step
   */
  model?: string | null;
  /**
   * Sort order (asc or desc)
   */
  order?: string | null;
  /**
   * Filter by the project ID that is associated with the step (cloud only).
   */
  projectId?: string | null;
  /**
   * Return steps after this ISO datetime (e.g. "2025-01-29T15:01:19-08:00")
   */
  startDate?: string | null;
  /**
   * Filter by tags
   */
  tags?: Array<string> | null;
  /**
   * Filter by trace ids returned by the server
   */
  traceIds?: Array<string> | null;
  userId?: string | null;
  /**
   * Filter by project slug to associate with the group (cloud only).
   */
  xProject?: string | null;
};

export type ListStepsResponse = Array<Step>;

export type RetrieveStepData = {
  stepId: string;
  userId?: string | null;
};

export type RetrieveStepResponse = Step;

export type AddFeedbackData = {
  feedback: FeedbackType | null;
  stepId: string;
  userId?: string | null;
};

export type AddFeedbackResponse = Step;

export type UpdateStepTransactionIdData = {
  stepId: string;
  transactionId: string;
  userId?: string | null;
};

export type UpdateStepTransactionIdResponse = Step;

export type ListTagsData = {
  after?: string | null;
  limit?: number | null;
  queryText?: string | null;
  userId?: string | null;
};

export type ListTagsResponse = Array<string>;

export type ListUsersData = {
  after?: string | null;
  limit?: number | null;
};

export type ListUsersResponse = Array<User>;

export type CreateUserData = {
  requestBody: UserCreate;
};

export type CreateUserResponse = User;

export type UpdateUserData = {
  requestBody: UserUpdate;
};

export type UpdateUserResponse = User;

export type DeleteUserData = {
  /**
   * The user_id key to be deleted.
   */
  userId: string;
};

export type DeleteUserResponse = User;

export type ListOrgsData = {
  after?: string | null;
  limit?: number | null;
};

export type ListOrgsResponse = Array<Organization>;

export type CreateOrganizationData = {
  requestBody: OrganizationCreate;
};

export type CreateOrganizationResponse = Organization;

export type DeleteOrganizationByIdData = {
  /**
   * The org_id key to be deleted.
   */
  orgId: string;
};

export type DeleteOrganizationByIdResponse = Organization;

export type UpdateOrganizationData = {
  /**
   * The org_id key to be updated.
   */
  orgId: string;
  requestBody: OrganizationUpdate;
};

export type UpdateOrganizationResponse = Organization;

export type RetrieveProviderTraceData = {
  stepId: string;
  userId?: string | null;
};

export type RetrieveProviderTraceResponse = ProviderTrace;

export type CreateMessagesBatchData = {
  requestBody: CreateBatch;
  userId?: string | null;
};

export type CreateMessagesBatchResponse = BatchJob;

export type ListBatchRunsData = {
  userId?: string | null;
};

export type ListBatchRunsResponse = Array<BatchJob>;

export type RetrieveBatchRunData = {
  batchId: string;
  userId?: string | null;
};

export type RetrieveBatchRunResponse = BatchJob;

export type ListBatchMessagesData = {
  /**
   * Filter messages by agent ID
   */
  agentId?: string | null;
  batchId: string;
  /**
   * Message ID to use as pagination cursor (get messages before/after this ID) depending on sort_descending.
   */
  cursor?: string | null;
  /**
   * Maximum number of messages to return
   */
  limit?: number;
  /**
   * Sort messages by creation time (true=newest first)
   */
  sortDescending?: boolean;
  userId?: string | null;
};

export type ListBatchMessagesResponse = LettaBatchMessages;

export type CancelBatchRunData = {
  batchId: string;
  userId?: string | null;
};

export type CancelBatchRunResponse = unknown;

export type CreateVoiceChatCompletionsData = {
  agentId: string;
  requestBody: {
    [key: string]: unknown;
  };
  userId?: string | null;
};

export type CreateVoiceChatCompletionsResponse = unknown;

export type GetTotalStorageSizeData = {
  storageUnit?: string | null;
  userId?: string | null;
};

export type GetTotalStorageSizeResponse = number;

export type AuthenticateUserV1AuthPostData = {
  requestBody: AuthRequest;
};

export type AuthenticateUserV1AuthPostResponse = AuthResponse;

export type $OpenApiTs = {
  '/v1/tools/{tool_id}': {
    delete: {
      req: DeleteToolData;
      res: {
        /**
         * Successful Response
         */
        200: unknown;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
    get: {
      req: RetrieveToolData;
      res: {
        /**
         * Successful Response
         */
        200: Tool;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
    patch: {
      req: ModifyToolData;
      res: {
        /**
         * Successful Response
         */
        200: Tool;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/tools/count': {
    get: {
      req: CountToolsData;
      res: {
        /**
         * Successful Response
         */
        200: number;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/tools/': {
    get: {
      req: ListToolsData;
      res: {
        /**
         * Successful Response
         */
        200: Array<Tool>;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
    post: {
      req: CreateToolData;
      res: {
        /**
         * Successful Response
         */
        200: Tool;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
    put: {
      req: UpsertToolData;
      res: {
        /**
         * Successful Response
         */
        200: Tool;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/tools/add-base-tools': {
    post: {
      req: AddBaseToolsData;
      res: {
        /**
         * Successful Response
         */
        200: Array<Tool>;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/tools/run': {
    post: {
      req: RunToolFromSourceData;
      res: {
        /**
         * Successful Response
         */
        200: ToolReturnMessage;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/tools/composio/apps': {
    get: {
      req: ListComposioAppsData;
      res: {
        /**
         * Successful Response
         */
        200: Array<AppModel>;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/tools/composio/apps/{composio_app_name}/actions': {
    get: {
      req: ListComposioActionsByAppData;
      res: {
        /**
         * Successful Response
         */
        200: Array<ActionModel>;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/tools/composio/{composio_action_name}': {
    post: {
      req: AddComposioToolData;
      res: {
        /**
         * Successful Response
         */
        200: Tool;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/tools/mcp/servers': {
    get: {
      req: ListMcpServersData;
      res: {
        /**
         * Successful Response
         */
        200: {
          [key: string]:
            | SSEServerConfig
            | StdioServerConfig
            | StreamableHTTPServerConfig;
        };
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
    put: {
      req: AddMcpServerData;
      res: {
        /**
         * Successful Response
         */
        200: Array<
          StdioServerConfig | SSEServerConfig | StreamableHTTPServerConfig
        >;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/tools/mcp/servers/{mcp_server_name}/tools': {
    get: {
      req: ListMcpToolsByServerData;
      res: {
        /**
         * Successful Response
         */
        200: Array<MCPTool>;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/tools/mcp/servers/{mcp_server_name}/{mcp_tool_name}': {
    post: {
      req: AddMcpToolData;
      res: {
        /**
         * Successful Response
         */
        200: Tool;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/tools/mcp/servers/{mcp_server_name}': {
    patch: {
      req: UpdateMcpServerData;
      res: {
        /**
         * Successful Response
         */
        200: StdioServerConfig | SSEServerConfig | StreamableHTTPServerConfig;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
    delete: {
      req: DeleteMcpServerData;
      res: {
        /**
         * Successful Response
         */
        200: Array<
          StdioServerConfig | SSEServerConfig | StreamableHTTPServerConfig
        >;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/tools/mcp/servers/test': {
    post: {
      req: TestMcpServerData;
      res: {
        /**
         * Successful Response
         */
        200: unknown;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/tools/mcp/servers/connect': {
    post: {
      req: ConnectMcpServerData;
      res: {
        /**
         * Successful response
         */
        200: unknown;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/tools/generate-schema': {
    post: {
      req: GenerateJsonSchemaData;
      res: {
        /**
         * Successful Response
         */
        200: {
          [key: string]: unknown;
        };
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/tools/mcp/oauth/callback/{session_id}': {
    get: {
      req: McpOauthCallbackData;
      res: {
        /**
         * Successful Response
         */
        200: unknown;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/tools/generate-tool': {
    post: {
      req: GenerateToolData;
      res: {
        /**
         * Successful Response
         */
        200: GenerateToolOutput;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/sources/count': {
    get: {
      req: CountSourcesData;
      res: {
        /**
         * Successful Response
         */
        200: number;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/sources/{source_id}': {
    get: {
      req: RetrieveSourceData;
      res: {
        /**
         * Successful Response
         */
        200: Source;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
    patch: {
      req: ModifySourceData;
      res: {
        /**
         * Successful Response
         */
        200: Source;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
    delete: {
      req: DeleteSourceData;
      res: {
        /**
         * Successful Response
         */
        200: unknown;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/sources/name/{source_name}': {
    get: {
      req: GetSourceIdByNameData;
      res: {
        /**
         * Successful Response
         */
        200: string;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/sources/metadata': {
    get: {
      req: GetSourcesMetadataData;
      res: {
        /**
         * Successful Response
         */
        200: OrganizationSourcesStats;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/sources/': {
    get: {
      req: ListSourcesData;
      res: {
        /**
         * Successful Response
         */
        200: Array<Source>;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
    post: {
      req: CreateSourceData;
      res: {
        /**
         * Successful Response
         */
        200: Source;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/sources/{source_id}/upload': {
    post: {
      req: UploadFileToSourceData;
      res: {
        /**
         * Successful Response
         */
        200: FileMetadata;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/sources/{source_id}/agents': {
    get: {
      req: GetAgentsForSourceData;
      res: {
        /**
         * Successful Response
         */
        200: Array<string>;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/sources/{source_id}/passages': {
    get: {
      req: ListSourcePassagesData;
      res: {
        /**
         * Successful Response
         */
        200: Array<Passage>;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/sources/{source_id}/files': {
    get: {
      req: ListSourceFilesData;
      res: {
        /**
         * Successful Response
         */
        200: Array<FileMetadata>;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/sources/{source_id}/files/{file_id}': {
    get: {
      req: GetFileMetadataData;
      res: {
        /**
         * Successful Response
         */
        200: FileMetadata;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/sources/{source_id}/{file_id}': {
    delete: {
      req: DeleteFileFromSourceData;
      res: {
        /**
         * Successful Response
         */
        204: void;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/folders/count': {
    get: {
      req: CountFoldersData;
      res: {
        /**
         * Successful Response
         */
        200: number;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/folders/{folder_id}': {
    get: {
      req: RetrieveFolderData;
      res: {
        /**
         * Successful Response
         */
        200: Folder;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
    patch: {
      req: ModifyFolderData;
      res: {
        /**
         * Successful Response
         */
        200: Folder;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
    delete: {
      req: DeleteFolderData;
      res: {
        /**
         * Successful Response
         */
        200: unknown;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/folders/name/{folder_name}': {
    get: {
      req: GetFolderIdByNameData;
      res: {
        /**
         * Successful Response
         */
        200: string;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/folders/metadata': {
    get: {
      req: GetFoldersMetadataData;
      res: {
        /**
         * Successful Response
         */
        200: OrganizationSourcesStats;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/folders/': {
    get: {
      req: ListFoldersData;
      res: {
        /**
         * Successful Response
         */
        200: Array<Folder>;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
    post: {
      req: CreateFolderData;
      res: {
        /**
         * Successful Response
         */
        200: Folder;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/folders/{folder_id}/upload': {
    post: {
      req: UploadFileToFolderData;
      res: {
        /**
         * Successful Response
         */
        200: FileMetadata;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/folders/{folder_id}/agents': {
    get: {
      req: GetAgentsForFolderData;
      res: {
        /**
         * Successful Response
         */
        200: Array<string>;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/folders/{folder_id}/passages': {
    get: {
      req: ListFolderPassagesData;
      res: {
        /**
         * Successful Response
         */
        200: Array<Passage>;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/folders/{folder_id}/files': {
    get: {
      req: ListFolderFilesData;
      res: {
        /**
         * Successful Response
         */
        200: Array<FileMetadata>;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/folders/{folder_id}/{file_id}': {
    delete: {
      req: DeleteFileFromFolderData;
      res: {
        /**
         * Successful Response
         */
        204: void;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/agents/': {
    get: {
      req: ListAgentsData;
      res: {
        /**
         * Successful Response
         */
        200: Array<AgentState>;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
    post: {
      req: CreateAgentData;
      res: {
        /**
         * Successful Response
         */
        200: AgentState;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/agents/count': {
    get: {
      req: CountAgentsData;
      res: {
        /**
         * Successful Response
         */
        200: number;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/agents/{agent_id}/export': {
    get: {
      req: ExportAgentSerializedData;
      res: {
        /**
         * Successful Response
         */
        200: string;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/agents/import': {
    post: {
      req: ImportAgentSerializedData;
      res: {
        /**
         * Successful Response
         */
        200: ImportedAgentsResponse;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/agents/{agent_id}/context': {
    get: {
      req: RetrieveAgentContextWindowData;
      res: {
        /**
         * Successful Response
         */
        200: ContextWindowOverview;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/agents/{agent_id}': {
    patch: {
      req: ModifyAgentData;
      res: {
        /**
         * Successful Response
         */
        200: AgentState;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
    get: {
      req: RetrieveAgentData;
      res: {
        /**
         * Successful Response
         */
        200: AgentState;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
    delete: {
      req: DeleteAgentData;
      res: {
        /**
         * Successful Response
         */
        200: unknown;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/agents/{agent_id}/tools': {
    get: {
      req: ListAgentToolsData;
      res: {
        /**
         * Successful Response
         */
        200: Array<Tool>;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/agents/{agent_id}/tools/attach/{tool_id}': {
    patch: {
      req: AttachToolData;
      res: {
        /**
         * Successful Response
         */
        200: AgentState;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/agents/{agent_id}/tools/detach/{tool_id}': {
    patch: {
      req: DetachToolData;
      res: {
        /**
         * Successful Response
         */
        200: AgentState;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/agents/{agent_id}/sources/attach/{source_id}': {
    patch: {
      req: AttachSourceToAgentData;
      res: {
        /**
         * Successful Response
         */
        200: AgentState;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/agents/{agent_id}/folders/attach/{folder_id}': {
    patch: {
      req: AttachFolderToAgentData;
      res: {
        /**
         * Successful Response
         */
        200: AgentState;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/agents/{agent_id}/sources/detach/{source_id}': {
    patch: {
      req: DetachSourceFromAgentData;
      res: {
        /**
         * Successful Response
         */
        200: AgentState;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/agents/{agent_id}/folders/detach/{folder_id}': {
    patch: {
      req: DetachFolderFromAgentData;
      res: {
        /**
         * Successful Response
         */
        200: AgentState;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/agents/{agent_id}/files/close-all': {
    patch: {
      req: CloseAllOpenFilesData;
      res: {
        /**
         * Successful Response
         */
        200: Array<string>;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/agents/{agent_id}/files/{file_id}/open': {
    patch: {
      req: OpenFileData;
      res: {
        /**
         * Successful Response
         */
        200: Array<string>;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/agents/{agent_id}/files/{file_id}/close': {
    patch: {
      req: CloseFileData;
      res: {
        /**
         * Successful Response
         */
        200: unknown;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/agents/{agent_id}/sources': {
    get: {
      req: ListAgentSourcesData;
      res: {
        /**
         * Successful Response
         */
        200: Array<Source>;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/agents/{agent_id}/folders': {
    get: {
      req: ListAgentFoldersData;
      res: {
        /**
         * Successful Response
         */
        200: Array<Source>;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/agents/{agent_id}/core-memory': {
    get: {
      req: RetrieveAgentMemoryData;
      res: {
        /**
         * Successful Response
         */
        200: Memory;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/agents/{agent_id}/core-memory/blocks/{block_label}': {
    get: {
      req: RetrieveCoreMemoryBlockData;
      res: {
        /**
         * Successful Response
         */
        200: Block;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
    patch: {
      req: ModifyCoreMemoryBlockData;
      res: {
        /**
         * Successful Response
         */
        200: Block;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/agents/{agent_id}/core-memory/blocks': {
    get: {
      req: ListCoreMemoryBlocksData;
      res: {
        /**
         * Successful Response
         */
        200: Array<Block>;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/agents/{agent_id}/core-memory/blocks/attach/{block_id}': {
    patch: {
      req: AttachCoreMemoryBlockData;
      res: {
        /**
         * Successful Response
         */
        200: AgentState;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/agents/{agent_id}/core-memory/blocks/detach/{block_id}': {
    patch: {
      req: DetachCoreMemoryBlockData;
      res: {
        /**
         * Successful Response
         */
        200: AgentState;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/agents/{agent_id}/archival-memory': {
    get: {
      req: ListPassagesData;
      res: {
        /**
         * Successful Response
         */
        200: Array<Passage>;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
    post: {
      req: CreatePassageData;
      res: {
        /**
         * Successful Response
         */
        200: Array<Passage>;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/agents/{agent_id}/archival-memory/{memory_id}': {
    patch: {
      req: ModifyPassageData;
      res: {
        /**
         * Successful Response
         */
        200: Array<Passage>;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
    delete: {
      req: DeletePassageData;
      res: {
        /**
         * Successful Response
         */
        200: unknown;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/agents/{agent_id}/messages': {
    get: {
      req: ListMessagesData;
      res: {
        /**
         * Successful Response
         */
        200: Array<LettaMessageUnion>;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
    post: {
      req: SendMessageData;
      res: {
        /**
         * Successful Response
         */
        200: LettaResponse;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/agents/{agent_id}/messages/{message_id}': {
    patch: {
      req: ModifyMessageData;
      res: {
        /**
         * Successful Response
         */
        200:
          | SystemMessage
          | UserMessage
          | ReasoningMessage
          | HiddenReasoningMessage
          | ToolCallMessage
          | ToolReturnMessage
          | AssistantMessage;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/agents/{agent_id}/messages/stream': {
    post: {
      req: CreateAgentMessageStreamData;
      res: {
        /**
         * Successful response
         */
        200: unknown;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/agents/{agent_id}/messages/cancel': {
    post: {
      req: CancelAgentRunData;
      res: {
        /**
         * Successful Response
         */
        200: {
          [key: string]: unknown;
        };
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/agents/{agent_id}/messages/async': {
    post: {
      req: CreateAgentMessageAsyncData;
      res: {
        /**
         * Successful Response
         */
        200: Run;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/agents/{agent_id}/reset-messages': {
    patch: {
      req: ResetMessagesData;
      res: {
        /**
         * Successful Response
         */
        200: AgentState;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/agents/{agent_id}/groups': {
    get: {
      req: ListAgentGroupsData;
      res: {
        /**
         * Successful Response
         */
        200: Array<Group>;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/agents/{agent_id}/messages/preview-raw-payload': {
    post: {
      req: PreviewRawPayloadData;
      res: {
        /**
         * Successful Response
         */
        200: {
          [key: string]: unknown;
        };
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/agents/{agent_id}/summarize': {
    post: {
      req: SummarizeAgentConversationData;
      res: {
        /**
         * Successful Response
         */
        204: void;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/groups/': {
    get: {
      req: ListGroupsData;
      res: {
        /**
         * Successful Response
         */
        200: Array<Group>;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
    post: {
      req: CreateGroupData;
      res: {
        /**
         * Successful Response
         */
        200: Group;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/groups/count': {
    get: {
      req: CountGroupsData;
      res: {
        /**
         * Successful Response
         */
        200: number;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/groups/{group_id}': {
    get: {
      req: RetrieveGroupData;
      res: {
        /**
         * Successful Response
         */
        200: Group;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
    patch: {
      req: ModifyGroupData;
      res: {
        /**
         * Successful Response
         */
        200: Group;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
    delete: {
      req: DeleteGroupData;
      res: {
        /**
         * Successful Response
         */
        200: unknown;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/groups/{group_id}/messages': {
    post: {
      req: SendGroupMessageData;
      res: {
        /**
         * Successful Response
         */
        200: LettaResponse;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
    get: {
      req: ListGroupMessagesData;
      res: {
        /**
         * Successful Response
         */
        200: Array<LettaMessageUnion>;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/groups/{group_id}/messages/stream': {
    post: {
      req: SendGroupMessageStreamingData;
      res: {
        /**
         * Successful response
         */
        200: unknown;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/groups/{group_id}/messages/{message_id}': {
    patch: {
      req: ModifyGroupMessageData;
      res: {
        /**
         * Successful Response
         */
        200:
          | SystemMessage
          | UserMessage
          | ReasoningMessage
          | HiddenReasoningMessage
          | ToolCallMessage
          | ToolReturnMessage
          | AssistantMessage;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/groups/{group_id}/reset-messages': {
    patch: {
      req: ResetGroupMessagesData;
      res: {
        /**
         * Successful Response
         */
        200: unknown;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/identities/': {
    get: {
      req: ListIdentitiesData;
      res: {
        /**
         * Successful Response
         */
        200: Array<Identity>;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
    post: {
      req: CreateIdentityData;
      res: {
        /**
         * Successful Response
         */
        200: Identity;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
    put: {
      req: UpsertIdentityData;
      res: {
        /**
         * Successful Response
         */
        200: Identity;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/identities/count': {
    get: {
      req: CountIdentitiesData;
      res: {
        /**
         * Successful Response
         */
        200: number;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/identities/{identity_id}': {
    get: {
      req: RetrieveIdentityData;
      res: {
        /**
         * Successful Response
         */
        200: Identity;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
    patch: {
      req: UpdateIdentityData;
      res: {
        /**
         * Successful Response
         */
        200: Identity;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
    delete: {
      req: DeleteIdentityData;
      res: {
        /**
         * Successful Response
         */
        200: unknown;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/identities/{identity_id}/properties': {
    put: {
      req: UpsertIdentityPropertiesData;
      res: {
        /**
         * Successful Response
         */
        200: unknown;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/models/': {
    get: {
      req: ListModelsData;
      res: {
        /**
         * Successful Response
         */
        200: Array<LLMConfig>;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/models/embedding': {
    get: {
      req: ListEmbeddingModelsData;
      res: {
        /**
         * Successful Response
         */
        200: Array<EmbeddingConfig>;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/blocks/': {
    get: {
      req: ListBlocksData;
      res: {
        /**
         * Successful Response
         */
        200: Array<Block>;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
    post: {
      req: CreateBlockData;
      res: {
        /**
         * Successful Response
         */
        200: Block;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/blocks/count': {
    get: {
      req: CountBlocksData;
      res: {
        /**
         * Successful Response
         */
        200: number;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/blocks/{block_id}': {
    patch: {
      req: ModifyBlockData;
      res: {
        /**
         * Successful Response
         */
        200: Block;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
    delete: {
      req: DeleteBlockData;
      res: {
        /**
         * Successful Response
         */
        200: unknown;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
    get: {
      req: RetrieveBlockData;
      res: {
        /**
         * Successful Response
         */
        200: Block;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/blocks/{block_id}/agents': {
    get: {
      req: ListAgentsForBlockData;
      res: {
        /**
         * Successful Response
         */
        200: Array<AgentState>;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/jobs/': {
    get: {
      req: ListJobsData;
      res: {
        /**
         * Successful Response
         */
        200: Array<Job>;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/jobs/active': {
    get: {
      req: ListActiveJobsData;
      res: {
        /**
         * Successful Response
         */
        200: Array<Job>;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/jobs/{job_id}': {
    get: {
      req: RetrieveJobData;
      res: {
        /**
         * Successful Response
         */
        200: Job;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
    delete: {
      req: DeleteJobData;
      res: {
        /**
         * Successful Response
         */
        200: Job;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/jobs/{job_id}/cancel': {
    patch: {
      req: CancelJobData;
      res: {
        /**
         * Successful Response
         */
        200: Job;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/health/': {
    get: {
      res: {
        /**
         * Successful Response
         */
        200: Health;
      };
    };
  };
  '/v1/sandbox-config/': {
    post: {
      req: CreateSandboxConfigV1SandboxConfigPostData;
      res: {
        /**
         * Successful Response
         */
        200: SandboxConfig;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
    get: {
      req: ListSandboxConfigsV1SandboxConfigGetData;
      res: {
        /**
         * Successful Response
         */
        200: Array<SandboxConfig>;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/sandbox-config/e2b/default': {
    post: {
      req: CreateDefaultE2bSandboxConfigV1SandboxConfigE2bDefaultPostData;
      res: {
        /**
         * Successful Response
         */
        200: SandboxConfig;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/sandbox-config/local/default': {
    post: {
      req: CreateDefaultLocalSandboxConfigV1SandboxConfigLocalDefaultPostData;
      res: {
        /**
         * Successful Response
         */
        200: SandboxConfig;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/sandbox-config/local': {
    post: {
      req: CreateCustomLocalSandboxConfigV1SandboxConfigLocalPostData;
      res: {
        /**
         * Successful Response
         */
        200: SandboxConfig;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/sandbox-config/{sandbox_config_id}': {
    patch: {
      req: UpdateSandboxConfigV1SandboxConfigSandboxConfigIdPatchData;
      res: {
        /**
         * Successful Response
         */
        200: SandboxConfig;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
    delete: {
      req: DeleteSandboxConfigV1SandboxConfigSandboxConfigIdDeleteData;
      res: {
        /**
         * Successful Response
         */
        204: void;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/sandbox-config/local/recreate-venv': {
    post: {
      req: ForceRecreateLocalSandboxVenvV1SandboxConfigLocalRecreateVenvPostData;
      res: {
        /**
         * Successful Response
         */
        200: SandboxConfig;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/sandbox-config/{sandbox_config_id}/environment-variable': {
    post: {
      req: CreateSandboxEnvVarV1SandboxConfigSandboxConfigIdEnvironmentVariablePostData;
      res: {
        /**
         * Successful Response
         */
        200: SandboxEnvironmentVariable;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
    get: {
      req: ListSandboxEnvVarsV1SandboxConfigSandboxConfigIdEnvironmentVariableGetData;
      res: {
        /**
         * Successful Response
         */
        200: Array<SandboxEnvironmentVariable>;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/sandbox-config/environment-variable/{env_var_id}': {
    patch: {
      req: UpdateSandboxEnvVarV1SandboxConfigEnvironmentVariableEnvVarIdPatchData;
      res: {
        /**
         * Successful Response
         */
        200: SandboxEnvironmentVariable;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
    delete: {
      req: DeleteSandboxEnvVarV1SandboxConfigEnvironmentVariableEnvVarIdDeleteData;
      res: {
        /**
         * Successful Response
         */
        204: void;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/providers/': {
    get: {
      req: ListProvidersData;
      res: {
        /**
         * Successful Response
         */
        200: Array<Provider>;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
    post: {
      req: CreateProviderData;
      res: {
        /**
         * Successful Response
         */
        200: Provider;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/providers/{provider_id}': {
    patch: {
      req: ModifyProviderData;
      res: {
        /**
         * Successful Response
         */
        200: Provider;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
    delete: {
      req: DeleteProviderData;
      res: {
        /**
         * Successful Response
         */
        200: unknown;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/providers/check': {
    get: {
      req: CheckProviderData;
      res: {
        /**
         * Successful Response
         */
        200: unknown;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/runs/': {
    get: {
      req: ListRunsData;
      res: {
        /**
         * Successful Response
         */
        200: Array<Run>;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/runs/active': {
    get: {
      req: ListActiveRunsData;
      res: {
        /**
         * Successful Response
         */
        200: Array<Run>;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/runs/{run_id}': {
    get: {
      req: RetrieveRunData;
      res: {
        /**
         * Successful Response
         */
        200: Run;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
    delete: {
      req: DeleteRunData;
      res: {
        /**
         * Successful Response
         */
        200: Run;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/runs/{run_id}/messages': {
    get: {
      req: ListRunMessagesData;
      res: {
        /**
         * Successful Response
         */
        200: Array<LettaMessageUnion>;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/runs/{run_id}/usage': {
    get: {
      req: RetrieveRunUsageData;
      res: {
        /**
         * Successful Response
         */
        200: UsageStatistics;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/runs/{run_id}/steps': {
    get: {
      req: ListRunStepsData;
      res: {
        /**
         * Successful Response
         */
        200: Array<Step>;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/steps/': {
    get: {
      req: ListStepsData;
      res: {
        /**
         * Successful Response
         */
        200: Array<Step>;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/steps/{step_id}': {
    get: {
      req: RetrieveStepData;
      res: {
        /**
         * Successful Response
         */
        200: Step;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/steps/{step_id}/feedback': {
    patch: {
      req: AddFeedbackData;
      res: {
        /**
         * Successful Response
         */
        200: Step;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/steps/{step_id}/transaction/{transaction_id}': {
    patch: {
      req: UpdateStepTransactionIdData;
      res: {
        /**
         * Successful Response
         */
        200: Step;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/tags/': {
    get: {
      req: ListTagsData;
      res: {
        /**
         * Successful Response
         */
        200: Array<string>;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/admin/users/': {
    get: {
      req: ListUsersData;
      res: {
        /**
         * Successful Response
         */
        200: Array<User>;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
    post: {
      req: CreateUserData;
      res: {
        /**
         * Successful Response
         */
        200: User;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
    put: {
      req: UpdateUserData;
      res: {
        /**
         * Successful Response
         */
        200: User;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
    delete: {
      req: DeleteUserData;
      res: {
        /**
         * Successful Response
         */
        200: User;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/admin/orgs/': {
    get: {
      req: ListOrgsData;
      res: {
        /**
         * Successful Response
         */
        200: Array<Organization>;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
    post: {
      req: CreateOrganizationData;
      res: {
        /**
         * Successful Response
         */
        200: Organization;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
    delete: {
      req: DeleteOrganizationByIdData;
      res: {
        /**
         * Successful Response
         */
        200: Organization;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
    patch: {
      req: UpdateOrganizationData;
      res: {
        /**
         * Successful Response
         */
        200: Organization;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/telemetry/{step_id}': {
    get: {
      req: RetrieveProviderTraceData;
      res: {
        /**
         * Successful Response
         */
        200: ProviderTrace;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/messages/batches': {
    post: {
      req: CreateMessagesBatchData;
      res: {
        /**
         * Successful Response
         */
        200: BatchJob;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
    get: {
      req: ListBatchRunsData;
      res: {
        /**
         * Successful Response
         */
        200: Array<BatchJob>;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/messages/batches/{batch_id}': {
    get: {
      req: RetrieveBatchRunData;
      res: {
        /**
         * Successful Response
         */
        200: BatchJob;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/messages/batches/{batch_id}/messages': {
    get: {
      req: ListBatchMessagesData;
      res: {
        /**
         * Successful Response
         */
        200: LettaBatchMessages;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/messages/batches/{batch_id}/cancel': {
    patch: {
      req: CancelBatchRunData;
      res: {
        /**
         * Successful Response
         */
        200: unknown;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/voice-beta/{agent_id}/chat/completions': {
    post: {
      req: CreateVoiceChatCompletionsData;
      res: {
        /**
         * Successful response
         */
        200: unknown;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/embeddings/total_storage_size': {
    get: {
      req: GetTotalStorageSizeData;
      res: {
        /**
         * Successful Response
         */
        200: number;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/auth': {
    post: {
      req: AuthenticateUserV1AuthPostData;
      res: {
        /**
         * Successful Response
         */
        200: AuthResponse;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
};
