// This file is auto-generated by @hey-api/openapi-ts

/**
 * Action data model.
 */
export type ActionModel = {
  name: string;
  description: string;
  parameters: ActionParametersModel;
  response: ActionResponseModel;
  appName: string;
  appId: string;
  version: string;
  available_versions: Array<string>;
  tags: Array<string>;
  logo?: string | null;
  display_name?: string | null;
  enabled?: boolean;
};

/**
 * Action parameter data models.
 */
export type ActionParametersModel = {
  properties: {
    [key: string]: unknown;
  };
  title: string;
  type: string;
  required?: Array<string> | null;
  examples?: Array<unknown> | null;
};

/**
 * Action response data model.
 */
export type ActionResponseModel = {
  properties: {
    [key: string]: unknown;
  };
  title: string;
  type: string;
  required?: Array<string> | null;
  examples?: Array<unknown> | null;
};

export type AgentEnvironmentVariable = {
  /**
   * The id of the user that made this object.
   */
  created_by_id?: string | null;
  /**
   * The id of the user that made this object.
   */
  last_updated_by_id?: string | null;
  /**
   * The timestamp when the object was created.
   */
  created_at?: string | null;
  /**
   * The timestamp when the object was last updated.
   */
  updated_at?: string | null;
  /**
   * The human-friendly ID of the Agent-env
   */
  id?: string;
  /**
   * The name of the environment variable.
   */
  key: string;
  /**
   * The value of the environment variable.
   */
  value: string;
  /**
   * An optional description of the environment variable.
   */
  description?: string | null;
  /**
   * The ID of the organization this environment variable belongs to.
   */
  organization_id?: string | null;
  /**
   * The ID of the agent this environment variable belongs to.
   */
  agent_id: string;
};

/**
 * Representation of an agent's state. This is the state of the agent at a given time, and is persisted in the DB backend. The state has all the information needed to recreate a persisted agent.
 *
 * Parameters:
 * id (str): The unique identifier of the agent.
 * name (str): The name of the agent (must be unique to the user).
 * created_at (datetime): The datetime the agent was created.
 * message_ids (List[str]): The ids of the messages in the agent's in-context memory.
 * memory (Memory): The in-context memory of the agent.
 * tools (List[str]): The tools used by the agent. This includes any memory editing functions specified in `memory`.
 * system (str): The system prompt used by the agent.
 * llm_config (LLMConfig): The LLM configuration used by the agent.
 * embedding_config (EmbeddingConfig): The embedding configuration used by the agent.
 */
export type AgentState = {
  /**
   * The id of the user that made this object.
   */
  created_by_id?: string | null;
  /**
   * The id of the user that made this object.
   */
  last_updated_by_id?: string | null;
  /**
   * The timestamp when the object was created.
   */
  created_at?: string | null;
  /**
   * The timestamp when the object was last updated.
   */
  updated_at?: string | null;
  /**
   * The id of the agent. Assigned by the database.
   */
  id: string;
  /**
   * The name of the agent.
   */
  name: string;
  /**
   * The list of tool rules.
   */
  tool_rules?: Array<
    | ChildToolRule
    | InitToolRule
    | TerminalToolRule
    | ConditionalToolRule
    | ContinueToolRule
  > | null;
  /**
   * The ids of the messages in the agent's in-context memory.
   */
  message_ids?: Array<string> | null;
  /**
   * The system prompt used by the agent.
   */
  system: string;
  /**
   * The type of agent.
   */
  agent_type: AgentType;
  /**
   * The LLM configuration used by the agent.
   */
  llm_config: LLMConfig;
  /**
   * The embedding configuration used by the agent.
   */
  embedding_config: EmbeddingConfig;
  /**
   * The unique identifier of the organization associated with the agent.
   */
  organization_id?: string | null;
  /**
   * The description of the agent.
   */
  description?: string | null;
  /**
   * The metadata of the agent.
   */
  metadata?: {
    [key: string]: unknown;
  } | null;
  /**
   * The in-context memory of the agent.
   */
  memory: Memory;
  /**
   * The tools used by the agent.
   */
  tools: Array<Tool>;
  /**
   * The sources used by the agent.
   */
  sources: Array<Source>;
  /**
   * The tags associated with the agent.
   */
  tags: Array<string>;
  /**
   * The environment variables for tool execution specific to this agent.
   */
  tool_exec_environment_variables?: Array<AgentEnvironmentVariable>;
  /**
   * The id of the project the agent belongs to.
   */
  project_id?: string | null;
  /**
   * The id of the template the agent belongs to.
   */
  template_id?: string | null;
  /**
   * The base template id of the agent.
   */
  base_template_id?: string | null;
  /**
   * The ids of the identities associated with this agent.
   */
  identity_ids?: Array<string>;
  /**
   * If set to True, the agent will not remember previous messages (though the agent will still retain state via core memory blocks and archival/recall memory). Not recommended unless you have an advanced use case.
   */
  message_buffer_autoclear?: boolean;
};

/**
 * Enum to represent the type of agent.
 */
export type AgentType =
  | 'memgpt_agent'
  | 'split_thread_agent'
  | 'offline_memory_agent';

/**
 * App authenticatio scheme.
 */
export type AppAuthScheme = {
  scheme_name: string;
  auth_mode:
    | 'OAUTH2'
    | 'OAUTH1'
    | 'API_KEY'
    | 'BASIC'
    | 'BEARER_TOKEN'
    | 'BASIC_WITH_JWT'
    | 'NO_AUTH';
  fields: Array<AuthSchemeField>;
  proxy?: {
    [key: string]: unknown;
  } | null;
  authorization_url?: string | null;
  token_url?: string | null;
  default_scopes?: Array<unknown> | null;
  token_response_metadata?: Array<unknown> | null;
  client_id?: string | null;
  client_secret?: string | null;
};

export type auth_mode =
  | 'OAUTH2'
  | 'OAUTH1'
  | 'API_KEY'
  | 'BASIC'
  | 'BEARER_TOKEN'
  | 'BASIC_WITH_JWT'
  | 'NO_AUTH';

/**
 * App data model.
 */
export type AppModel = {
  name: string;
  key: string;
  appId: string;
  description: string;
  categories: Array<string>;
  meta: {
    [key: string]: unknown;
  };
  logo?: string | null;
  docs?: string | null;
  group?: string | null;
  status?: string | null;
  enabled?: boolean;
  no_auth?: boolean;
  auth_schemes?: Array<AppAuthScheme> | null;
  testConnectors?: Array<{
    [key: string]: unknown;
  }> | null;
  documentation_doc_text?: string | null;
  configuration_docs_text?: string | null;
};

export type AssistantMessage = {
  id: string;
  date: string;
  message_type?: 'assistant_message';
  content: string | Array<TextContent>;
};

export type Audio = {
  id: string;
};

export type AuthRequest = {
  /**
   * Admin password provided when starting the Letta server
   */
  password?: string;
};

export type AuthResponse = {
  /**
   * UUID of the user
   */
  uuid: string;
  /**
   * Whether the user is an admin
   */
  is_admin?: boolean | null;
};

/**
 * Auth scheme field.
 */
export type AuthSchemeField = {
  name: string;
  display_name?: string | null;
  description: string;
  type: string;
  default?: string | null;
  required?: boolean;
  expected_from_customer?: boolean;
  get_current_user_endpoint?: string | null;
};

/**
 * A Block represents a reserved section of the LLM's context window which is editable. `Block` objects contained in the `Memory` object, which is able to edit the Block values.
 *
 * Parameters:
 * label (str): The label of the block (e.g. 'human', 'persona'). This defines a category for the block.
 * value (str): The value of the block. This is the string that is represented in the context window.
 * limit (int): The character limit of the block.
 * is_template (bool): Whether the block is a template (e.g. saved human/persona options). Non-template blocks are not stored in the database and are ephemeral, while templated blocks are stored in the database.
 * label (str): The label of the block (e.g. 'human', 'persona'). This defines a category for the block.
 * template_name (str): The name of the block template (if it is a template).
 * description (str): Description of the block.
 * metadata (Dict): Metadata of the block.
 * user_id (str): The unique identifier of the user associated with the block.
 */
export type Block = {
  /**
   * Value of the block.
   */
  value: string;
  /**
   * Character limit of the block.
   */
  limit?: number;
  /**
   * Name of the block if it is a template.
   */
  name?: string | null;
  /**
   * Whether the block is a template (e.g. saved human/persona options).
   */
  is_template?: boolean;
  /**
   * Label of the block (e.g. 'human', 'persona') in the context window.
   */
  label?: string | null;
  /**
   * Description of the block.
   */
  description?: string | null;
  /**
   * Metadata of the block.
   */
  metadata?: {
    [key: string]: unknown;
  } | null;
  /**
   * The human-friendly ID of the Block
   */
  id?: string;
  /**
   * The unique identifier of the organization associated with the block.
   */
  organization_id?: string | null;
  /**
   * The id of the user that made this Block.
   */
  created_by_id?: string | null;
  /**
   * The id of the user that last updated this Block.
   */
  last_updated_by_id?: string | null;
};

/**
 * Update a block
 */
export type BlockUpdate = {
  /**
   * Value of the block.
   */
  value?: string | null;
  /**
   * Character limit of the block.
   */
  limit?: number | null;
  /**
   * Name of the block if it is a template.
   */
  name?: string | null;
  /**
   * Whether the block is a template (e.g. saved human/persona options).
   */
  is_template?: boolean;
  /**
   * Label of the block (e.g. 'human', 'persona') in the context window.
   */
  label?: string | null;
  /**
   * Description of the block.
   */
  description?: string | null;
  /**
   * Metadata of the block.
   */
  metadata?: {
    [key: string]: unknown;
  } | null;
};

export type Body_upload_agent_serialized = {
  file: Blob | File;
};

export type Body_upload_file_to_source = {
  file: Blob | File;
};

export type ChatCompletionAssistantMessageParam = {
  role: 'assistant';
  audio?: Audio | null;
  content?:
    | string
    | Array<
        | ChatCompletionContentPartTextParam
        | ChatCompletionContentPartRefusalParam
      >
    | null;
  function_call?: FunctionCall | null;
  name?: string;
  refusal?: string | null;
  tool_calls?: Array<ChatCompletionMessageToolCallParam>;
};

export type role = 'assistant';

export type ChatCompletionAudioParam = {
  format: 'wav' | 'mp3' | 'flac' | 'opus' | 'pcm16';
  voice:
    | 'alloy'
    | 'ash'
    | 'ballad'
    | 'coral'
    | 'echo'
    | 'sage'
    | 'shimmer'
    | 'verse';
};

export type format = 'wav' | 'mp3' | 'flac' | 'opus' | 'pcm16';

export type voice =
  | 'alloy'
  | 'ash'
  | 'ballad'
  | 'coral'
  | 'echo'
  | 'sage'
  | 'shimmer'
  | 'verse';

export type ChatCompletionContentPartImageParam = {
  image_url: ImageURL;
  type: 'image_url';
};

export type type = 'image_url';

export type ChatCompletionContentPartInputAudioParam = {
  input_audio: InputAudio;
  type: 'input_audio';
};

export type type2 = 'input_audio';

export type ChatCompletionContentPartRefusalParam = {
  refusal: string;
  type: 'refusal';
};

export type type3 = 'refusal';

export type ChatCompletionContentPartTextParam = {
  text: string;
  type: 'text';
};

export type type4 = 'text';

export type ChatCompletionDeveloperMessageParam = {
  content: string | Array<ChatCompletionContentPartTextParam>;
  role: 'developer';
  name?: string;
};

export type role2 = 'developer';

export type ChatCompletionFunctionCallOptionParam = {
  name: string;
};

export type ChatCompletionFunctionMessageParam = {
  content: string | null;
  name: string;
  role: 'function';
};

export type role3 = 'function';

export type ChatCompletionMessageToolCall_Input = {
  id: string;
  function: openai__types__chat__chat_completion_message_tool_call__Function;
  type: 'function';
  [key: string]:
    | unknown
    | string
    | openai__types__chat__chat_completion_message_tool_call__Function;
};

export type type5 = 'function';

export type ChatCompletionMessageToolCall_Output = {
  id: string;
  function: Function_Output;
  type: 'function';
  [key: string]: unknown | string | Function_Output;
};

export type ChatCompletionMessageToolCallParam = {
  id: string;
  function: openai__types__chat__chat_completion_message_tool_call_param__Function;
  type: 'function';
};

export type ChatCompletionNamedToolChoiceParam = {
  function: openai__types__chat__chat_completion_named_tool_choice_param__Function;
  type: 'function';
};

export type ChatCompletionPredictionContentParam = {
  content: string | Array<ChatCompletionContentPartTextParam>;
  type: 'content';
};

export type type6 = 'content';

export type ChatCompletionStreamOptionsParam = {
  include_usage?: boolean;
};

export type ChatCompletionSystemMessageParam = {
  content: string | Array<ChatCompletionContentPartTextParam>;
  role: 'system';
  name?: string;
};

export type role4 = 'system';

export type ChatCompletionToolMessageParam = {
  content: string | Array<ChatCompletionContentPartTextParam>;
  role: 'tool';
  tool_call_id: string;
};

export type role5 = 'tool';

export type ChatCompletionToolParam = {
  function: FunctionDefinition_Input;
  type: 'function';
};

export type ChatCompletionUserMessageParam = {
  content:
    | string
    | Array<
        | ChatCompletionContentPartTextParam
        | ChatCompletionContentPartImageParam
        | ChatCompletionContentPartInputAudioParam
      >;
  role: 'user';
  name?: string;
};

export type role6 = 'user';

/**
 * A ToolRule represents a tool that can be invoked by the agent.
 */
export type ChildToolRule = {
  /**
   * The name of the tool. Must exist in the database for the user's organization.
   */
  tool_name: string;
  type?: 'constrain_child_tools';
  /**
   * The children tools that can be invoked.
   */
  children: Array<string>;
};

export type type7 = 'constrain_child_tools';

export type CompletionCreateParamsNonStreaming = {
  messages: Array<
    | ChatCompletionDeveloperMessageParam
    | ChatCompletionSystemMessageParam
    | ChatCompletionUserMessageParam
    | ChatCompletionAssistantMessageParam
    | ChatCompletionToolMessageParam
    | ChatCompletionFunctionMessageParam
  >;
  model:
    | string
    | 'o3-mini'
    | 'o3-mini-2025-01-31'
    | 'o1'
    | 'o1-2024-12-17'
    | 'o1-preview'
    | 'o1-preview-2024-09-12'
    | 'o1-mini'
    | 'o1-mini-2024-09-12'
    | 'gpt-4.5-preview'
    | 'gpt-4.5-preview-2025-02-27'
    | 'gpt-4o'
    | 'gpt-4o-2024-11-20'
    | 'gpt-4o-2024-08-06'
    | 'gpt-4o-2024-05-13'
    | 'gpt-4o-audio-preview'
    | 'gpt-4o-audio-preview-2024-10-01'
    | 'gpt-4o-audio-preview-2024-12-17'
    | 'gpt-4o-mini-audio-preview'
    | 'gpt-4o-mini-audio-preview-2024-12-17'
    | 'chatgpt-4o-latest'
    | 'gpt-4o-mini'
    | 'gpt-4o-mini-2024-07-18'
    | 'gpt-4-turbo'
    | 'gpt-4-turbo-2024-04-09'
    | 'gpt-4-0125-preview'
    | 'gpt-4-turbo-preview'
    | 'gpt-4-1106-preview'
    | 'gpt-4-vision-preview'
    | 'gpt-4'
    | 'gpt-4-0314'
    | 'gpt-4-0613'
    | 'gpt-4-32k'
    | 'gpt-4-32k-0314'
    | 'gpt-4-32k-0613'
    | 'gpt-3.5-turbo'
    | 'gpt-3.5-turbo-16k'
    | 'gpt-3.5-turbo-0301'
    | 'gpt-3.5-turbo-0613'
    | 'gpt-3.5-turbo-1106'
    | 'gpt-3.5-turbo-0125'
    | 'gpt-3.5-turbo-16k-0613';
  audio?: ChatCompletionAudioParam | null;
  frequency_penalty?: number | null;
  function_call?: 'none' | 'auto' | ChatCompletionFunctionCallOptionParam;
  functions?: Array<openai__types__chat__completion_create_params__Function>;
  logit_bias?: {
    [key: string]: number;
  } | null;
  logprobs?: boolean | null;
  max_completion_tokens?: number | null;
  max_tokens?: number | null;
  metadata?: {
    [key: string]: string;
  } | null;
  modalities?: Array<'text' | 'audio'> | null;
  n?: number | null;
  parallel_tool_calls?: boolean;
  prediction?: ChatCompletionPredictionContentParam | null;
  presence_penalty?: number | null;
  reasoning_effort?: 'low' | 'medium' | 'high' | null;
  response_format?:
    | ResponseFormatText
    | ResponseFormatJSONObject
    | ResponseFormatJSONSchema;
  seed?: number | null;
  service_tier?: 'auto' | 'default' | null;
  stop?: string | Array<string> | null;
  store?: boolean | null;
  stream_options?: ChatCompletionStreamOptionsParam | null;
  temperature?: number | null;
  tool_choice?:
    | 'none'
    | 'auto'
    | 'required'
    | ChatCompletionNamedToolChoiceParam;
  tools?: Array<ChatCompletionToolParam>;
  top_logprobs?: number | null;
  top_p?: number | null;
  user?: string;
  stream?: false | null;
};

export type CompletionCreateParamsStreaming = {
  messages: Array<
    | ChatCompletionDeveloperMessageParam
    | ChatCompletionSystemMessageParam
    | ChatCompletionUserMessageParam
    | ChatCompletionAssistantMessageParam
    | ChatCompletionToolMessageParam
    | ChatCompletionFunctionMessageParam
  >;
  model:
    | string
    | 'o3-mini'
    | 'o3-mini-2025-01-31'
    | 'o1'
    | 'o1-2024-12-17'
    | 'o1-preview'
    | 'o1-preview-2024-09-12'
    | 'o1-mini'
    | 'o1-mini-2024-09-12'
    | 'gpt-4.5-preview'
    | 'gpt-4.5-preview-2025-02-27'
    | 'gpt-4o'
    | 'gpt-4o-2024-11-20'
    | 'gpt-4o-2024-08-06'
    | 'gpt-4o-2024-05-13'
    | 'gpt-4o-audio-preview'
    | 'gpt-4o-audio-preview-2024-10-01'
    | 'gpt-4o-audio-preview-2024-12-17'
    | 'gpt-4o-mini-audio-preview'
    | 'gpt-4o-mini-audio-preview-2024-12-17'
    | 'chatgpt-4o-latest'
    | 'gpt-4o-mini'
    | 'gpt-4o-mini-2024-07-18'
    | 'gpt-4-turbo'
    | 'gpt-4-turbo-2024-04-09'
    | 'gpt-4-0125-preview'
    | 'gpt-4-turbo-preview'
    | 'gpt-4-1106-preview'
    | 'gpt-4-vision-preview'
    | 'gpt-4'
    | 'gpt-4-0314'
    | 'gpt-4-0613'
    | 'gpt-4-32k'
    | 'gpt-4-32k-0314'
    | 'gpt-4-32k-0613'
    | 'gpt-3.5-turbo'
    | 'gpt-3.5-turbo-16k'
    | 'gpt-3.5-turbo-0301'
    | 'gpt-3.5-turbo-0613'
    | 'gpt-3.5-turbo-1106'
    | 'gpt-3.5-turbo-0125'
    | 'gpt-3.5-turbo-16k-0613';
  audio?: ChatCompletionAudioParam | null;
  frequency_penalty?: number | null;
  function_call?: 'none' | 'auto' | ChatCompletionFunctionCallOptionParam;
  functions?: Array<openai__types__chat__completion_create_params__Function>;
  logit_bias?: {
    [key: string]: number;
  } | null;
  logprobs?: boolean | null;
  max_completion_tokens?: number | null;
  max_tokens?: number | null;
  metadata?: {
    [key: string]: string;
  } | null;
  modalities?: Array<'text' | 'audio'> | null;
  n?: number | null;
  parallel_tool_calls?: boolean;
  prediction?: ChatCompletionPredictionContentParam | null;
  presence_penalty?: number | null;
  reasoning_effort?: 'low' | 'medium' | 'high' | null;
  response_format?:
    | ResponseFormatText
    | ResponseFormatJSONObject
    | ResponseFormatJSONSchema;
  seed?: number | null;
  service_tier?: 'auto' | 'default' | null;
  stop?: string | Array<string> | null;
  store?: boolean | null;
  stream_options?: ChatCompletionStreamOptionsParam | null;
  temperature?: number | null;
  tool_choice?:
    | 'none'
    | 'auto'
    | 'required'
    | ChatCompletionNamedToolChoiceParam;
  tools?: Array<ChatCompletionToolParam>;
  top_logprobs?: number | null;
  top_p?: number | null;
  user?: string;
  stream: true;
};

/**
 * A ToolRule that conditionally maps to different child tools based on the output.
 */
export type ConditionalToolRule = {
  /**
   * The name of the tool. Must exist in the database for the user's organization.
   */
  tool_name: string;
  type?: 'conditional';
  /**
   * The default child tool to be called. If None, any tool can be called.
   */
  default_child?: string | null;
  /**
   * The output case to check for mapping
   */
  child_output_mapping: {
    [key: string]: string;
  };
  /**
   * Whether to throw an error when output doesn't match any case
   */
  require_output_mapping?: boolean;
};

export type type8 = 'conditional';

/**
 * Overview of the context window, including the number of messages and tokens.
 */
export type ContextWindowOverview = {
  /**
   * The maximum amount of tokens the context window can hold.
   */
  context_window_size_max: number;
  /**
   * The current number of tokens in the context window.
   */
  context_window_size_current: number;
  /**
   * The number of messages in the context window.
   */
  num_messages: number;
  /**
   * The number of messages in the archival memory.
   */
  num_archival_memory: number;
  /**
   * The number of messages in the recall memory.
   */
  num_recall_memory: number;
  /**
   * The number of tokens in the external memory summary (archival + recall metadata).
   */
  num_tokens_external_memory_summary: number;
  /**
   * The metadata summary of the external memory sources (archival + recall metadata).
   */
  external_memory_summary: string;
  /**
   * The number of tokens in the system prompt.
   */
  num_tokens_system: number;
  /**
   * The content of the system prompt.
   */
  system_prompt: string;
  /**
   * The number of tokens in the core memory.
   */
  num_tokens_core_memory: number;
  /**
   * The content of the core memory.
   */
  core_memory: string;
  /**
   * The number of tokens in the summary memory.
   */
  num_tokens_summary_memory: number;
  /**
   * The content of the summary memory.
   */
  summary_memory?: string | null;
  /**
   * The number of tokens in the functions definitions.
   */
  num_tokens_functions_definitions: number;
  /**
   * The content of the functions definitions.
   */
  functions_definitions: Array<FunctionTool> | null;
  /**
   * The number of tokens in the messages list.
   */
  num_tokens_messages: number;
  /**
   * The messages in the context window.
   */
  messages: Array<Message>;
};

/**
 * Represents a tool rule configuration where if this tool gets called, it must continue the agent loop.
 */
export type ContinueToolRule = {
  /**
   * The name of the tool. Must exist in the database for the user's organization.
   */
  tool_name: string;
  type?: 'continue_loop';
};

export type type9 = 'continue_loop';

/**
 * CreateAgent model specifically for POST request body, excluding user_id which comes from headers
 */
export type CreateAgentRequest = {
  /**
   * The name of the agent.
   */
  name?: string;
  /**
   * The blocks to create in the agent's in-context memory.
   */
  memory_blocks?: Array<CreateBlock> | null;
  /**
   * The tools used by the agent.
   */
  tools?: Array<string> | null;
  /**
   * The ids of the tools used by the agent.
   */
  tool_ids?: Array<string> | null;
  /**
   * The ids of the sources used by the agent.
   */
  source_ids?: Array<string> | null;
  /**
   * The ids of the blocks used by the agent.
   */
  block_ids?: Array<string> | null;
  /**
   * The tool rules governing the agent.
   */
  tool_rules?: Array<
    | ChildToolRule
    | InitToolRule
    | TerminalToolRule
    | ConditionalToolRule
    | ContinueToolRule
  > | null;
  /**
   * The tags associated with the agent.
   */
  tags?: Array<string> | null;
  /**
   * The system prompt used by the agent.
   */
  system?: string | null;
  /**
   * The type of agent.
   */
  agent_type?: AgentType;
  /**
   * The LLM configuration used by the agent.
   */
  llm_config?: LLMConfig | null;
  /**
   * The embedding configuration used by the agent.
   */
  embedding_config?: EmbeddingConfig | null;
  /**
   * The initial set of messages to put in the agent's in-context memory.
   */
  initial_message_sequence?: Array<MessageCreate> | null;
  /**
   * If true, attaches the Letta core tools (e.g. archival_memory and core_memory related functions).
   */
  include_base_tools?: boolean;
  /**
   * If true, attaches the Letta multi-agent tools (e.g. sending a message to another agent).
   */
  include_multi_agent_tools?: boolean;
  /**
   * If true, attaches the Letta base tool rules (e.g. deny all tools not explicitly allowed).
   */
  include_base_tool_rules?: boolean;
  /**
   * The description of the agent.
   */
  description?: string | null;
  /**
   * The metadata of the agent.
   */
  metadata?: {
    [key: string]: unknown;
  } | null;
  /**
   * The LLM configuration handle used by the agent, specified in the format provider/model-name, as an alternative to specifying llm_config.
   */
  model?: string | null;
  /**
   * The embedding configuration handle used by the agent, specified in the format provider/model-name.
   */
  embedding?: string | null;
  /**
   * The context window limit used by the agent.
   */
  context_window_limit?: number | null;
  /**
   * The embedding chunk size used by the agent.
   */
  embedding_chunk_size?: number | null;
  /**
   * The template id used to configure the agent
   */
  from_template?: string | null;
  /**
   * Whether the agent is a template
   */
  template?: boolean;
  /**
   * Deprecated: Project should now be passed via the X-Project header instead of in the request body. If using the sdk, this can be done via the new x_project field below.
   * @deprecated
   */
  project?: string | null;
  /**
   * The environment variables for tool execution specific to this agent.
   */
  tool_exec_environment_variables?: {
    [key: string]: string;
  } | null;
  /**
   * The variables that should be set for the agent.
   */
  memory_variables?: {
    [key: string]: string;
  } | null;
  /**
   * The id of the project the agent belongs to.
   */
  project_id?: string | null;
  /**
   * The id of the template the agent belongs to.
   */
  template_id?: string | null;
  /**
   * The base template id of the agent.
   */
  base_template_id?: string | null;
  /**
   * The ids of the identities associated with this agent.
   */
  identity_ids?: Array<string> | null;
  /**
   * If set to True, the agent will not remember previous messages (though the agent will still retain state via core memory blocks and archival/recall memory). Not recommended unless you have an advanced use case.
   */
  message_buffer_autoclear?: boolean;
  actor_id?: string | null;
};

export type CreateArchivalMemory = {
  /**
   * Text to write to archival memory.
   */
  text: string;
};

/**
 * Create a block
 */
export type CreateBlock = {
  /**
   * Value of the block.
   */
  value: string;
  /**
   * Character limit of the block.
   */
  limit?: number;
  /**
   * Name of the block if it is a template.
   */
  name?: string | null;
  is_template?: boolean;
  /**
   * Label of the block.
   */
  label: string;
  /**
   * Description of the block.
   */
  description?: string | null;
  /**
   * Metadata of the block.
   */
  metadata?: {
    [key: string]: unknown;
  } | null;
};

export type E2BSandboxConfig = {
  /**
   * Time limit for the sandbox (in seconds).
   */
  timeout?: number;
  /**
   * The E2B template id (docker image).
   */
  template?: string | null;
  /**
   * A list of pip packages to install on the E2B Sandbox
   */
  pip_requirements?: Array<string> | null;
};

/**
 * Embedding model configuration. This object specifies all the information necessary to access an embedding model to usage with Letta, except for secret keys.
 *
 * Attributes:
 * embedding_endpoint_type (str): The endpoint type for the model.
 * embedding_endpoint (str): The endpoint for the model.
 * embedding_model (str): The model for the embedding.
 * embedding_dim (int): The dimension of the embedding.
 * embedding_chunk_size (int): The chunk size of the embedding.
 * azure_endpoint (:obj:`str`, optional): The Azure endpoint for the model (Azure only).
 * azure_version (str): The Azure version for the model (Azure only).
 * azure_deployment (str): The Azure deployment for the model (Azure only).
 */
export type EmbeddingConfig = {
  /**
   * The endpoint type for the model.
   */
  embedding_endpoint_type:
    | 'openai'
    | 'anthropic'
    | 'bedrock'
    | 'cohere'
    | 'google_ai'
    | 'google_vertex'
    | 'azure'
    | 'groq'
    | 'ollama'
    | 'webui'
    | 'webui-legacy'
    | 'lmstudio'
    | 'lmstudio-legacy'
    | 'llamacpp'
    | 'koboldcpp'
    | 'vllm'
    | 'hugging-face'
    | 'mistral'
    | 'together';
  /**
   * The endpoint for the model (`None` if local).
   */
  embedding_endpoint?: string | null;
  /**
   * The model for the embedding.
   */
  embedding_model: string;
  /**
   * The dimension of the embedding.
   */
  embedding_dim: number;
  /**
   * The chunk size of the embedding.
   */
  embedding_chunk_size?: number | null;
  /**
   * The handle for this config, in the format provider/model-name.
   */
  handle?: string | null;
  /**
   * The Azure endpoint for the model.
   */
  azure_endpoint?: string | null;
  /**
   * The Azure version for the model.
   */
  azure_version?: string | null;
  /**
   * The Azure deployment for the model.
   */
  azure_deployment?: string | null;
};

/**
 * The endpoint type for the model.
 */
export type embedding_endpoint_type =
  | 'openai'
  | 'anthropic'
  | 'bedrock'
  | 'cohere'
  | 'google_ai'
  | 'google_vertex'
  | 'azure'
  | 'groq'
  | 'ollama'
  | 'webui'
  | 'webui-legacy'
  | 'lmstudio'
  | 'lmstudio-legacy'
  | 'llamacpp'
  | 'koboldcpp'
  | 'vllm'
  | 'hugging-face'
  | 'mistral'
  | 'together';

/**
 * Representation of a single FileMetadata
 */
export type FileMetadata = {
  /**
   * The human-friendly ID of the File
   */
  id?: string;
  /**
   * The unique identifier of the organization associated with the document.
   */
  organization_id?: string | null;
  /**
   * The unique identifier of the source associated with the document.
   */
  source_id: string;
  /**
   * The name of the file.
   */
  file_name?: string | null;
  /**
   * The path to the file.
   */
  file_path?: string | null;
  /**
   * The type of the file (MIME type).
   */
  file_type?: string | null;
  /**
   * The size of the file in bytes.
   */
  file_size?: number | null;
  /**
   * The creation date of the file.
   */
  file_creation_date?: string | null;
  /**
   * The last modified date of the file.
   */
  file_last_modified_date?: string | null;
  /**
   * The creation date of the file.
   */
  created_at?: string | null;
  /**
   * The update date of the file.
   */
  updated_at?: string | null;
  /**
   * Whether this file is deleted or not.
   */
  is_deleted?: boolean;
};

export type Function_Output = {
  arguments: string;
  name: string;
  [key: string]: unknown | string;
};

export type FunctionCall = {
  arguments: string;
  name: string;
};

export type FunctionDefinition_Input = {
  name: string;
  description?: string;
  parameters?: {
    [key: string]: unknown;
  };
  strict?: boolean | null;
};

export type FunctionDefinition_Output = {
  name: string;
  description?: string | null;
  parameters?: {
    [key: string]: unknown;
  } | null;
  strict?: boolean | null;
  [key: string]: unknown | string;
};

export type FunctionTool = {
  function: FunctionDefinition_Output;
  type: 'function';
  [key: string]: unknown | FunctionDefinition_Output | string;
};

export type HTTPValidationError = {
  detail?: Array<ValidationError>;
};

/**
 * Health check response body
 */
export type Health = {
  version: string;
  status: string;
};

export type Identity = {
  /**
   * The human-friendly ID of the Identity
   */
  id?: string;
  /**
   * External, user-generated identifier key of the identity.
   */
  identifier_key: string;
  /**
   * The name of the identity.
   */
  name: string;
  /**
   * The type of the identity.
   */
  identity_type: IdentityType;
  /**
   * The project id of the identity, if applicable.
   */
  project_id?: string | null;
  /**
   * The IDs of the agents associated with the identity.
   */
  agent_ids: Array<string>;
  /**
   * The organization id of the user
   */
  organization_id?: string | null;
  /**
   * List of properties associated with the identity
   */
  properties?: Array<IdentityProperty>;
};

export type IdentityCreate = {
  /**
   * External, user-generated identifier key of the identity.
   */
  identifier_key: string;
  /**
   * The name of the identity.
   */
  name: string;
  /**
   * The type of the identity.
   */
  identity_type: IdentityType;
  /**
   * The project id of the identity, if applicable.
   */
  project_id?: string | null;
  /**
   * The agent ids that are associated with the identity.
   */
  agent_ids?: Array<string> | null;
  /**
   * List of properties associated with the identity.
   */
  properties?: Array<IdentityProperty> | null;
};

/**
 * A property of an identity
 */
export type IdentityProperty = {
  /**
   * The key of the property
   */
  key: string;
  /**
   * The value of the property
   */
  value:
    | string
    | number
    | boolean
    | {
        [key: string]: unknown;
      };
  /**
   * The type of the property
   */
  type: IdentityPropertyType;
};

/**
 * Enum to represent the type of the identity property.
 */
export type IdentityPropertyType = 'string' | 'number' | 'boolean' | 'json';

/**
 * Enum to represent the type of the identity.
 */
export type IdentityType = 'org' | 'user' | 'other';

export type IdentityUpdate = {
  /**
   * External, user-generated identifier key of the identity.
   */
  identifier_key?: string | null;
  /**
   * The name of the identity.
   */
  name?: string | null;
  /**
   * The type of the identity.
   */
  identity_type?: IdentityType | null;
  /**
   * The agent ids that are associated with the identity.
   */
  agent_ids?: Array<string> | null;
  /**
   * List of properties associated with the identity.
   */
  properties?: Array<IdentityProperty> | null;
};

export type ImageURL = {
  url: string;
  detail?: 'auto' | 'low' | 'high';
};

export type detail = 'auto' | 'low' | 'high';

/**
 * Represents the initial tool rule configuration.
 */
export type InitToolRule = {
  /**
   * The name of the tool. Must exist in the database for the user's organization.
   */
  tool_name: string;
  type?: 'run_first';
};

export type type10 = 'run_first';

export type InputAudio = {
  data: string;
  format: 'wav' | 'mp3';
};

export type format2 = 'wav' | 'mp3';

export type JSONSchema = {
  name: string;
  description?: string;
  schema?: {
    [key: string]: unknown;
  };
  strict?: boolean | null;
};

/**
 * Representation of offline jobs, used for tracking status of data loading tasks (involving parsing and embedding files).
 *
 * Parameters:
 * id (str): The unique identifier of the job.
 * status (JobStatus): The status of the job.
 * created_at (datetime): The unix timestamp of when the job was created.
 * completed_at (datetime): The unix timestamp of when the job was completed.
 * user_id (str): The unique identifier of the user associated with the.
 */
export type Job = {
  /**
   * The id of the user that made this object.
   */
  created_by_id?: string | null;
  /**
   * The id of the user that made this object.
   */
  last_updated_by_id?: string | null;
  /**
   * The timestamp when the object was created.
   */
  created_at?: string | null;
  /**
   * The timestamp when the object was last updated.
   */
  updated_at?: string | null;
  /**
   * The status of the job.
   */
  status?: JobStatus;
  /**
   * The unix timestamp of when the job was completed.
   */
  completed_at?: string | null;
  /**
   * The metadata of the job.
   */
  metadata?: {
    [key: string]: unknown;
  } | null;
  /**
   * The type of the job.
   */
  job_type?: JobType;
  /**
   * The human-friendly ID of the Job
   */
  id?: string;
  /**
   * The unique identifier of the user associated with the job.
   */
  user_id?: string | null;
};

/**
 * Status of the job.
 */
export type JobStatus =
  | 'created'
  | 'running'
  | 'completed'
  | 'failed'
  | 'pending';

export type JobType = 'job' | 'run';

/**
 * Configuration for a Language Model (LLM) model. This object specifies all the information necessary to access an LLM model to usage with Letta, except for secret keys.
 *
 * Attributes:
 * model (str): The name of the LLM model.
 * model_endpoint_type (str): The endpoint type for the model.
 * model_endpoint (str): The endpoint for the model.
 * model_wrapper (str): The wrapper for the model. This is used to wrap additional text around the input/output of the model. This is useful for text-to-text completions, such as the Completions API in OpenAI.
 * context_window (int): The context window size for the model.
 * put_inner_thoughts_in_kwargs (bool): Puts `inner_thoughts` as a kwarg in the function call if this is set to True. This helps with function calling performance and also the generation of inner thoughts.
 * temperature (float): The temperature to use when generating text with the model. A higher temperature will result in more random text.
 * max_tokens (int): The maximum number of tokens to generate.
 */
export type LLMConfig = {
  /**
   * LLM model name.
   */
  model: string;
  /**
   * The endpoint type for the model.
   */
  model_endpoint_type:
    | 'openai'
    | 'anthropic'
    | 'cohere'
    | 'google_ai'
    | 'google_vertex'
    | 'azure'
    | 'groq'
    | 'ollama'
    | 'webui'
    | 'webui-legacy'
    | 'lmstudio'
    | 'lmstudio-legacy'
    | 'lmstudio-chatcompletions'
    | 'llamacpp'
    | 'koboldcpp'
    | 'vllm'
    | 'hugging-face'
    | 'mistral'
    | 'together'
    | 'bedrock'
    | 'deepseek'
    | 'xai';
  /**
   * The endpoint for the model.
   */
  model_endpoint?: string | null;
  /**
   * The wrapper for the model.
   */
  model_wrapper?: string | null;
  /**
   * The context window size for the model.
   */
  context_window: number;
  /**
   * Puts 'inner_thoughts' as a kwarg in the function call if this is set to True. This helps with function calling performance and also the generation of inner thoughts.
   */
  put_inner_thoughts_in_kwargs?: boolean | null;
  /**
   * The handle for this config, in the format provider/model-name.
   */
  handle?: string | null;
  /**
   * The temperature to use when generating text with the model. A higher temperature will result in more random text.
   */
  temperature?: number;
  /**
   * The maximum number of tokens to generate. If not set, the model will use its default value.
   */
  max_tokens?: number | null;
};

/**
 * The endpoint type for the model.
 */
export type model_endpoint_type =
  | 'openai'
  | 'anthropic'
  | 'cohere'
  | 'google_ai'
  | 'google_vertex'
  | 'azure'
  | 'groq'
  | 'ollama'
  | 'webui'
  | 'webui-legacy'
  | 'lmstudio'
  | 'lmstudio-legacy'
  | 'lmstudio-chatcompletions'
  | 'llamacpp'
  | 'koboldcpp'
  | 'vllm'
  | 'hugging-face'
  | 'mistral'
  | 'together'
  | 'bedrock'
  | 'deepseek'
  | 'xai';

export type LettaRequest = {
  /**
   * The messages to be sent to the agent.
   */
  messages: Array<MessageCreate>;
  /**
   * Whether the server should parse specific tool call arguments (default `send_message`) as `AssistantMessage` objects.
   */
  use_assistant_message?: boolean;
  /**
   * The name of the designated message tool.
   */
  assistant_message_tool_name?: string;
  /**
   * The name of the message argument in the designated message tool.
   */
  assistant_message_tool_kwarg?: string;
};

export type LettaRequestConfig = {
  /**
   * Whether the server should parse specific tool call arguments (default `send_message`) as `AssistantMessage` objects.
   */
  use_assistant_message?: boolean;
  /**
   * The name of the designated message tool.
   */
  assistant_message_tool_name?: string;
  /**
   * The name of the message argument in the designated message tool.
   */
  assistant_message_tool_kwarg?: string;
};

/**
 * Response object from an agent interaction, consisting of the new messages generated by the agent and usage statistics.
 * The type of the returned messages can be either `Message` or `LettaMessage`, depending on what was specified in the request.
 *
 * Attributes:
 * messages (List[Union[Message, LettaMessage]]): The messages returned by the agent.
 * usage (LettaUsageStatistics): The usage statistics
 */
export type LettaResponse = {
  /**
   * The messages returned by the agent.
   */
  messages: Array<LettaMessageUnion>;
  /**
   * The usage statistics of the agent.
   */
  usage: LettaUsageStatistics;
};

export type LettaStreamingRequest = {
  /**
   * The messages to be sent to the agent.
   */
  messages: Array<MessageCreate>;
  /**
   * Whether the server should parse specific tool call arguments (default `send_message`) as `AssistantMessage` objects.
   */
  use_assistant_message?: boolean;
  /**
   * The name of the designated message tool.
   */
  assistant_message_tool_name?: string;
  /**
   * The name of the message argument in the designated message tool.
   */
  assistant_message_tool_kwarg?: string;
  /**
   * Flag to determine if individual tokens should be streamed. Set to True for token streaming (requires stream_steps = True).
   */
  stream_tokens?: boolean;
};

/**
 * Usage statistics for the agent interaction.
 *
 * Attributes:
 * completion_tokens (int): The number of tokens generated by the agent.
 * prompt_tokens (int): The number of tokens in the prompt.
 * total_tokens (int): The total number of tokens processed by the agent.
 * step_count (int): The number of steps taken by the agent.
 */
export type LettaUsageStatistics = {
  message_type?: 'usage_statistics';
  /**
   * The number of tokens generated by the agent.
   */
  completion_tokens?: number;
  /**
   * The number of tokens in the prompt.
   */
  prompt_tokens?: number;
  /**
   * The total number of tokens processed by the agent.
   */
  total_tokens?: number;
  /**
   * The number of steps taken by the agent.
   */
  step_count?: number;
};

export type message_type = 'usage_statistics';

export type LocalSandboxConfig = {
  /**
   * Directory for the sandbox environment.
   */
  sandbox_dir?: string | null;
  /**
   * Whether or not to use the venv, or run directly in the same run loop.
   */
  use_venv?: boolean;
  /**
   * The name for the venv in the sandbox directory. We first search for an existing venv with this name, otherwise, we make it from the requirements.txt.
   */
  venv_name?: string;
  /**
   * List of pip packages to install with mandatory name and optional version following semantic versioning. This only is considered when use_venv is True.
   */
  pip_requirements?: Array<PipRequirement>;
};

/**
 * Represents the in-context memory (i.e. Core memory) of the agent. This includes both the `Block` objects (labelled by sections), as well as tools to edit the blocks.
 */
export type Memory = {
  /**
   * Memory blocks contained in the agent's in-context memory
   */
  blocks: Array<Block>;
  /**
   * Jinja2 template for compiling memory blocks into a prompt string
   */
  prompt_template?: string;
};

/**
 * Letta's internal representation of a message. Includes methods to convert to/from LLM provider formats.
 *
 * Attributes:
 * id (str): The unique identifier of the message.
 * role (MessageRole): The role of the participant.
 * text (str): The text of the message.
 * user_id (str): The unique identifier of the user.
 * agent_id (str): The unique identifier of the agent.
 * model (str): The model used to make the function call.
 * name (str): The name of the participant.
 * created_at (datetime): The time the message was created.
 * tool_calls (List[OpenAIToolCall,]): The list of tool calls requested.
 * tool_call_id (str): The id of the tool call.
 */
export type Message = {
  /**
   * The id of the user that made this object.
   */
  created_by_id?: string | null;
  /**
   * The id of the user that made this object.
   */
  last_updated_by_id?: string | null;
  /**
   * The timestamp when the object was created.
   */
  created_at?: string;
  /**
   * The timestamp when the object was last updated.
   */
  updated_at?: string | null;
  /**
   * The human-friendly ID of the Message
   */
  id?: string;
  /**
   * The role of the participant.
   */
  role: MessageRole;
  /**
   * The content of the message.
   */
  content?: Array<TextContent> | null;
  /**
   * The unique identifier of the organization.
   */
  organization_id?: string | null;
  /**
   * The unique identifier of the agent.
   */
  agent_id?: string | null;
  /**
   * The model used to make the function call.
   */
  model?: string | null;
  /**
   * The name of the participant.
   */
  name?: string | null;
  /**
   * The list of tool calls requested.
   */
  tool_calls?: Array<ChatCompletionMessageToolCall_Output> | null;
  /**
   * The id of the tool call.
   */
  tool_call_id?: string | null;
  /**
   * The id of the step that this message was created in.
   */
  step_id?: string | null;
};

/**
 * Request to create a message
 */
export type MessageCreate = {
  /**
   * The role of the participant.
   */
  role: 'user' | 'system';
  /**
   * The content of the message.
   */
  content: string | Array<TextContent>;
  /**
   * The name of the participant.
   */
  name?: string | null;
};

/**
 * The role of the participant.
 */
export type role7 = 'user' | 'system';

export type MessageRole = 'assistant' | 'user' | 'tool' | 'function' | 'system';

/**
 * Request to update a message
 */
export type MessageUpdate = {
  /**
   * The role of the participant.
   */
  role?: MessageRole | null;
  /**
   * The content of the message.
   */
  content: string | Array<TextContent> | null;
  /**
   * The name of the participant.
   */
  name?: string | null;
  /**
   * The list of tool calls requested.
   */
  tool_calls?: Array<ChatCompletionMessageToolCall_Input> | null;
  /**
   * The id of the tool call.
   */
  tool_call_id?: string | null;
};

export type Organization = {
  /**
   * The human-friendly ID of the Org
   */
  id?: string;
  /**
   * The name of the organization.
   */
  name?: string;
  /**
   * The creation date of the organization.
   */
  created_at?: string | null;
};

export type OrganizationCreate = {
  /**
   * The name of the organization.
   */
  name?: string | null;
};

/**
 * Representation of a passage, which is stored in archival memory.
 *
 * Parameters:
 * text (str): The text of the passage.
 * embedding (List[float]): The embedding of the passage.
 * embedding_config (EmbeddingConfig): The embedding configuration used by the passage.
 * created_at (datetime): The creation date of the passage.
 * user_id (str): The unique identifier of the user associated with the passage.
 * agent_id (str): The unique identifier of the agent associated with the passage.
 * source_id (str): The data source of the passage.
 * file_id (str): The unique identifier of the file associated with the passage.
 */
export type Passage = {
  /**
   * The id of the user that made this object.
   */
  created_by_id?: string | null;
  /**
   * The id of the user that made this object.
   */
  last_updated_by_id?: string | null;
  /**
   * The creation date of the passage.
   */
  created_at?: string;
  /**
   * The timestamp when the object was last updated.
   */
  updated_at?: string | null;
  /**
   * Whether this passage is deleted or not.
   */
  is_deleted?: boolean;
  /**
   * The unique identifier of the user associated with the passage.
   */
  organization_id?: string | null;
  /**
   * The unique identifier of the agent associated with the passage.
   */
  agent_id?: string | null;
  /**
   * The data source of the passage.
   */
  source_id?: string | null;
  /**
   * The unique identifier of the file associated with the passage.
   */
  file_id?: string | null;
  /**
   * The metadata of the passage.
   */
  metadata?: {
    [key: string]: unknown;
  } | null;
  /**
   * The human-friendly ID of the Passage
   */
  id?: string;
  /**
   * The text of the passage.
   */
  text: string;
  /**
   * The embedding of the passage.
   */
  embedding: Array<number> | null;
  /**
   * The embedding configuration used by the passage.
   */
  embedding_config: EmbeddingConfig | null;
};

export type PassageUpdate = {
  /**
   * The id of the user that made this object.
   */
  created_by_id?: string | null;
  /**
   * The id of the user that made this object.
   */
  last_updated_by_id?: string | null;
  /**
   * The timestamp when the object was created.
   */
  created_at?: string | null;
  /**
   * The timestamp when the object was last updated.
   */
  updated_at?: string | null;
  /**
   * Whether this passage is deleted or not.
   */
  is_deleted?: boolean;
  /**
   * The unique identifier of the user associated with the passage.
   */
  organization_id?: string | null;
  /**
   * The unique identifier of the agent associated with the passage.
   */
  agent_id?: string | null;
  /**
   * The data source of the passage.
   */
  source_id?: string | null;
  /**
   * The unique identifier of the file associated with the passage.
   */
  file_id?: string | null;
  /**
   * The metadata of the passage.
   */
  metadata_?: {
    [key: string]: unknown;
  } | null;
  /**
   * The text of the passage.
   */
  text?: string | null;
  /**
   * The embedding of the passage.
   */
  embedding?: Array<number> | null;
  /**
   * The embedding configuration used by the passage.
   */
  embedding_config?: EmbeddingConfig | null;
  /**
   * The unique identifier of the passage.
   */
  id: string;
};

export type PipRequirement = {
  /**
   * Name of the pip package.
   */
  name: string;
  /**
   * Optional version of the package, following semantic versioning.
   */
  version?: string | null;
};

export type Provider = {
  /**
   * The id of the provider, lazily created by the database manager.
   */
  id?: string | null;
  /**
   * The name of the provider
   */
  name: string;
  /**
   * API key used for requests to the provider.
   */
  api_key?: string | null;
  /**
   * The organization id of the user
   */
  organization_id?: string | null;
  /**
   * The last update timestamp of the provider.
   */
  updated_at?: string | null;
};

export type ProviderCreate = {
  /**
   * The name of the provider.
   */
  name: string;
  /**
   * API key used for requests to the provider.
   */
  api_key: string;
};

export type ProviderUpdate = {
  /**
   * The id of the provider to update.
   */
  id: string;
  /**
   * API key used for requests to the provider.
   */
  api_key: string;
};

/**
 * Representation of an agent's internal reasoning.
 *
 * Attributes:
 * reasoning (str): The internal reasoning of the agent
 * id (str): The ID of the message
 * date (datetime): The date the message was created in ISO format
 */
export type ReasoningMessage = {
  id: string;
  date: string;
  message_type?: 'reasoning_message';
  reasoning: string;
};

export type ResponseFormatJSONObject = {
  type: 'json_object';
};

export type type11 = 'json_object';

export type ResponseFormatJSONSchema = {
  json_schema: JSONSchema;
  type: 'json_schema';
};

export type type12 = 'json_schema';

export type ResponseFormatText = {
  type: 'text';
};

/**
 * Representation of a run, which is a job with a 'run' prefix in its ID.
 * Inherits all fields and behavior from Job except for the ID prefix.
 *
 * Parameters:
 * id (str): The unique identifier of the run (prefixed with 'run-').
 * status (JobStatus): The status of the run.
 * created_at (datetime): The unix timestamp of when the run was created.
 * completed_at (datetime): The unix timestamp of when the run was completed.
 * user_id (str): The unique identifier of the user associated with the run.
 */
export type Run = {
  /**
   * The id of the user that made this object.
   */
  created_by_id?: string | null;
  /**
   * The id of the user that made this object.
   */
  last_updated_by_id?: string | null;
  /**
   * The timestamp when the object was created.
   */
  created_at?: string | null;
  /**
   * The timestamp when the object was last updated.
   */
  updated_at?: string | null;
  /**
   * The status of the job.
   */
  status?: JobStatus;
  /**
   * The unix timestamp of when the job was completed.
   */
  completed_at?: string | null;
  /**
   * The metadata of the job.
   */
  metadata?: {
    [key: string]: unknown;
  } | null;
  job_type?: JobType;
  /**
   * The human-friendly ID of the Run
   */
  id?: string;
  /**
   * The unique identifier of the user associated with the run.
   */
  user_id?: string | null;
  /**
   * The request configuration for the run.
   */
  request_config?: LettaRequestConfig | null;
};

export type SandboxConfig = {
  /**
   * The id of the user that made this object.
   */
  created_by_id?: string | null;
  /**
   * The id of the user that made this object.
   */
  last_updated_by_id?: string | null;
  /**
   * The timestamp when the object was created.
   */
  created_at?: string | null;
  /**
   * The timestamp when the object was last updated.
   */
  updated_at?: string | null;
  /**
   * The human-friendly ID of the Sandbox
   */
  id?: string;
  /**
   * The type of sandbox.
   */
  type?: SandboxType;
  /**
   * The unique identifier of the organization associated with the sandbox.
   */
  organization_id?: string | null;
  /**
   * The JSON sandbox settings data.
   */
  config?: {
    [key: string]: unknown;
  };
};

export type SandboxConfigCreate = {
  /**
   * The configuration for the sandbox.
   */
  config: LocalSandboxConfig | E2BSandboxConfig;
};

/**
 * Pydantic model for updating SandboxConfig fields.
 */
export type SandboxConfigUpdate = {
  /**
   * The JSON configuration data for the sandbox.
   */
  config?: LocalSandboxConfig | E2BSandboxConfig;
};

export type SandboxEnvironmentVariable = {
  /**
   * The id of the user that made this object.
   */
  created_by_id?: string | null;
  /**
   * The id of the user that made this object.
   */
  last_updated_by_id?: string | null;
  /**
   * The timestamp when the object was created.
   */
  created_at?: string | null;
  /**
   * The timestamp when the object was last updated.
   */
  updated_at?: string | null;
  /**
   * The human-friendly ID of the Sandbox-env
   */
  id?: string;
  /**
   * The name of the environment variable.
   */
  key: string;
  /**
   * The value of the environment variable.
   */
  value: string;
  /**
   * An optional description of the environment variable.
   */
  description?: string | null;
  /**
   * The ID of the organization this environment variable belongs to.
   */
  organization_id?: string | null;
  /**
   * The ID of the sandbox config this environment variable belongs to.
   */
  sandbox_config_id: string;
};

export type SandboxEnvironmentVariableCreate = {
  /**
   * The name of the environment variable.
   */
  key: string;
  /**
   * The value of the environment variable.
   */
  value: string;
  /**
   * An optional description of the environment variable.
   */
  description?: string | null;
};

export type SandboxEnvironmentVariableUpdate = {
  /**
   * The name of the environment variable.
   */
  key?: string | null;
  /**
   * The value of the environment variable.
   */
  value?: string | null;
  /**
   * An optional description of the environment variable.
   */
  description?: string | null;
};

export type SandboxType = 'e2b' | 'local';

/**
 * Representation of a source, which is a collection of files and passages.
 *
 * Parameters:
 * id (str): The ID of the source
 * name (str): The name of the source.
 * embedding_config (EmbeddingConfig): The embedding configuration used by the source.
 * user_id (str): The ID of the user that created the source.
 * metadata (dict): Metadata associated with the source.
 * description (str): The description of the source.
 */
export type Source = {
  /**
   * The human-friendly ID of the Source
   */
  id?: string;
  /**
   * The name of the source.
   */
  name: string;
  /**
   * The description of the source.
   */
  description?: string | null;
  /**
   * The embedding configuration used by the source.
   */
  embedding_config: EmbeddingConfig;
  /**
   * The ID of the organization that created the source.
   */
  organization_id?: string | null;
  /**
   * Metadata associated with the source.
   */
  metadata?: {
    [key: string]: unknown;
  } | null;
  /**
   * The id of the user that made this Tool.
   */
  created_by_id?: string | null;
  /**
   * The id of the user that made this Tool.
   */
  last_updated_by_id?: string | null;
  /**
   * The timestamp when the source was created.
   */
  created_at?: string | null;
  /**
   * The timestamp when the source was last updated.
   */
  updated_at?: string | null;
};

/**
 * Schema for creating a new Source.
 */
export type SourceCreate = {
  /**
   * The name of the source.
   */
  name: string;
  /**
   * The embedding configuration used by the source.
   */
  embedding_config?: EmbeddingConfig | null;
  /**
   * The description of the source.
   */
  description?: string | null;
  /**
   * Metadata associated with the source.
   */
  metadata?: {
    [key: string]: unknown;
  } | null;
};

/**
 * Schema for updating an existing Source.
 */
export type SourceUpdate = {
  /**
   * The name of the source.
   */
  name?: string | null;
  /**
   * The description of the source.
   */
  description?: string | null;
  /**
   * Metadata associated with the source.
   */
  metadata?: {
    [key: string]: unknown;
  } | null;
  /**
   * The embedding configuration used by the source.
   */
  embedding_config?: EmbeddingConfig | null;
};

export type Step = {
  /**
   * The id of the step. Assigned by the database.
   */
  id: string;
  /**
   * The surface that this agent step was initiated from.
   */
  origin?: string | null;
  /**
   * The unique identifier of the organization associated with the step.
   */
  organization_id?: string | null;
  /**
   * The unique identifier of the provider that was configured for this step
   */
  provider_id?: string | null;
  /**
   * The unique identifier of the job that this step belongs to. Only included for async calls.
   */
  job_id?: string | null;
  /**
   * The name of the provider used for this step.
   */
  provider_name?: string | null;
  /**
   * The name of the model used for this step.
   */
  model?: string | null;
  /**
   * The model endpoint url used for this step.
   */
  model_endpoint?: string | null;
  /**
   * The context window limit configured for this step.
   */
  context_window_limit?: number | null;
  /**
   * The number of tokens generated by the agent during this step.
   */
  completion_tokens?: number | null;
  /**
   * The number of tokens in the prompt during this step.
   */
  prompt_tokens?: number | null;
  /**
   * The total number of tokens processed by the agent during this step.
   */
  total_tokens?: number | null;
  /**
   * Metadata for the agent.
   */
  completion_tokens_details?: {
    [key: string]: unknown;
  } | null;
  /**
   * Metadata tags.
   */
  tags?: Array<string>;
  /**
   * The unique identifier of the transaction that processed this step.
   */
  tid?: string | null;
  /**
   * The trace id of the agent step.
   */
  trace_id?: string | null;
  /**
   * The messages generated during this step.
   */
  messages?: Array<Message>;
};

/**
 * A message generated by the system. Never streamed back on a response, only used for cursor pagination.
 *
 * Attributes:
 * content (Union[str, List[MessageContentUnion]]): The message content sent by the user (can be a string or an array of content parts)
 * id (str): The ID of the message
 * date (datetime): The date the message was created in ISO format
 */
export type SystemMessage = {
  id: string;
  date: string;
  message_type?: 'system_message';
  content: string | Array<TextContent>;
};

/**
 * Represents a terminal tool rule configuration where if this tool gets called, it must end the agent loop.
 */
export type TerminalToolRule = {
  /**
   * The name of the tool. Must exist in the database for the user's organization.
   */
  tool_name: string;
  type?: 'exit_loop';
};

export type type13 = 'exit_loop';

export type TextContent = {
  /**
   * The type of the message.
   */
  type?: 'text';
  /**
   * The text content of the message.
   */
  text: string;
};

/**
 * Representation of a tool, which is a function that can be called by the agent.
 *
 * Parameters:
 * id (str): The unique identifier of the tool.
 * name (str): The name of the function.
 * tags (List[str]): Metadata tags.
 * source_code (str): The source code of the function.
 * json_schema (Dict): The JSON schema of the function.
 */
export type Tool = {
  /**
   * The human-friendly ID of the Tool
   */
  id?: string;
  /**
   * The type of the tool.
   */
  tool_type?: ToolType;
  /**
   * The description of the tool.
   */
  description?: string | null;
  /**
   * The type of the source code.
   */
  source_type?: string | null;
  /**
   * The unique identifier of the organization associated with the tool.
   */
  organization_id?: string | null;
  /**
   * The name of the function.
   */
  name?: string | null;
  /**
   * Metadata tags.
   */
  tags?: Array<string>;
  /**
   * The source code of the function.
   */
  source_code?: string | null;
  /**
   * The JSON schema of the function.
   */
  json_schema?: {
    [key: string]: unknown;
  } | null;
  /**
   * The args JSON schema of the function.
   */
  args_json_schema?: {
    [key: string]: unknown;
  } | null;
  /**
   * The maximum number of characters in the response.
   */
  return_char_limit?: number;
  /**
   * The id of the user that made this Tool.
   */
  created_by_id?: string | null;
  /**
   * The id of the user that made this Tool.
   */
  last_updated_by_id?: string | null;
};

export type ToolCall = {
  name: string;
  arguments: string;
  tool_call_id: string;
};

export type ToolCallDelta = {
  name: string | null;
  arguments: string | null;
  tool_call_id: string | null;
};

/**
 * A message representing a request to call a tool (generated by the LLM to trigger tool execution).
 *
 * Attributes:
 * tool_call (Union[ToolCall, ToolCallDelta]): The tool call
 * id (str): The ID of the message
 * date (datetime): The date the message was created in ISO format
 */
export type ToolCallMessage = {
  id: string;
  date: string;
  message_type?: 'tool_call_message';
  tool_call: ToolCall | ToolCallDelta;
};

export type ToolCreate = {
  /**
   * The description of the tool.
   */
  description?: string | null;
  /**
   * Metadata tags.
   */
  tags?: Array<string>;
  /**
   * The source code of the function.
   */
  source_code: string;
  /**
   * The source type of the function.
   */
  source_type?: string;
  /**
   * The JSON schema of the function (auto-generated from source_code if not provided)
   */
  json_schema?: {
    [key: string]: unknown;
  } | null;
  /**
   * The args JSON schema of the function.
   */
  args_json_schema?: {
    [key: string]: unknown;
  } | null;
  /**
   * The maximum number of characters in the response.
   */
  return_char_limit?: number;
};

/**
 * A message representing the return value of a tool call (generated by Letta executing the requested tool).
 *
 * Attributes:
 * tool_return (str): The return value of the tool
 * status (Literal["success", "error"]): The status of the tool call
 * id (str): The ID of the message
 * date (datetime): The date the message was created in ISO format
 * tool_call_id (str): A unique identifier for the tool call that generated this message
 * stdout (Optional[List(str)]): Captured stdout (e.g. prints, logs) from the tool invocation
 * stderr (Optional[List(str)]): Captured stderr from the tool invocation
 */
export type ToolReturnMessage = {
  id: string;
  date: string;
  message_type?: 'tool_return_message';
  tool_return: string;
  status: 'success' | 'error';
  tool_call_id: string;
  stdout?: Array<string> | null;
  stderr?: Array<string> | null;
};

export type status = 'success' | 'error';

export type ToolRunFromSource = {
  /**
   * The source code of the function.
   */
  source_code: string;
  /**
   * The arguments to pass to the tool.
   */
  args: {
    [key: string]: unknown;
  };
  /**
   * The environment variables to pass to the tool.
   */
  env_vars?: {
    [key: string]: string;
  };
  /**
   * The name of the tool to run.
   */
  name?: string | null;
  /**
   * The type of the source code.
   */
  source_type?: string | null;
  /**
   * The args JSON schema of the function.
   */
  args_json_schema?: {
    [key: string]: unknown;
  } | null;
};

export type ToolType =
  | 'custom'
  | 'letta_core'
  | 'letta_memory_core'
  | 'letta_multi_agent_core'
  | 'external_composio'
  | 'external_langchain';

export type ToolUpdate = {
  /**
   * The description of the tool.
   */
  description?: string | null;
  /**
   * Metadata tags.
   */
  tags?: Array<string> | null;
  /**
   * The source code of the function.
   */
  source_code?: string | null;
  /**
   * The type of the source code.
   */
  source_type?: string | null;
  /**
   * The JSON schema of the function (auto-generated from source_code if not provided)
   */
  json_schema?: {
    [key: string]: unknown;
  } | null;
  /**
   * The args JSON schema of the function.
   */
  args_json_schema?: {
    [key: string]: unknown;
  } | null;
  /**
   * The maximum number of characters in the response.
   */
  return_char_limit?: number | null;
};

export type UpdateAgent = {
  /**
   * The name of the agent.
   */
  name?: string | null;
  /**
   * The ids of the tools used by the agent.
   */
  tool_ids?: Array<string> | null;
  /**
   * The ids of the sources used by the agent.
   */
  source_ids?: Array<string> | null;
  /**
   * The ids of the blocks used by the agent.
   */
  block_ids?: Array<string> | null;
  /**
   * The tags associated with the agent.
   */
  tags?: Array<string> | null;
  /**
   * The system prompt used by the agent.
   */
  system?: string | null;
  /**
   * The tool rules governing the agent.
   */
  tool_rules?: Array<
    | ChildToolRule
    | InitToolRule
    | TerminalToolRule
    | ConditionalToolRule
    | ContinueToolRule
  > | null;
  /**
   * The LLM configuration used by the agent.
   */
  llm_config?: LLMConfig | null;
  /**
   * The embedding configuration used by the agent.
   */
  embedding_config?: EmbeddingConfig | null;
  /**
   * The ids of the messages in the agent's in-context memory.
   */
  message_ids?: Array<string> | null;
  /**
   * The description of the agent.
   */
  description?: string | null;
  /**
   * The metadata of the agent.
   */
  metadata?: {
    [key: string]: unknown;
  } | null;
  /**
   * The environment variables for tool execution specific to this agent.
   */
  tool_exec_environment_variables?: {
    [key: string]: string;
  } | null;
  /**
   * The id of the project the agent belongs to.
   */
  project_id?: string | null;
  /**
   * The id of the template the agent belongs to.
   */
  template_id?: string | null;
  /**
   * The base template id of the agent.
   */
  base_template_id?: string | null;
  /**
   * The ids of the identities associated with this agent.
   */
  identity_ids?: Array<string> | null;
  /**
   * If set to True, the agent will not remember previous messages (though the agent will still retain state via core memory blocks and archival/recall memory). Not recommended unless you have an advanced use case.
   */
  message_buffer_autoclear?: boolean | null;
};

export type UsageStatistics = {
  completion_tokens?: number;
  prompt_tokens?: number;
  total_tokens?: number;
};

/**
 * Representation of a user.
 *
 * Parameters:
 * id (str): The unique identifier of the user.
 * name (str): The name of the user.
 * created_at (datetime): The creation date of the user.
 */
export type User = {
  /**
   * The human-friendly ID of the User
   */
  id?: string;
  /**
   * The organization id of the user
   */
  organization_id?: string | null;
  /**
   * The name of the user.
   */
  name: string;
  /**
   * The creation date of the user.
   */
  created_at?: string | null;
  /**
   * The update date of the user.
   */
  updated_at?: string | null;
  /**
   * Whether this user is deleted or not.
   */
  is_deleted?: boolean;
};

export type UserCreate = {
  /**
   * The name of the user.
   */
  name: string;
  /**
   * The organization id of the user.
   */
  organization_id: string;
};

/**
 * A message sent by the user. Never streamed back on a response, only used for cursor pagination.
 *
 * Attributes:
 * content (Union[str, List[MessageContentUnion]]): The message content sent by the user (can be a string or an array of content parts)
 * id (str): The ID of the message
 * date (datetime): The date the message was created in ISO format
 */
export type UserMessage = {
  id: string;
  date: string;
  message_type?: 'user_message';
  content: string | Array<TextContent>;
};

export type UserUpdate = {
  /**
   * The id of the user to update.
   */
  id: string;
  /**
   * The new name of the user.
   */
  name?: string | null;
  /**
   * The new organization id of the user.
   */
  organization_id?: string | null;
};

export type ValidationError = {
  loc: Array<string | number>;
  msg: string;
  type: string;
};

export type openai__types__chat__chat_completion_message_tool_call__Function = {
  arguments: string;
  name: string;
  [key: string]: unknown | string;
};

export type openai__types__chat__chat_completion_message_tool_call_param__Function =
  {
    arguments: string;
    name: string;
  };

export type openai__types__chat__chat_completion_named_tool_choice_param__Function =
  {
    name: string;
  };

export type openai__types__chat__completion_create_params__Function = {
  name: string;
  description?: string;
  parameters?: {
    [key: string]: unknown;
  };
};

export type LettaMessageUnion =
  | SystemMessage
  | UserMessage
  | ReasoningMessage
  | ToolCallMessage
  | ToolReturnMessage
  | AssistantMessage;

export type DeleteToolData = {
  toolId: string;
  userId?: string | null;
};

export type DeleteToolResponse = unknown;

export type RetrieveToolData = {
  toolId: string;
  userId?: string | null;
};

export type RetrieveToolResponse = Tool;

export type ModifyToolData = {
  requestBody: ToolUpdate;
  toolId: string;
  userId?: string | null;
};

export type ModifyToolResponse = Tool;

export type ListToolsData = {
  after?: string | null;
  limit?: number | null;
  name?: string | null;
  userId?: string | null;
};

export type ListToolsResponse = Array<Tool>;

export type CreateToolData = {
  requestBody: ToolCreate;
  userId?: string | null;
};

export type CreateToolResponse = Tool;

export type UpsertToolData = {
  requestBody: ToolCreate;
  userId?: string | null;
};

export type UpsertToolResponse = Tool;

export type AddBaseToolsData = {
  userId?: string | null;
};

export type AddBaseToolsResponse = Array<Tool>;

export type RunToolFromSourceData = {
  requestBody: ToolRunFromSource;
  userId?: string | null;
};

export type RunToolFromSourceResponse = ToolReturnMessage;

export type ListComposioAppsData = {
  userId?: string | null;
};

export type ListComposioAppsResponse = Array<AppModel>;

export type ListComposioActionsByAppData = {
  composioAppName: string;
  userId?: string | null;
};

export type ListComposioActionsByAppResponse = Array<ActionModel>;

export type AddComposioToolData = {
  composioActionName: string;
  userId?: string | null;
};

export type AddComposioToolResponse = Tool;

export type RetrieveSourceData = {
  sourceId: string;
  userId?: string | null;
};

export type RetrieveSourceResponse = Source;

export type ModifySourceData = {
  requestBody: SourceUpdate;
  sourceId: string;
  userId?: string | null;
};

export type ModifySourceResponse = Source;

export type DeleteSourceData = {
  sourceId: string;
  userId?: string | null;
};

export type DeleteSourceResponse = unknown;

export type GetSourceIdByNameData = {
  sourceName: string;
  userId?: string | null;
};

export type GetSourceIdByNameResponse = string;

export type ListSourcesData = {
  userId?: string | null;
};

export type ListSourcesResponse = Array<Source>;

export type CreateSourceData = {
  requestBody: SourceCreate;
  userId?: string | null;
};

export type CreateSourceResponse = Source;

export type UploadFileToSourceData = {
  formData: Body_upload_file_to_source;
  sourceId: string;
  userId?: string | null;
};

export type UploadFileToSourceResponse = Job;

export type ListSourcePassagesData = {
  sourceId: string;
  userId?: string | null;
};

export type ListSourcePassagesResponse = Array<Passage>;

export type ListSourceFilesData = {
  /**
   * Pagination cursor to fetch the next set of results
   */
  after?: string | null;
  /**
   * Number of files to return
   */
  limit?: number;
  sourceId: string;
  userId?: string | null;
};

export type ListSourceFilesResponse = Array<FileMetadata>;

export type DeleteFileFromSourceData = {
  fileId: string;
  sourceId: string;
  userId?: string | null;
};

export type DeleteFileFromSourceResponse = void;

export type ListAgentsData = {
  /**
   * Cursor for pagination
   */
  after?: string | null;
  /**
   * Search agents by base template id
   */
  baseTemplateId?: string | null;
  /**
   * Cursor for pagination
   */
  before?: string | null;
  /**
   * Search agents by identifier id
   */
  identifierId?: string | null;
  /**
   * Search agents by identifier keys
   */
  identifierKeys?: Array<string> | null;
  /**
   * Limit for pagination
   */
  limit?: number | null;
  /**
   * If True, only returns agents that match ALL given tags. Otherwise, return agents that have ANY of the passed in tags.
   */
  matchAllTags?: boolean;
  /**
   * Name of the agent
   */
  name?: string | null;
  /**
   * Search agents by project id
   */
  projectId?: string | null;
  /**
   * Search agents by name
   */
  queryText?: string | null;
  /**
   * List of tags to filter agents by
   */
  tags?: Array<string> | null;
  /**
   * Search agents by template id
   */
  templateId?: string | null;
  userId?: string | null;
};

export type ListAgentsResponse = Array<AgentState>;

export type CreateAgentData = {
  requestBody: CreateAgentRequest;
  userId?: string | null;
  xProject?: string | null;
};

export type CreateAgentResponse = AgentState;

export type DownloadAgentSerializedData = {
  agentId: string;
  userId?: string | null;
};

export type DownloadAgentSerializedResponse = unknown;

export type UploadAgentSerializedData = {
  formData: Body_upload_agent_serialized;
  /**
   * Whether to mark the uploaded agent as a copy
   */
  markAsCopy?: boolean;
  userId?: string | null;
};

export type UploadAgentSerializedResponse = AgentState;

export type RetrieveAgentContextWindowData = {
  agentId: string;
  userId?: string | null;
};

export type RetrieveAgentContextWindowResponse = ContextWindowOverview;

export type ModifyAgentData = {
  agentId: string;
  requestBody: UpdateAgent;
  userId?: string | null;
};

export type ModifyAgentResponse = AgentState;

export type RetrieveAgentData = {
  agentId: string;
  userId?: string | null;
};

export type RetrieveAgentResponse = AgentState;

export type DeleteAgentData = {
  agentId: string;
  userId?: string | null;
};

export type DeleteAgentResponse = unknown;

export type ListAgentToolsData = {
  agentId: string;
  userId?: string | null;
};

export type ListAgentToolsResponse = Array<Tool>;

export type AttachToolData = {
  agentId: string;
  toolId: string;
  userId?: string | null;
};

export type AttachToolResponse = AgentState;

export type DetachToolData = {
  agentId: string;
  toolId: string;
  userId?: string | null;
};

export type DetachToolResponse = AgentState;

export type AttachSourceToAgentData = {
  agentId: string;
  sourceId: string;
  userId?: string | null;
};

export type AttachSourceToAgentResponse = AgentState;

export type DetachSourceFromAgentData = {
  agentId: string;
  sourceId: string;
  userId?: string | null;
};

export type DetachSourceFromAgentResponse = AgentState;

export type ListAgentSourcesData = {
  agentId: string;
  userId?: string | null;
};

export type ListAgentSourcesResponse = Array<Source>;

export type RetrieveAgentMemoryData = {
  agentId: string;
  userId?: string | null;
};

export type RetrieveAgentMemoryResponse = Memory;

export type RetrieveCoreMemoryBlockData = {
  agentId: string;
  blockLabel: string;
  userId?: string | null;
};

export type RetrieveCoreMemoryBlockResponse = Block;

export type ModifyCoreMemoryBlockData = {
  agentId: string;
  blockLabel: string;
  requestBody: BlockUpdate;
  userId?: string | null;
};

export type ModifyCoreMemoryBlockResponse = Block;

export type ListCoreMemoryBlocksData = {
  agentId: string;
  userId?: string | null;
};

export type ListCoreMemoryBlocksResponse = Array<Block>;

export type AttachCoreMemoryBlockData = {
  agentId: string;
  blockId: string;
  userId?: string | null;
};

export type AttachCoreMemoryBlockResponse = AgentState;

export type DetachCoreMemoryBlockData = {
  agentId: string;
  blockId: string;
  userId?: string | null;
};

export type DetachCoreMemoryBlockResponse = AgentState;

export type ListPassagesData = {
  /**
   * Unique ID of the memory to start the query range at.
   */
  after?: number | null;
  agentId: string;
  /**
   * Unique ID of the memory to end the query range at.
   */
  before?: number | null;
  /**
   * How many results to include in the response.
   */
  limit?: number | null;
  userId?: string | null;
};

export type ListPassagesResponse = Array<Passage>;

export type CreatePassageData = {
  agentId: string;
  requestBody: CreateArchivalMemory;
  userId?: string | null;
};

export type CreatePassageResponse = Array<Passage>;

export type ModifyPassageData = {
  agentId: string;
  memoryId: string;
  requestBody: PassageUpdate;
  userId?: string | null;
};

export type ModifyPassageResponse = Array<Passage>;

export type DeletePassageData = {
  agentId: string;
  memoryId: string;
  userId?: string | null;
};

export type DeletePassageResponse = unknown;

export type ListMessagesData = {
  /**
   * Message after which to retrieve the returned messages.
   */
  after?: string | null;
  agentId: string;
  /**
   * The name of the message argument.
   */
  assistantMessageToolKwarg?: string;
  /**
   * The name of the designated message tool.
   */
  assistantMessageToolName?: string;
  /**
   * Message before which to retrieve the returned messages.
   */
  before?: string | null;
  /**
   * Maximum number of messages to retrieve.
   */
  limit?: number;
  /**
   * Whether to use assistant messages
   */
  useAssistantMessage?: boolean;
  userId?: string | null;
};

export type ListMessagesResponse = Array<LettaMessageUnion>;

export type SendMessageData = {
  agentId: string;
  requestBody: LettaRequest;
  userId?: string | null;
};

export type SendMessageResponse = LettaResponse;

export type ModifyMessageData = {
  agentId: string;
  messageId: string;
  requestBody: MessageUpdate;
  userId?: string | null;
};

export type ModifyMessageResponse = Message;

export type CreateAgentMessageStreamData = {
  agentId: string;
  requestBody: LettaStreamingRequest;
  userId?: string | null;
};

export type CreateAgentMessageStreamResponse = unknown;

export type CreateAgentMessageAsyncData = {
  agentId: string;
  requestBody: LettaRequest;
  userId?: string | null;
};

export type CreateAgentMessageAsyncResponse = Run;

export type ResetMessagesData = {
  /**
   * If true, adds the default initial messages after resetting.
   */
  addDefaultInitialMessages?: boolean;
  agentId: string;
  userId?: string | null;
};

export type ResetMessagesResponse = AgentState;

export type ListIdentitiesData = {
  after?: string | null;
  before?: string | null;
  identifierKey?: string | null;
  identityType?: IdentityType | null;
  limit?: number | null;
  name?: string | null;
  projectId?: string | null;
  userId?: string | null;
};

export type ListIdentitiesResponse = Array<Identity>;

export type CreateIdentityData = {
  requestBody: IdentityCreate;
  userId?: string | null;
  xProject?: string | null;
};

export type CreateIdentityResponse = Identity;

export type UpsertIdentityData = {
  requestBody: IdentityCreate;
  userId?: string | null;
  xProject?: string | null;
};

export type UpsertIdentityResponse = Identity;

export type RetrieveIdentityData = {
  identityId: string;
  userId?: string | null;
};

export type RetrieveIdentityResponse = Identity;

export type UpdateIdentityData = {
  identityId: string;
  requestBody: IdentityUpdate;
  userId?: string | null;
};

export type UpdateIdentityResponse = Identity;

export type DeleteIdentityData = {
  identityId: string;
  userId?: string | null;
};

export type DeleteIdentityResponse = unknown;

export type ListModelsResponse = Array<LLMConfig>;

export type ListEmbeddingModelsResponse = Array<EmbeddingConfig>;

export type ListBlocksData = {
  /**
   * Labels to include (e.g. human, persona)
   */
  label?: string | null;
  /**
   * Name of the block
   */
  name?: string | null;
  /**
   * Whether to include only templates
   */
  templatesOnly?: boolean;
  userId?: string | null;
};

export type ListBlocksResponse = Array<Block>;

export type CreateBlockData = {
  requestBody: CreateBlock;
  userId?: string | null;
};

export type CreateBlockResponse = Block;

export type ModifyBlockData = {
  blockId: string;
  requestBody: BlockUpdate;
  userId?: string | null;
};

export type ModifyBlockResponse = Block;

export type DeleteBlockData = {
  blockId: string;
  userId?: string | null;
};

export type DeleteBlockResponse = Block;

export type RetrieveBlockData = {
  blockId: string;
  userId?: string | null;
};

export type RetrieveBlockResponse = Block;

export type ListAgentsForBlockData = {
  blockId: string;
  userId?: string | null;
};

export type ListAgentsForBlockResponse = Array<AgentState>;

export type ListJobsData = {
  /**
   * Only list jobs associated with the source.
   */
  sourceId?: string | null;
  userId?: string | null;
};

export type ListJobsResponse = Array<Job>;

export type ListActiveJobsData = {
  userId?: string | null;
};

export type ListActiveJobsResponse = Array<Job>;

export type RetrieveJobData = {
  jobId: string;
  userId?: string | null;
};

export type RetrieveJobResponse = Job;

export type DeleteJobData = {
  jobId: string;
  userId?: string | null;
};

export type DeleteJobResponse = Job;

export type HealthCheckResponse = Health;

export type CreateSandboxConfigV1SandboxConfigPostData = {
  requestBody: SandboxConfigCreate;
  userId?: string | null;
};

export type CreateSandboxConfigV1SandboxConfigPostResponse = SandboxConfig;

export type ListSandboxConfigsV1SandboxConfigGetData = {
  /**
   * Pagination cursor to fetch the next set of results
   */
  after?: string | null;
  /**
   * Number of results to return
   */
  limit?: number;
  /**
   * Filter for this specific sandbox type
   */
  sandboxType?: SandboxType | null;
  userId?: string | null;
};

export type ListSandboxConfigsV1SandboxConfigGetResponse = Array<SandboxConfig>;

export type CreateDefaultE2bSandboxConfigV1SandboxConfigE2bDefaultPostData = {
  userId?: string | null;
};

export type CreateDefaultE2bSandboxConfigV1SandboxConfigE2bDefaultPostResponse =
  SandboxConfig;

export type CreateDefaultLocalSandboxConfigV1SandboxConfigLocalDefaultPostData =
  {
    userId?: string | null;
  };

export type CreateDefaultLocalSandboxConfigV1SandboxConfigLocalDefaultPostResponse =
  SandboxConfig;

export type CreateCustomLocalSandboxConfigV1SandboxConfigLocalPostData = {
  requestBody: LocalSandboxConfig;
  userId?: string | null;
};

export type CreateCustomLocalSandboxConfigV1SandboxConfigLocalPostResponse =
  SandboxConfig;

export type UpdateSandboxConfigV1SandboxConfigSandboxConfigIdPatchData = {
  requestBody: SandboxConfigUpdate;
  sandboxConfigId: string;
  userId?: string | null;
};

export type UpdateSandboxConfigV1SandboxConfigSandboxConfigIdPatchResponse =
  SandboxConfig;

export type DeleteSandboxConfigV1SandboxConfigSandboxConfigIdDeleteData = {
  sandboxConfigId: string;
  userId?: string | null;
};

export type DeleteSandboxConfigV1SandboxConfigSandboxConfigIdDeleteResponse =
  void;

export type ForceRecreateLocalSandboxVenvV1SandboxConfigLocalRecreateVenvPostData =
  {
    userId?: string | null;
  };

export type ForceRecreateLocalSandboxVenvV1SandboxConfigLocalRecreateVenvPostResponse =
  SandboxConfig;

export type CreateSandboxEnvVarV1SandboxConfigSandboxConfigIdEnvironmentVariablePostData =
  {
    requestBody: SandboxEnvironmentVariableCreate;
    sandboxConfigId: string;
    userId?: string | null;
  };

export type CreateSandboxEnvVarV1SandboxConfigSandboxConfigIdEnvironmentVariablePostResponse =
  SandboxEnvironmentVariable;

export type ListSandboxEnvVarsV1SandboxConfigSandboxConfigIdEnvironmentVariableGetData =
  {
    /**
     * Pagination cursor to fetch the next set of results
     */
    after?: string | null;
    /**
     * Number of results to return
     */
    limit?: number;
    sandboxConfigId: string;
    userId?: string | null;
  };

export type ListSandboxEnvVarsV1SandboxConfigSandboxConfigIdEnvironmentVariableGetResponse =
  Array<SandboxEnvironmentVariable>;

export type UpdateSandboxEnvVarV1SandboxConfigEnvironmentVariableEnvVarIdPatchData =
  {
    envVarId: string;
    requestBody: SandboxEnvironmentVariableUpdate;
    userId?: string | null;
  };

export type UpdateSandboxEnvVarV1SandboxConfigEnvironmentVariableEnvVarIdPatchResponse =
  SandboxEnvironmentVariable;

export type DeleteSandboxEnvVarV1SandboxConfigEnvironmentVariableEnvVarIdDeleteData =
  {
    envVarId: string;
    userId?: string | null;
  };

export type DeleteSandboxEnvVarV1SandboxConfigEnvironmentVariableEnvVarIdDeleteResponse =
  void;

export type ListProvidersData = {
  after?: string | null;
  limit?: number | null;
  userId?: string | null;
};

export type ListProvidersResponse = Array<Provider>;

export type CreateProviderData = {
  requestBody: ProviderCreate;
  userId?: string | null;
};

export type CreateProviderResponse = Provider;

export type ModifyProviderData = {
  requestBody: ProviderUpdate;
  userId?: string | null;
};

export type ModifyProviderResponse = Provider;

export type DeleteProviderData = {
  /**
   * The provider_id key to be deleted.
   */
  providerId: string;
  userId?: string | null;
};

export type DeleteProviderResponse = unknown;

export type ListRunsData = {
  userId?: string | null;
};

export type ListRunsResponse = Array<Run>;

export type ListActiveRunsData = {
  userId?: string | null;
};

export type ListActiveRunsResponse = Array<Run>;

export type RetrieveRunData = {
  runId: string;
  userId?: string | null;
};

export type RetrieveRunResponse = Run;

export type DeleteRunData = {
  runId: string;
  userId?: string | null;
};

export type DeleteRunResponse = Run;

export type ListRunMessagesData = {
  /**
   * Cursor for pagination
   */
  after?: string | null;
  /**
   * Cursor for pagination
   */
  before?: string | null;
  /**
   * Maximum number of messages to return
   */
  limit?: number | null;
  /**
   * Sort order by the created_at timestamp of the objects. asc for ascending order and desc for descending order.
   */
  order?: string;
  /**
   * Filter by role
   */
  role?: MessageRole | null;
  runId: string;
  userId?: string | null;
};

export type ListRunMessagesResponse = Array<LettaMessageUnion>;

export type RetrieveRunUsageData = {
  runId: string;
  userId?: string | null;
};

export type RetrieveRunUsageResponse = UsageStatistics;

export type ListRunStepsData = {
  /**
   * Cursor for pagination
   */
  after?: string | null;
  /**
   * Cursor for pagination
   */
  before?: string | null;
  /**
   * Maximum number of messages to return
   */
  limit?: number | null;
  /**
   * Sort order by the created_at timestamp of the objects. asc for ascending order and desc for descending order.
   */
  order?: string;
  runId: string;
  userId?: string | null;
};

export type ListRunStepsResponse = Array<Step>;

export type ListStepsData = {
  /**
   * Return steps after this step ID
   */
  after?: string | null;
  /**
   * Return steps before this step ID
   */
  before?: string | null;
  /**
   * Return steps before this ISO datetime (e.g. "2025-01-29T15:01:19-08:00")
   */
  endDate?: string | null;
  /**
   * Maximum number of steps to return
   */
  limit?: number | null;
  /**
   * Filter by the name of the model used for the step
   */
  model?: string | null;
  /**
   * Sort order (asc or desc)
   */
  order?: string | null;
  /**
   * Return steps after this ISO datetime (e.g. "2025-01-29T15:01:19-08:00")
   */
  startDate?: string | null;
  userId?: string | null;
};

export type ListStepsResponse = Array<Step>;

export type RetrieveStepData = {
  stepId: string;
  userId?: string | null;
};

export type RetrieveStepResponse = Step;

export type UpdateStepTransactionIdData = {
  stepId: string;
  transactionId: string;
  userId?: string | null;
};

export type UpdateStepTransactionIdResponse = Step;

export type ListTagsData = {
  after?: string | null;
  limit?: number | null;
  queryText?: string | null;
  userId?: string | null;
};

export type ListTagsResponse = Array<string>;

export type ListUsersData = {
  after?: string | null;
  limit?: number | null;
};

export type ListUsersResponse = Array<User>;

export type CreateUserData = {
  requestBody: UserCreate;
};

export type CreateUserResponse = User;

export type UpdateUserData = {
  requestBody: UserUpdate;
};

export type UpdateUserResponse = User;

export type DeleteUserData = {
  /**
   * The user_id key to be deleted.
   */
  userId: string;
};

export type DeleteUserResponse = User;

export type ListOrgsData = {
  after?: string | null;
  limit?: number | null;
};

export type ListOrgsResponse = Array<Organization>;

export type CreateOrganizationData = {
  requestBody: OrganizationCreate;
};

export type CreateOrganizationResponse = Organization;

export type DeleteOrganizationByIdData = {
  /**
   * The org_id key to be deleted.
   */
  orgId: string;
};

export type DeleteOrganizationByIdResponse = Organization;

export type CreateVoiceChatCompletionsData = {
  requestBody:
    | CompletionCreateParamsNonStreaming
    | CompletionCreateParamsStreaming;
  userId?: string | null;
};

export type CreateVoiceChatCompletionsResponse = unknown;

export type AuthenticateUserV1AuthPostData = {
  requestBody: AuthRequest;
};

export type AuthenticateUserV1AuthPostResponse = AuthResponse;

export type $OpenApiTs = {
  '/v1/tools/{tool_id}': {
    delete: {
      req: DeleteToolData;
      res: {
        /**
         * Successful Response
         */
        200: unknown;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
    get: {
      req: RetrieveToolData;
      res: {
        /**
         * Successful Response
         */
        200: Tool;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
    patch: {
      req: ModifyToolData;
      res: {
        /**
         * Successful Response
         */
        200: Tool;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/tools/': {
    get: {
      req: ListToolsData;
      res: {
        /**
         * Successful Response
         */
        200: Array<Tool>;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
    post: {
      req: CreateToolData;
      res: {
        /**
         * Successful Response
         */
        200: Tool;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
    put: {
      req: UpsertToolData;
      res: {
        /**
         * Successful Response
         */
        200: Tool;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/tools/add-base-tools': {
    post: {
      req: AddBaseToolsData;
      res: {
        /**
         * Successful Response
         */
        200: Array<Tool>;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/tools/run': {
    post: {
      req: RunToolFromSourceData;
      res: {
        /**
         * Successful Response
         */
        200: ToolReturnMessage;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/tools/composio/apps': {
    get: {
      req: ListComposioAppsData;
      res: {
        /**
         * Successful Response
         */
        200: Array<AppModel>;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/tools/composio/apps/{composio_app_name}/actions': {
    get: {
      req: ListComposioActionsByAppData;
      res: {
        /**
         * Successful Response
         */
        200: Array<ActionModel>;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/tools/composio/{composio_action_name}': {
    post: {
      req: AddComposioToolData;
      res: {
        /**
         * Successful Response
         */
        200: Tool;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/sources/{source_id}': {
    get: {
      req: RetrieveSourceData;
      res: {
        /**
         * Successful Response
         */
        200: Source;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
    patch: {
      req: ModifySourceData;
      res: {
        /**
         * Successful Response
         */
        200: Source;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
    delete: {
      req: DeleteSourceData;
      res: {
        /**
         * Successful Response
         */
        200: unknown;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/sources/name/{source_name}': {
    get: {
      req: GetSourceIdByNameData;
      res: {
        /**
         * Successful Response
         */
        200: string;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/sources/': {
    get: {
      req: ListSourcesData;
      res: {
        /**
         * Successful Response
         */
        200: Array<Source>;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
    post: {
      req: CreateSourceData;
      res: {
        /**
         * Successful Response
         */
        200: Source;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/sources/{source_id}/upload': {
    post: {
      req: UploadFileToSourceData;
      res: {
        /**
         * Successful Response
         */
        200: Job;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/sources/{source_id}/passages': {
    get: {
      req: ListSourcePassagesData;
      res: {
        /**
         * Successful Response
         */
        200: Array<Passage>;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/sources/{source_id}/files': {
    get: {
      req: ListSourceFilesData;
      res: {
        /**
         * Successful Response
         */
        200: Array<FileMetadata>;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/sources/{source_id}/{file_id}': {
    delete: {
      req: DeleteFileFromSourceData;
      res: {
        /**
         * Successful Response
         */
        204: void;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/agents/': {
    get: {
      req: ListAgentsData;
      res: {
        /**
         * Successful Response
         */
        200: Array<AgentState>;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
    post: {
      req: CreateAgentData;
      res: {
        /**
         * Successful Response
         */
        200: AgentState;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/agents/{agent_id}/download': {
    get: {
      req: DownloadAgentSerializedData;
      res: {
        /**
         * Successful Response
         */
        200: unknown;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/agents/upload': {
    post: {
      req: UploadAgentSerializedData;
      res: {
        /**
         * Successful Response
         */
        200: AgentState;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/agents/{agent_id}/context': {
    get: {
      req: RetrieveAgentContextWindowData;
      res: {
        /**
         * Successful Response
         */
        200: ContextWindowOverview;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/agents/{agent_id}': {
    patch: {
      req: ModifyAgentData;
      res: {
        /**
         * Successful Response
         */
        200: AgentState;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
    get: {
      req: RetrieveAgentData;
      res: {
        /**
         * Successful Response
         */
        200: AgentState;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
    delete: {
      req: DeleteAgentData;
      res: {
        /**
         * Successful Response
         */
        200: unknown;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/agents/{agent_id}/tools': {
    get: {
      req: ListAgentToolsData;
      res: {
        /**
         * Successful Response
         */
        200: Array<Tool>;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/agents/{agent_id}/tools/attach/{tool_id}': {
    patch: {
      req: AttachToolData;
      res: {
        /**
         * Successful Response
         */
        200: AgentState;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/agents/{agent_id}/tools/detach/{tool_id}': {
    patch: {
      req: DetachToolData;
      res: {
        /**
         * Successful Response
         */
        200: AgentState;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/agents/{agent_id}/sources/attach/{source_id}': {
    patch: {
      req: AttachSourceToAgentData;
      res: {
        /**
         * Successful Response
         */
        200: AgentState;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/agents/{agent_id}/sources/detach/{source_id}': {
    patch: {
      req: DetachSourceFromAgentData;
      res: {
        /**
         * Successful Response
         */
        200: AgentState;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/agents/{agent_id}/sources': {
    get: {
      req: ListAgentSourcesData;
      res: {
        /**
         * Successful Response
         */
        200: Array<Source>;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/agents/{agent_id}/core-memory': {
    get: {
      req: RetrieveAgentMemoryData;
      res: {
        /**
         * Successful Response
         */
        200: Memory;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/agents/{agent_id}/core-memory/blocks/{block_label}': {
    get: {
      req: RetrieveCoreMemoryBlockData;
      res: {
        /**
         * Successful Response
         */
        200: Block;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
    patch: {
      req: ModifyCoreMemoryBlockData;
      res: {
        /**
         * Successful Response
         */
        200: Block;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/agents/{agent_id}/core-memory/blocks': {
    get: {
      req: ListCoreMemoryBlocksData;
      res: {
        /**
         * Successful Response
         */
        200: Array<Block>;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/agents/{agent_id}/core-memory/blocks/attach/{block_id}': {
    patch: {
      req: AttachCoreMemoryBlockData;
      res: {
        /**
         * Successful Response
         */
        200: AgentState;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/agents/{agent_id}/core-memory/blocks/detach/{block_id}': {
    patch: {
      req: DetachCoreMemoryBlockData;
      res: {
        /**
         * Successful Response
         */
        200: AgentState;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/agents/{agent_id}/archival-memory': {
    get: {
      req: ListPassagesData;
      res: {
        /**
         * Successful Response
         */
        200: Array<Passage>;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
    post: {
      req: CreatePassageData;
      res: {
        /**
         * Successful Response
         */
        200: Array<Passage>;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/agents/{agent_id}/archival-memory/{memory_id}': {
    patch: {
      req: ModifyPassageData;
      res: {
        /**
         * Successful Response
         */
        200: Array<Passage>;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
    delete: {
      req: DeletePassageData;
      res: {
        /**
         * Successful Response
         */
        200: unknown;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/agents/{agent_id}/messages': {
    get: {
      req: ListMessagesData;
      res: {
        /**
         * Successful Response
         */
        200: Array<LettaMessageUnion>;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
    post: {
      req: SendMessageData;
      res: {
        /**
         * Successful Response
         */
        200: LettaResponse;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/agents/{agent_id}/messages/{message_id}': {
    patch: {
      req: ModifyMessageData;
      res: {
        /**
         * Successful Response
         */
        200: Message;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/agents/{agent_id}/messages/stream': {
    post: {
      req: CreateAgentMessageStreamData;
      res: {
        /**
         * Successful response
         */
        200: unknown;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/agents/{agent_id}/messages/async': {
    post: {
      req: CreateAgentMessageAsyncData;
      res: {
        /**
         * Successful Response
         */
        200: Run;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/agents/{agent_id}/reset-messages': {
    patch: {
      req: ResetMessagesData;
      res: {
        /**
         * Successful Response
         */
        200: AgentState;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/identities/': {
    get: {
      req: ListIdentitiesData;
      res: {
        /**
         * Successful Response
         */
        200: Array<Identity>;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
    post: {
      req: CreateIdentityData;
      res: {
        /**
         * Successful Response
         */
        200: Identity;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
    put: {
      req: UpsertIdentityData;
      res: {
        /**
         * Successful Response
         */
        200: Identity;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/identities/{identity_id}': {
    get: {
      req: RetrieveIdentityData;
      res: {
        /**
         * Successful Response
         */
        200: Identity;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
    patch: {
      req: UpdateIdentityData;
      res: {
        /**
         * Successful Response
         */
        200: Identity;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
    delete: {
      req: DeleteIdentityData;
      res: {
        /**
         * Successful Response
         */
        200: unknown;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/models/': {
    get: {
      res: {
        /**
         * Successful Response
         */
        200: Array<LLMConfig>;
      };
    };
  };
  '/v1/models/embedding': {
    get: {
      res: {
        /**
         * Successful Response
         */
        200: Array<EmbeddingConfig>;
      };
    };
  };
  '/v1/blocks/': {
    get: {
      req: ListBlocksData;
      res: {
        /**
         * Successful Response
         */
        200: Array<Block>;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
    post: {
      req: CreateBlockData;
      res: {
        /**
         * Successful Response
         */
        200: Block;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/blocks/{block_id}': {
    patch: {
      req: ModifyBlockData;
      res: {
        /**
         * Successful Response
         */
        200: Block;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
    delete: {
      req: DeleteBlockData;
      res: {
        /**
         * Successful Response
         */
        200: Block;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
    get: {
      req: RetrieveBlockData;
      res: {
        /**
         * Successful Response
         */
        200: Block;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/blocks/{block_id}/agents': {
    get: {
      req: ListAgentsForBlockData;
      res: {
        /**
         * Successful Response
         */
        200: Array<AgentState>;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/jobs/': {
    get: {
      req: ListJobsData;
      res: {
        /**
         * Successful Response
         */
        200: Array<Job>;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/jobs/active': {
    get: {
      req: ListActiveJobsData;
      res: {
        /**
         * Successful Response
         */
        200: Array<Job>;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/jobs/{job_id}': {
    get: {
      req: RetrieveJobData;
      res: {
        /**
         * Successful Response
         */
        200: Job;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
    delete: {
      req: DeleteJobData;
      res: {
        /**
         * Successful Response
         */
        200: Job;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/health/': {
    get: {
      res: {
        /**
         * Successful Response
         */
        200: Health;
      };
    };
  };
  '/v1/sandbox-config/': {
    post: {
      req: CreateSandboxConfigV1SandboxConfigPostData;
      res: {
        /**
         * Successful Response
         */
        200: SandboxConfig;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
    get: {
      req: ListSandboxConfigsV1SandboxConfigGetData;
      res: {
        /**
         * Successful Response
         */
        200: Array<SandboxConfig>;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/sandbox-config/e2b/default': {
    post: {
      req: CreateDefaultE2bSandboxConfigV1SandboxConfigE2bDefaultPostData;
      res: {
        /**
         * Successful Response
         */
        200: SandboxConfig;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/sandbox-config/local/default': {
    post: {
      req: CreateDefaultLocalSandboxConfigV1SandboxConfigLocalDefaultPostData;
      res: {
        /**
         * Successful Response
         */
        200: SandboxConfig;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/sandbox-config/local': {
    post: {
      req: CreateCustomLocalSandboxConfigV1SandboxConfigLocalPostData;
      res: {
        /**
         * Successful Response
         */
        200: SandboxConfig;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/sandbox-config/{sandbox_config_id}': {
    patch: {
      req: UpdateSandboxConfigV1SandboxConfigSandboxConfigIdPatchData;
      res: {
        /**
         * Successful Response
         */
        200: SandboxConfig;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
    delete: {
      req: DeleteSandboxConfigV1SandboxConfigSandboxConfigIdDeleteData;
      res: {
        /**
         * Successful Response
         */
        204: void;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/sandbox-config/local/recreate-venv': {
    post: {
      req: ForceRecreateLocalSandboxVenvV1SandboxConfigLocalRecreateVenvPostData;
      res: {
        /**
         * Successful Response
         */
        200: SandboxConfig;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/sandbox-config/{sandbox_config_id}/environment-variable': {
    post: {
      req: CreateSandboxEnvVarV1SandboxConfigSandboxConfigIdEnvironmentVariablePostData;
      res: {
        /**
         * Successful Response
         */
        200: SandboxEnvironmentVariable;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
    get: {
      req: ListSandboxEnvVarsV1SandboxConfigSandboxConfigIdEnvironmentVariableGetData;
      res: {
        /**
         * Successful Response
         */
        200: Array<SandboxEnvironmentVariable>;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/sandbox-config/environment-variable/{env_var_id}': {
    patch: {
      req: UpdateSandboxEnvVarV1SandboxConfigEnvironmentVariableEnvVarIdPatchData;
      res: {
        /**
         * Successful Response
         */
        200: SandboxEnvironmentVariable;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
    delete: {
      req: DeleteSandboxEnvVarV1SandboxConfigEnvironmentVariableEnvVarIdDeleteData;
      res: {
        /**
         * Successful Response
         */
        204: void;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/providers/': {
    get: {
      req: ListProvidersData;
      res: {
        /**
         * Successful Response
         */
        200: Array<Provider>;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
    post: {
      req: CreateProviderData;
      res: {
        /**
         * Successful Response
         */
        200: Provider;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
    patch: {
      req: ModifyProviderData;
      res: {
        /**
         * Successful Response
         */
        200: Provider;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
    delete: {
      req: DeleteProviderData;
      res: {
        /**
         * Successful Response
         */
        200: unknown;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/runs/': {
    get: {
      req: ListRunsData;
      res: {
        /**
         * Successful Response
         */
        200: Array<Run>;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/runs/active': {
    get: {
      req: ListActiveRunsData;
      res: {
        /**
         * Successful Response
         */
        200: Array<Run>;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/runs/{run_id}': {
    get: {
      req: RetrieveRunData;
      res: {
        /**
         * Successful Response
         */
        200: Run;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
    delete: {
      req: DeleteRunData;
      res: {
        /**
         * Successful Response
         */
        200: Run;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/runs/{run_id}/messages': {
    get: {
      req: ListRunMessagesData;
      res: {
        /**
         * Successful Response
         */
        200: Array<LettaMessageUnion>;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/runs/{run_id}/usage': {
    get: {
      req: RetrieveRunUsageData;
      res: {
        /**
         * Successful Response
         */
        200: UsageStatistics;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/runs/{run_id}/steps': {
    get: {
      req: ListRunStepsData;
      res: {
        /**
         * Successful Response
         */
        200: Array<Step>;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/steps': {
    get: {
      req: ListStepsData;
      res: {
        /**
         * Successful Response
         */
        200: Array<Step>;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/steps/{step_id}': {
    get: {
      req: RetrieveStepData;
      res: {
        /**
         * Successful Response
         */
        200: Step;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/steps/{step_id}/transaction/{transaction_id}': {
    patch: {
      req: UpdateStepTransactionIdData;
      res: {
        /**
         * Successful Response
         */
        200: Step;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/tags/': {
    get: {
      req: ListTagsData;
      res: {
        /**
         * Successful Response
         */
        200: Array<string>;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/admin/users/': {
    get: {
      req: ListUsersData;
      res: {
        /**
         * Successful Response
         */
        200: Array<User>;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
    post: {
      req: CreateUserData;
      res: {
        /**
         * Successful Response
         */
        200: User;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
    put: {
      req: UpdateUserData;
      res: {
        /**
         * Successful Response
         */
        200: User;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
    delete: {
      req: DeleteUserData;
      res: {
        /**
         * Successful Response
         */
        200: User;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/admin/orgs/': {
    get: {
      req: ListOrgsData;
      res: {
        /**
         * Successful Response
         */
        200: Array<Organization>;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
    post: {
      req: CreateOrganizationData;
      res: {
        /**
         * Successful Response
         */
        200: Organization;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
    delete: {
      req: DeleteOrganizationByIdData;
      res: {
        /**
         * Successful Response
         */
        200: Organization;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/voice/chat/completions': {
    post: {
      req: CreateVoiceChatCompletionsData;
      res: {
        /**
         * Successful response
         */
        200: unknown;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/auth': {
    post: {
      req: AuthenticateUserV1AuthPostData;
      res: {
        /**
         * Successful Response
         */
        200: AuthResponse;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
};
