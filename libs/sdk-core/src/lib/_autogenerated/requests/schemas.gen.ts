// This file is auto-generated by @hey-api/openapi-ts

export const $AgentEnvironmentVariable = {
  properties: {
    created_by_id: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Created By Id',
      description: 'The id of the user that made this object.',
    },
    last_updated_by_id: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Last Updated By Id',
      description: 'The id of the user that made this object.',
    },
    created_at: {
      anyOf: [
        {
          type: 'string',
          format: 'date-time',
        },
        {
          type: 'null',
        },
      ],
      title: 'Created At',
      description: 'The timestamp when the object was created.',
    },
    updated_at: {
      anyOf: [
        {
          type: 'string',
          format: 'date-time',
        },
        {
          type: 'null',
        },
      ],
      title: 'Updated At',
      description: 'The timestamp when the object was last updated.',
    },
    id: {
      type: 'string',
      pattern: '^agent-env-[a-fA-F0-9]{8}',
      title: 'Id',
      description: 'The human-friendly ID of the Agent-env',
      examples: ['agent-env-123e4567-e89b-12d3-a456-426614174000'],
    },
    key: {
      type: 'string',
      title: 'Key',
      description: 'The name of the environment variable.',
    },
    value: {
      type: 'string',
      title: 'Value',
      description: 'The value of the environment variable.',
    },
    description: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Description',
      description: 'An optional description of the environment variable.',
    },
    organization_id: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Organization Id',
      description:
        'The ID of the organization this environment variable belongs to.',
    },
    agent_id: {
      type: 'string',
      title: 'Agent Id',
      description: 'The ID of the agent this environment variable belongs to.',
    },
  },
  additionalProperties: false,
  type: 'object',
  required: ['key', 'value', 'agent_id'],
  title: 'AgentEnvironmentVariable',
} as const;

export const $AgentFileAttachment = {
  properties: {
    id: {
      type: 'string',
      title: 'Id',
      description: 'Unique identifier of the file-agent relationship',
    },
    file_id: {
      type: 'string',
      title: 'File Id',
      description: 'Unique identifier of the file',
    },
    file_name: {
      type: 'string',
      title: 'File Name',
      description: 'Name of the file',
    },
    folder_id: {
      type: 'string',
      title: 'Folder Id',
      description: 'Unique identifier of the folder/source',
    },
    folder_name: {
      type: 'string',
      title: 'Folder Name',
      description: 'Name of the folder/source',
    },
    is_open: {
      type: 'boolean',
      title: 'Is Open',
      description: "Whether the file is currently open in the agent's context",
    },
    last_accessed_at: {
      anyOf: [
        {
          type: 'string',
          format: 'date-time',
        },
        {
          type: 'null',
        },
      ],
      title: 'Last Accessed At',
      description: 'Timestamp of last access by the agent',
    },
    visible_content: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Visible Content',
      description: 'Portion of the file visible to the agent if open',
    },
    start_line: {
      anyOf: [
        {
          type: 'integer',
        },
        {
          type: 'null',
        },
      ],
      title: 'Start Line',
      description: 'Starting line number if file was opened with line range',
    },
    end_line: {
      anyOf: [
        {
          type: 'integer',
        },
        {
          type: 'null',
        },
      ],
      title: 'End Line',
      description: 'Ending line number if file was opened with line range',
    },
  },
  additionalProperties: false,
  type: 'object',
  required: [
    'id',
    'file_id',
    'file_name',
    'folder_id',
    'folder_name',
    'is_open',
  ],
  title: 'AgentFileAttachment',
  description:
    'Response model for agent file attachments showing file status in agent context',
} as const;

export const $AgentFileSchema = {
  properties: {
    agents: {
      items: {
        $ref: '#/components/schemas/letta__schemas__agent_file__AgentSchema',
      },
      type: 'array',
      title: 'Agents',
      description: 'List of agents in this agent file',
    },
    groups: {
      items: {
        $ref: '#/components/schemas/GroupSchema',
      },
      type: 'array',
      title: 'Groups',
      description: 'List of groups in this agent file',
    },
    blocks: {
      items: {
        $ref: '#/components/schemas/BlockSchema',
      },
      type: 'array',
      title: 'Blocks',
      description: 'List of memory blocks in this agent file',
    },
    files: {
      items: {
        $ref: '#/components/schemas/FileSchema',
      },
      type: 'array',
      title: 'Files',
      description: 'List of files in this agent file',
    },
    sources: {
      items: {
        $ref: '#/components/schemas/SourceSchema',
      },
      type: 'array',
      title: 'Sources',
      description: 'List of sources in this agent file',
    },
    tools: {
      items: {
        $ref: '#/components/schemas/letta__schemas__agent_file__ToolSchema',
      },
      type: 'array',
      title: 'Tools',
      description: 'List of tools in this agent file',
    },
    mcp_servers: {
      items: {
        $ref: '#/components/schemas/MCPServerSchema',
      },
      type: 'array',
      title: 'Mcp Servers',
      description: 'List of MCP servers in this agent file',
    },
    metadata: {
      additionalProperties: {
        type: 'string',
      },
      type: 'object',
      title: 'Metadata',
      description:
        'Metadata for this agent file, including revision_id and other export information.',
    },
    created_at: {
      anyOf: [
        {
          type: 'string',
          format: 'date-time',
        },
        {
          type: 'null',
        },
      ],
      title: 'Created At',
      description: 'The timestamp when the object was created.',
    },
  },
  type: 'object',
  required: [
    'agents',
    'groups',
    'blocks',
    'files',
    'sources',
    'tools',
    'mcp_servers',
  ],
  title: 'AgentFileSchema',
  description:
    'Schema for serialized agent file that can be exported to JSON and imported into agent server.',
} as const;

export const $AgentState = {
  properties: {
    created_by_id: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Created By Id',
      description: 'The id of the user that made this object.',
    },
    last_updated_by_id: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Last Updated By Id',
      description: 'The id of the user that made this object.',
    },
    created_at: {
      anyOf: [
        {
          type: 'string',
          format: 'date-time',
        },
        {
          type: 'null',
        },
      ],
      title: 'Created At',
      description: 'The timestamp when the object was created.',
    },
    updated_at: {
      anyOf: [
        {
          type: 'string',
          format: 'date-time',
        },
        {
          type: 'null',
        },
      ],
      title: 'Updated At',
      description: 'The timestamp when the object was last updated.',
    },
    id: {
      type: 'string',
      title: 'Id',
      description: 'The id of the agent. Assigned by the database.',
    },
    name: {
      type: 'string',
      title: 'Name',
      description: 'The name of the agent.',
    },
    tool_rules: {
      anyOf: [
        {
          items: {
            oneOf: [
              {
                $ref: '#/components/schemas/ChildToolRule',
              },
              {
                $ref: '#/components/schemas/InitToolRule',
              },
              {
                $ref: '#/components/schemas/TerminalToolRule',
              },
              {
                $ref: '#/components/schemas/ConditionalToolRule',
              },
              {
                $ref: '#/components/schemas/ContinueToolRule',
              },
              {
                $ref: '#/components/schemas/RequiredBeforeExitToolRule',
              },
              {
                $ref: '#/components/schemas/MaxCountPerStepToolRule',
              },
              {
                $ref: '#/components/schemas/ParentToolRule',
              },
              {
                $ref: '#/components/schemas/RequiresApprovalToolRule',
              },
            ],
            discriminator: {
              propertyName: 'type',
              mapping: {
                conditional: '#/components/schemas/ConditionalToolRule',
                constrain_child_tools: '#/components/schemas/ChildToolRule',
                continue_loop: '#/components/schemas/ContinueToolRule',
                exit_loop: '#/components/schemas/TerminalToolRule',
                max_count_per_step:
                  '#/components/schemas/MaxCountPerStepToolRule',
                parent_last_tool: '#/components/schemas/ParentToolRule',
                required_before_exit:
                  '#/components/schemas/RequiredBeforeExitToolRule',
                requires_approval:
                  '#/components/schemas/RequiresApprovalToolRule',
                run_first: '#/components/schemas/InitToolRule',
              },
            },
          },
          type: 'array',
        },
        {
          type: 'null',
        },
      ],
      title: 'Tool Rules',
      description: 'The list of tool rules.',
    },
    message_ids: {
      anyOf: [
        {
          items: {
            type: 'string',
          },
          type: 'array',
        },
        {
          type: 'null',
        },
      ],
      title: 'Message Ids',
      description: "The ids of the messages in the agent's in-context memory.",
    },
    system: {
      type: 'string',
      title: 'System',
      description: 'The system prompt used by the agent.',
    },
    agent_type: {
      $ref: '#/components/schemas/AgentType',
      description: 'The type of agent.',
    },
    llm_config: {
      $ref: '#/components/schemas/LLMConfig',
      description: 'The LLM configuration used by the agent.',
    },
    embedding_config: {
      $ref: '#/components/schemas/EmbeddingConfig',
      description: 'The embedding configuration used by the agent.',
    },
    response_format: {
      anyOf: [
        {
          oneOf: [
            {
              $ref: '#/components/schemas/TextResponseFormat',
            },
            {
              $ref: '#/components/schemas/JsonSchemaResponseFormat',
            },
            {
              $ref: '#/components/schemas/JsonObjectResponseFormat',
            },
          ],
          discriminator: {
            propertyName: 'type',
            mapping: {
              json_object: '#/components/schemas/JsonObjectResponseFormat',
              json_schema: '#/components/schemas/JsonSchemaResponseFormat',
              text: '#/components/schemas/TextResponseFormat',
            },
          },
        },
        {
          type: 'null',
        },
      ],
      title: 'Response Format',
      description:
        'The response format used by the agent when returning from `send_message`.',
    },
    description: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Description',
      description: 'The description of the agent.',
    },
    metadata: {
      anyOf: [
        {
          additionalProperties: true,
          type: 'object',
        },
        {
          type: 'null',
        },
      ],
      title: 'Metadata',
      description: 'The metadata of the agent.',
    },
    memory: {
      $ref: '#/components/schemas/Memory',
      description: 'The in-context memory of the agent.',
    },
    tools: {
      items: {
        $ref: '#/components/schemas/Tool',
      },
      type: 'array',
      title: 'Tools',
      description: 'The tools used by the agent.',
    },
    sources: {
      items: {
        $ref: '#/components/schemas/Source',
      },
      type: 'array',
      title: 'Sources',
      description: 'The sources used by the agent.',
    },
    tags: {
      items: {
        type: 'string',
      },
      type: 'array',
      title: 'Tags',
      description: 'The tags associated with the agent.',
    },
    tool_exec_environment_variables: {
      items: {
        $ref: '#/components/schemas/AgentEnvironmentVariable',
      },
      type: 'array',
      title: 'Tool Exec Environment Variables',
      description: 'Deprecated: use `secrets` field instead.',
      deprecated: true,
    },
    secrets: {
      items: {
        $ref: '#/components/schemas/AgentEnvironmentVariable',
      },
      type: 'array',
      title: 'Secrets',
      description:
        'The environment variables for tool execution specific to this agent.',
    },
    project_id: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Project Id',
      description: 'The id of the project the agent belongs to.',
    },
    template_id: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Template Id',
      description: 'The id of the template the agent belongs to.',
    },
    base_template_id: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Base Template Id',
      description: 'The base template id of the agent.',
    },
    deployment_id: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Deployment Id',
      description: 'The id of the deployment.',
    },
    entity_id: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Entity Id',
      description: 'The id of the entity within the template.',
    },
    identity_ids: {
      items: {
        type: 'string',
      },
      type: 'array',
      title: 'Identity Ids',
      description: 'The ids of the identities associated with this agent.',
      default: [],
    },
    message_buffer_autoclear: {
      type: 'boolean',
      title: 'Message Buffer Autoclear',
      description:
        'If set to True, the agent will not remember previous messages (though the agent will still retain state via core memory blocks and archival/recall memory). Not recommended unless you have an advanced use case.',
      default: false,
    },
    enable_sleeptime: {
      anyOf: [
        {
          type: 'boolean',
        },
        {
          type: 'null',
        },
      ],
      title: 'Enable Sleeptime',
      description:
        'If set to True, memory management will move to a background agent thread.',
    },
    multi_agent_group: {
      anyOf: [
        {
          $ref: '#/components/schemas/Group',
        },
        {
          type: 'null',
        },
      ],
      description: 'The multi-agent group that this agent manages',
    },
    last_run_completion: {
      anyOf: [
        {
          type: 'string',
          format: 'date-time',
        },
        {
          type: 'null',
        },
      ],
      title: 'Last Run Completion',
      description: 'The timestamp when the agent last completed a run.',
    },
    last_run_duration_ms: {
      anyOf: [
        {
          type: 'integer',
        },
        {
          type: 'null',
        },
      ],
      title: 'Last Run Duration Ms',
      description: "The duration in milliseconds of the agent's last run.",
    },
    timezone: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Timezone',
      description: 'The timezone of the agent (IANA format).',
    },
    max_files_open: {
      anyOf: [
        {
          type: 'integer',
        },
        {
          type: 'null',
        },
      ],
      title: 'Max Files Open',
      description:
        'Maximum number of files that can be open at once for this agent. Setting this too high may exceed the context window, which will break the agent.',
    },
    per_file_view_window_char_limit: {
      anyOf: [
        {
          type: 'integer',
        },
        {
          type: 'null',
        },
      ],
      title: 'Per File View Window Char Limit',
      description:
        'The per-file view window character limit for this agent. Setting this too high may exceed the context window, which will break the agent.',
    },
    hidden: {
      anyOf: [
        {
          type: 'boolean',
        },
        {
          type: 'null',
        },
      ],
      title: 'Hidden',
      description: 'If set to True, the agent will be hidden.',
    },
  },
  additionalProperties: false,
  type: 'object',
  required: [
    'id',
    'name',
    'system',
    'agent_type',
    'llm_config',
    'embedding_config',
    'memory',
    'tools',
    'sources',
    'tags',
  ],
  title: 'AgentState',
  description: `Representation of an agent's state. This is the state of the agent at a given time, and is persisted in the DB backend. The state has all the information needed to recreate a persisted agent.

Parameters:
    id (str): The unique identifier of the agent.
    name (str): The name of the agent (must be unique to the user).
    created_at (datetime): The datetime the agent was created.
    message_ids (List[str]): The ids of the messages in the agent's in-context memory.
    memory (Memory): The in-context memory of the agent.
    tools (List[str]): The tools used by the agent. This includes any memory editing functions specified in \`memory\`.
    system (str): The system prompt used by the agent.
    llm_config (LLMConfig): The LLM configuration used by the agent.
    embedding_config (EmbeddingConfig): The embedding configuration used by the agent.`,
} as const;

export const $AgentType = {
  type: 'string',
  enum: [
    'memgpt_agent',
    'memgpt_v2_agent',
    'letta_v1_agent',
    'react_agent',
    'workflow_agent',
    'split_thread_agent',
    'sleeptime_agent',
    'voice_convo_agent',
    'voice_sleeptime_agent',
  ],
  title: 'AgentType',
  description: 'Enum to represent the type of agent.',
} as const;

export const $ApprovalCreate = {
  properties: {
    type: {
      type: 'string',
      const: 'approval',
      title: 'Type',
      description: 'The message type to be created.',
      default: 'approval',
    },
    approve: {
      type: 'boolean',
      title: 'Approve',
      description: 'Whether the tool has been approved',
    },
    approval_request_id: {
      type: 'string',
      title: 'Approval Request Id',
      description: 'The message ID of the approval request',
    },
    reason: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Reason',
      description: 'An optional explanation for the provided approval status',
    },
  },
  type: 'object',
  required: ['approve', 'approval_request_id'],
  title: 'ApprovalCreate',
  description: 'Input to approve or deny a tool call request',
} as const;

export const $ApprovalRequestMessage = {
  properties: {
    id: {
      type: 'string',
      title: 'Id',
    },
    date: {
      type: 'string',
      format: 'date-time',
      title: 'Date',
    },
    name: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Name',
    },
    message_type: {
      type: 'string',
      const: 'approval_request_message',
      title: 'Message Type',
      description: 'The type of the message.',
      default: 'approval_request_message',
    },
    otid: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Otid',
    },
    sender_id: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Sender Id',
    },
    step_id: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Step Id',
    },
    is_err: {
      anyOf: [
        {
          type: 'boolean',
        },
        {
          type: 'null',
        },
      ],
      title: 'Is Err',
    },
    seq_id: {
      anyOf: [
        {
          type: 'integer',
        },
        {
          type: 'null',
        },
      ],
      title: 'Seq Id',
    },
    run_id: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Run Id',
    },
    tool_call: {
      anyOf: [
        {
          $ref: '#/components/schemas/ToolCall',
        },
        {
          $ref: '#/components/schemas/ToolCallDelta',
        },
      ],
      title: 'Tool Call',
      description: 'The tool call that has been requested by the llm to run',
    },
  },
  type: 'object',
  required: ['id', 'date', 'tool_call'],
  title: 'ApprovalRequestMessage',
  description: `A message representing a request for approval to call a tool (generated by the LLM to trigger tool execution).

Args:
    id (str): The ID of the message
    date (datetime): The date the message was created in ISO format
    name (Optional[str]): The name of the sender of the message
    tool_call (ToolCall): The tool call`,
} as const;

export const $ApprovalResponseMessage = {
  properties: {
    id: {
      type: 'string',
      title: 'Id',
    },
    date: {
      type: 'string',
      format: 'date-time',
      title: 'Date',
    },
    name: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Name',
    },
    message_type: {
      type: 'string',
      const: 'approval_response_message',
      title: 'Message Type',
      description: 'The type of the message.',
      default: 'approval_response_message',
    },
    otid: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Otid',
    },
    sender_id: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Sender Id',
    },
    step_id: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Step Id',
    },
    is_err: {
      anyOf: [
        {
          type: 'boolean',
        },
        {
          type: 'null',
        },
      ],
      title: 'Is Err',
    },
    seq_id: {
      anyOf: [
        {
          type: 'integer',
        },
        {
          type: 'null',
        },
      ],
      title: 'Seq Id',
    },
    run_id: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Run Id',
    },
    approve: {
      type: 'boolean',
      title: 'Approve',
      description: 'Whether the tool has been approved',
    },
    approval_request_id: {
      type: 'string',
      title: 'Approval Request Id',
      description: 'The message ID of the approval request',
    },
    reason: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Reason',
      description: 'An optional explanation for the provided approval status',
    },
  },
  type: 'object',
  required: ['id', 'date', 'approve', 'approval_request_id'],
  title: 'ApprovalResponseMessage',
  description: `A message representing a response form the user indicating whether a tool has been approved to run.

Args:
    id (str): The ID of the message
    date (datetime): The date the message was created in ISO format
    name (Optional[str]): The name of the sender of the message
    approve: (bool) Whether the tool has been approved
    approval_request_id: The ID of the approval request
    reason: (Optional[str]) An optional explanation for the provided approval status`,
} as const;

export const $ArchivalMemorySearchResponse = {
  properties: {
    results: {
      items: {
        $ref: '#/components/schemas/ArchivalMemorySearchResult',
      },
      type: 'array',
      title: 'Results',
      description: 'List of search results matching the query',
    },
    count: {
      type: 'integer',
      title: 'Count',
      description: 'Total number of results returned',
    },
  },
  type: 'object',
  required: ['results', 'count'],
  title: 'ArchivalMemorySearchResponse',
} as const;

export const $ArchivalMemorySearchResult = {
  properties: {
    timestamp: {
      type: 'string',
      title: 'Timestamp',
      description:
        "Timestamp of when the memory was created, formatted in agent's timezone",
    },
    content: {
      type: 'string',
      title: 'Content',
      description: 'Text content of the archival memory passage',
    },
    tags: {
      items: {
        type: 'string',
      },
      type: 'array',
      title: 'Tags',
      description: 'List of tags associated with this memory',
    },
  },
  type: 'object',
  required: ['timestamp', 'content'],
  title: 'ArchivalMemorySearchResult',
} as const;

export const $Archive = {
  properties: {
    created_by_id: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Created By Id',
      description: 'The id of the user that made this object.',
    },
    last_updated_by_id: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Last Updated By Id',
      description: 'The id of the user that made this object.',
    },
    created_at: {
      type: 'string',
      format: 'date-time',
      title: 'Created At',
      description: 'The creation date of the archive',
    },
    updated_at: {
      anyOf: [
        {
          type: 'string',
          format: 'date-time',
        },
        {
          type: 'null',
        },
      ],
      title: 'Updated At',
      description: 'The timestamp when the object was last updated.',
    },
    name: {
      type: 'string',
      title: 'Name',
      description: 'The name of the archive',
    },
    description: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Description',
      description: 'A description of the archive',
    },
    organization_id: {
      type: 'string',
      title: 'Organization Id',
      description: 'The organization this archive belongs to',
    },
    vector_db_provider: {
      $ref: '#/components/schemas/VectorDBProvider',
      description:
        "The vector database provider used for this archive's passages",
      default: 'native',
    },
    metadata: {
      anyOf: [
        {
          additionalProperties: true,
          type: 'object',
        },
        {
          type: 'null',
        },
      ],
      title: 'Metadata',
      description: 'Additional metadata',
    },
    id: {
      type: 'string',
      pattern: '^archive-[a-fA-F0-9]{8}',
      title: 'Id',
      description: 'The human-friendly ID of the Archive',
      examples: ['archive-123e4567-e89b-12d3-a456-426614174000'],
    },
  },
  additionalProperties: false,
  type: 'object',
  required: ['created_at', 'name', 'organization_id'],
  title: 'Archive',
  description: `Representation of an archive - a collection of archival passages that can be shared between agents.

Parameters:
    id (str): The unique identifier of the archive.
    name (str): The name of the archive.
    description (str): A description of the archive.
    organization_id (str): The organization this archive belongs to.
    created_at (datetime): The creation date of the archive.
    metadata (dict): Additional metadata for the archive.`,
} as const;

export const $ArchiveCreateRequest = {
  properties: {
    name: {
      type: 'string',
      title: 'Name',
    },
    description: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Description',
    },
  },
  type: 'object',
  required: ['name'],
  title: 'ArchiveCreateRequest',
  description: `Request model for creating an archive.

Intentionally excludes vector_db_provider. These are derived internally (vector DB provider from env).`,
} as const;

export const $ArchiveUpdateRequest = {
  properties: {
    name: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Name',
    },
    description: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Description',
    },
  },
  type: 'object',
  title: 'ArchiveUpdateRequest',
  description: `Request model for updating an archive (partial).

Supports updating only name and description.`,
} as const;

export const $AssistantMessage = {
  properties: {
    id: {
      type: 'string',
      title: 'Id',
    },
    date: {
      type: 'string',
      format: 'date-time',
      title: 'Date',
    },
    name: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Name',
    },
    message_type: {
      type: 'string',
      const: 'assistant_message',
      title: 'Message Type',
      description: 'The type of the message.',
      default: 'assistant_message',
    },
    otid: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Otid',
    },
    sender_id: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Sender Id',
    },
    step_id: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Step Id',
    },
    is_err: {
      anyOf: [
        {
          type: 'boolean',
        },
        {
          type: 'null',
        },
      ],
      title: 'Is Err',
    },
    seq_id: {
      anyOf: [
        {
          type: 'integer',
        },
        {
          type: 'null',
        },
      ],
      title: 'Seq Id',
    },
    run_id: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Run Id',
    },
    content: {
      anyOf: [
        {
          items: {
            $ref: '#/components/schemas/LettaAssistantMessageContentUnion',
          },
          type: 'array',
        },
        {
          type: 'string',
        },
      ],
      title: 'Content',
      description:
        'The message content sent by the agent (can be a string or an array of content parts)',
    },
  },
  type: 'object',
  required: ['id', 'date', 'content'],
  title: 'AssistantMessage',
  description: `A message sent by the LLM in response to user input. Used in the LLM context.

Args:
    id (str): The ID of the message
    date (datetime): The date the message was created in ISO format
    name (Optional[str]): The name of the sender of the message
    content (Union[str, List[LettaAssistantMessageContentUnion]]): The message content sent by the agent (can be a string or an array of content parts)`,
} as const;

export const $AuthRequest = {
  properties: {
    password: {
      type: 'string',
      title: 'Password',
      description: 'Admin password provided when starting the Letta server',
    },
  },
  type: 'object',
  title: 'AuthRequest',
} as const;

export const $AuthResponse = {
  properties: {
    uuid: {
      type: 'string',
      format: 'uuid',
      title: 'Uuid',
      description: 'UUID of the user',
    },
    is_admin: {
      anyOf: [
        {
          type: 'boolean',
        },
        {
          type: 'null',
        },
      ],
      title: 'Is Admin',
      description: 'Whether the user is an admin',
    },
  },
  type: 'object',
  required: ['uuid'],
  title: 'AuthResponse',
} as const;

export const $Base64Image = {
  properties: {
    type: {
      type: 'string',
      const: 'base64',
      title: 'Type',
      description: 'The source type for the image.',
      default: 'base64',
    },
    media_type: {
      type: 'string',
      title: 'Media Type',
      description: 'The media type for the image.',
    },
    data: {
      type: 'string',
      title: 'Data',
      description: 'The base64 encoded image data.',
    },
    detail: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Detail',
      description:
        'What level of detail to use when processing and understanding the image (low, high, or auto to let the model decide)',
    },
  },
  type: 'object',
  required: ['media_type', 'data'],
  title: 'Base64Image',
} as const;

export const $BaseToolRuleSchema = {
  properties: {
    tool_name: {
      type: 'string',
      title: 'Tool Name',
    },
    type: {
      type: 'string',
      title: 'Type',
    },
  },
  type: 'object',
  required: ['tool_name', 'type'],
  title: 'BaseToolRuleSchema',
} as const;

export const $BatchJob = {
  properties: {
    created_by_id: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Created By Id',
      description: 'The id of the user that made this object.',
    },
    last_updated_by_id: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Last Updated By Id',
      description: 'The id of the user that made this object.',
    },
    created_at: {
      type: 'string',
      format: 'date-time',
      title: 'Created At',
      description: 'The unix timestamp of when the job was created.',
    },
    updated_at: {
      anyOf: [
        {
          type: 'string',
          format: 'date-time',
        },
        {
          type: 'null',
        },
      ],
      title: 'Updated At',
      description: 'The timestamp when the object was last updated.',
    },
    status: {
      $ref: '#/components/schemas/JobStatus',
      description: 'The status of the job.',
      default: 'created',
    },
    completed_at: {
      anyOf: [
        {
          type: 'string',
          format: 'date-time',
        },
        {
          type: 'null',
        },
      ],
      title: 'Completed At',
      description: 'The unix timestamp of when the job was completed.',
    },
    stop_reason: {
      anyOf: [
        {
          $ref: '#/components/schemas/StopReasonType',
        },
        {
          type: 'null',
        },
      ],
      description: 'The reason why the job was stopped.',
    },
    metadata: {
      anyOf: [
        {
          additionalProperties: true,
          type: 'object',
        },
        {
          type: 'null',
        },
      ],
      title: 'Metadata',
      description: 'The metadata of the job.',
    },
    job_type: {
      $ref: '#/components/schemas/JobType',
      default: 'batch',
    },
    background: {
      anyOf: [
        {
          type: 'boolean',
        },
        {
          type: 'null',
        },
      ],
      title: 'Background',
      description: 'Whether the job was created in background mode.',
    },
    agent_id: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Agent Id',
      description: 'The agent associated with this job/run.',
    },
    callback_url: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Callback Url',
      description: 'If set, POST to this URL when the job completes.',
    },
    callback_sent_at: {
      anyOf: [
        {
          type: 'string',
          format: 'date-time',
        },
        {
          type: 'null',
        },
      ],
      title: 'Callback Sent At',
      description: 'Timestamp when the callback was last attempted.',
    },
    callback_status_code: {
      anyOf: [
        {
          type: 'integer',
        },
        {
          type: 'null',
        },
      ],
      title: 'Callback Status Code',
      description: 'HTTP status code returned by the callback endpoint.',
    },
    callback_error: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Callback Error',
      description:
        'Optional error message from attempting to POST the callback endpoint.',
    },
    ttft_ns: {
      anyOf: [
        {
          type: 'integer',
        },
        {
          type: 'null',
        },
      ],
      title: 'Ttft Ns',
      description: 'Time to first token for a run in nanoseconds',
    },
    total_duration_ns: {
      anyOf: [
        {
          type: 'integer',
        },
        {
          type: 'null',
        },
      ],
      title: 'Total Duration Ns',
      description: 'Total run duration in nanoseconds',
    },
    id: {
      type: 'string',
      pattern: '^(job|run)-[a-fA-F0-9]{8}',
      title: 'Id',
      description: 'The human-friendly ID of the Job',
      examples: ['job-123e4567-e89b-12d3-a456-426614174000'],
    },
    user_id: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'User Id',
      description: 'The unique identifier of the user associated with the job.',
    },
  },
  additionalProperties: false,
  type: 'object',
  title: 'BatchJob',
} as const;

export const $Block = {
  properties: {
    value: {
      type: 'string',
      title: 'Value',
      description: 'Value of the block.',
    },
    limit: {
      type: 'integer',
      title: 'Limit',
      description: 'Character limit of the block.',
      default: 20000,
    },
    project_id: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Project Id',
      description: 'The associated project id.',
    },
    name: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Name',
      description: 'The id of the template.',
    },
    is_template: {
      type: 'boolean',
      title: 'Is Template',
      description:
        'Whether the block is a template (e.g. saved human/persona options).',
      default: false,
    },
    base_template_id: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Base Template Id',
      description: 'The base template id of the block.',
    },
    deployment_id: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Deployment Id',
      description: 'The id of the deployment.',
    },
    entity_id: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Entity Id',
      description: 'The id of the entity within the template.',
    },
    preserve_on_migration: {
      anyOf: [
        {
          type: 'boolean',
        },
        {
          type: 'null',
        },
      ],
      title: 'Preserve On Migration',
      description: 'Preserve the block on template migration.',
      default: false,
    },
    label: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Label',
      description:
        "Label of the block (e.g. 'human', 'persona') in the context window.",
    },
    read_only: {
      type: 'boolean',
      title: 'Read Only',
      description: 'Whether the agent has read-only access to the block.',
      default: false,
    },
    description: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Description',
      description: 'Description of the block.',
    },
    metadata: {
      anyOf: [
        {
          additionalProperties: true,
          type: 'object',
        },
        {
          type: 'null',
        },
      ],
      title: 'Metadata',
      description: 'Metadata of the block.',
      default: {},
    },
    hidden: {
      anyOf: [
        {
          type: 'boolean',
        },
        {
          type: 'null',
        },
      ],
      title: 'Hidden',
      description: 'If set to True, the block will be hidden.',
    },
    id: {
      type: 'string',
      pattern: '^block-[a-fA-F0-9]{8}',
      title: 'Id',
      description: 'The human-friendly ID of the Block',
      examples: ['block-123e4567-e89b-12d3-a456-426614174000'],
    },
    created_by_id: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Created By Id',
      description: 'The id of the user that made this Block.',
    },
    last_updated_by_id: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Last Updated By Id',
      description: 'The id of the user that last updated this Block.',
    },
  },
  type: 'object',
  required: ['value'],
  title: 'Block',
  description: `A Block represents a reserved section of the LLM's context window which is editable. \`Block\` objects contained in the \`Memory\` object, which is able to edit the Block values.

Parameters:
    label (str): The label of the block (e.g. 'human', 'persona'). This defines a category for the block.
    value (str): The value of the block. This is the string that is represented in the context window.
    limit (int): The character limit of the block.
    is_template (bool): Whether the block is a template (e.g. saved human/persona options). Non-template blocks are not stored in the database and are ephemeral, while templated blocks are stored in the database.
    label (str): The label of the block (e.g. 'human', 'persona'). This defines a category for the block.
    template_name (str): The name of the block template (if it is a template).
    description (str): Description of the block.
    metadata (Dict): Metadata of the block.
    user_id (str): The unique identifier of the user associated with the block.`,
} as const;

export const $BlockSchema = {
  properties: {
    value: {
      type: 'string',
      title: 'Value',
      description: 'Value of the block.',
    },
    limit: {
      type: 'integer',
      title: 'Limit',
      description: 'Character limit of the block.',
      default: 20000,
    },
    project_id: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Project Id',
      description: 'The associated project id.',
    },
    name: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Name',
      description: 'The id of the template.',
    },
    is_template: {
      type: 'boolean',
      title: 'Is Template',
      default: false,
    },
    base_template_id: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Base Template Id',
      description: 'The base template id of the block.',
    },
    deployment_id: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Deployment Id',
      description: 'The id of the deployment.',
    },
    entity_id: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Entity Id',
      description: 'The id of the entity within the template.',
    },
    preserve_on_migration: {
      anyOf: [
        {
          type: 'boolean',
        },
        {
          type: 'null',
        },
      ],
      title: 'Preserve On Migration',
      description: 'Preserve the block on template migration.',
      default: false,
    },
    label: {
      type: 'string',
      title: 'Label',
      description: 'Label of the block.',
    },
    read_only: {
      type: 'boolean',
      title: 'Read Only',
      description: 'Whether the agent has read-only access to the block.',
      default: false,
    },
    description: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Description',
      description: 'Description of the block.',
    },
    metadata: {
      anyOf: [
        {
          additionalProperties: true,
          type: 'object',
        },
        {
          type: 'null',
        },
      ],
      title: 'Metadata',
      description: 'Metadata of the block.',
      default: {},
    },
    hidden: {
      anyOf: [
        {
          type: 'boolean',
        },
        {
          type: 'null',
        },
      ],
      title: 'Hidden',
      description: 'If set to True, the block will be hidden.',
    },
    id: {
      type: 'string',
      title: 'Id',
      description: 'Human-readable identifier for this block in the file',
    },
  },
  type: 'object',
  required: ['value', 'label', 'id'],
  title: 'BlockSchema',
  description: 'Block with human-readable ID for agent file',
} as const;

export const $BlockUpdate = {
  properties: {
    value: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Value',
      description: 'Value of the block.',
    },
    limit: {
      anyOf: [
        {
          type: 'integer',
        },
        {
          type: 'null',
        },
      ],
      title: 'Limit',
      description: 'Character limit of the block.',
    },
    project_id: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Project Id',
      description: 'The associated project id.',
    },
    name: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Name',
      description: 'The id of the template.',
    },
    is_template: {
      type: 'boolean',
      title: 'Is Template',
      description:
        'Whether the block is a template (e.g. saved human/persona options).',
      default: false,
    },
    base_template_id: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Base Template Id',
      description: 'The base template id of the block.',
    },
    deployment_id: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Deployment Id',
      description: 'The id of the deployment.',
    },
    entity_id: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Entity Id',
      description: 'The id of the entity within the template.',
    },
    preserve_on_migration: {
      anyOf: [
        {
          type: 'boolean',
        },
        {
          type: 'null',
        },
      ],
      title: 'Preserve On Migration',
      description: 'Preserve the block on template migration.',
      default: false,
    },
    label: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Label',
      description:
        "Label of the block (e.g. 'human', 'persona') in the context window.",
    },
    read_only: {
      type: 'boolean',
      title: 'Read Only',
      description: 'Whether the agent has read-only access to the block.',
      default: false,
    },
    description: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Description',
      description: 'Description of the block.',
    },
    metadata: {
      anyOf: [
        {
          additionalProperties: true,
          type: 'object',
        },
        {
          type: 'null',
        },
      ],
      title: 'Metadata',
      description: 'Metadata of the block.',
      default: {},
    },
    hidden: {
      anyOf: [
        {
          type: 'boolean',
        },
        {
          type: 'null',
        },
      ],
      title: 'Hidden',
      description: 'If set to True, the block will be hidden.',
    },
  },
  type: 'object',
  title: 'BlockUpdate',
  description: 'Update a block',
} as const;

export const $Body_export_agent = {
  properties: {
    spec: {
      anyOf: [
        {
          $ref: '#/components/schemas/AgentFileSchema',
        },
        {
          type: 'null',
        },
      ],
    },
    legacy_spec: {
      anyOf: [
        {
          $ref: '#/components/schemas/letta__serialize_schemas__pydantic_agent_schema__AgentSchema',
        },
        {
          type: 'null',
        },
      ],
    },
  },
  type: 'object',
  title: 'Body_export_agent',
} as const;

export const $Body_import_agent = {
  properties: {
    file: {
      type: 'string',
      format: 'binary',
      title: 'File',
    },
    append_copy_suffix: {
      type: 'boolean',
      title: 'Append Copy Suffix',
      description:
        'If set to True, appends "_copy" to the end of the agent name.',
      default: true,
    },
    override_existing_tools: {
      type: 'boolean',
      title: 'Override Existing Tools',
      description:
        'If set to True, existing tools can get their source code overwritten by the uploaded tool definitions. Note that Letta core tools can never be updated externally.',
      default: true,
    },
    override_embedding_handle: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Override Embedding Handle',
      description: 'Override import with specific embedding handle.',
    },
    project_id: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Project Id',
      description: 'The project ID to associate the uploaded agent with.',
    },
    strip_messages: {
      type: 'boolean',
      title: 'Strip Messages',
      description:
        'If set to True, strips all messages from the agent before importing.',
      default: false,
    },
    env_vars_json: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Env Vars Json',
      description:
        'Environment variables as a JSON string to pass to the agent for tool execution.',
    },
  },
  type: 'object',
  required: ['file'],
  title: 'Body_import_agent',
} as const;

export const $Body_upload_file_to_folder = {
  properties: {
    file: {
      type: 'string',
      format: 'binary',
      title: 'File',
    },
  },
  type: 'object',
  required: ['file'],
  title: 'Body_upload_file_to_folder',
} as const;

export const $Body_upload_file_to_source = {
  properties: {
    file: {
      type: 'string',
      format: 'binary',
      title: 'File',
    },
  },
  type: 'object',
  required: ['file'],
  title: 'Body_upload_file_to_source',
} as const;

export const $CancelAgentRunRequest = {
  properties: {
    run_ids: {
      anyOf: [
        {
          items: {
            type: 'string',
          },
          type: 'array',
        },
        {
          type: 'null',
        },
      ],
      title: 'Run Ids',
      description: 'Optional list of run IDs to cancel',
    },
  },
  type: 'object',
  title: 'CancelAgentRunRequest',
} as const;

export const $ChatCompletionMessageFunctionToolCall = {
  properties: {
    id: {
      type: 'string',
      title: 'Id',
    },
    function: {
      $ref: '#/components/schemas/Function',
    },
    type: {
      type: 'string',
      const: 'function',
      title: 'Type',
    },
  },
  additionalProperties: true,
  type: 'object',
  required: ['id', 'function', 'type'],
  title: 'ChatCompletionMessageFunctionToolCall',
} as const;

export const $ChildToolRule = {
  properties: {
    tool_name: {
      type: 'string',
      title: 'Tool Name',
      description:
        "The name of the tool. Must exist in the database for the user's organization.",
    },
    type: {
      type: 'string',
      const: 'constrain_child_tools',
      title: 'Type',
      default: 'constrain_child_tools',
    },
    prompt_template: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Prompt Template',
      description: 'Optional template string (ignored).',
    },
    children: {
      items: {
        type: 'string',
      },
      type: 'array',
      title: 'Children',
      description: 'The children tools that can be invoked.',
    },
    child_arg_nodes: {
      anyOf: [
        {
          items: {
            $ref: '#/components/schemas/ToolCallNode',
          },
          type: 'array',
        },
        {
          type: 'null',
        },
      ],
      title: 'Child Arg Nodes',
      description:
        "Optional list of typed child argument overrides. Each node must reference a child in 'children'.",
    },
  },
  additionalProperties: false,
  type: 'object',
  required: ['tool_name', 'children'],
  title: 'ChildToolRule',
  description: 'A ToolRule represents a tool that can be invoked by the agent.',
} as const;

export const $ChildToolRuleSchema = {
  properties: {
    tool_name: {
      type: 'string',
      title: 'Tool Name',
    },
    type: {
      type: 'string',
      title: 'Type',
    },
    children: {
      items: {
        type: 'string',
      },
      type: 'array',
      title: 'Children',
    },
  },
  type: 'object',
  required: ['tool_name', 'type', 'children'],
  title: 'ChildToolRuleSchema',
} as const;

export const $CodeInput = {
  properties: {
    code: {
      type: 'string',
      title: 'Code',
      description: 'Source code to parse for JSON schema',
    },
    source_type: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Source Type',
      description: 'The source type of the code (python or typescript)',
      default: 'python',
    },
  },
  type: 'object',
  required: ['code'],
  title: 'CodeInput',
} as const;

export const $ConditionalToolRule = {
  properties: {
    tool_name: {
      type: 'string',
      title: 'Tool Name',
      description:
        "The name of the tool. Must exist in the database for the user's organization.",
    },
    type: {
      type: 'string',
      const: 'conditional',
      title: 'Type',
      default: 'conditional',
    },
    prompt_template: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Prompt Template',
      description: 'Optional template string (ignored).',
    },
    default_child: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Default Child',
      description:
        'The default child tool to be called. If None, any tool can be called.',
    },
    child_output_mapping: {
      additionalProperties: {
        type: 'string',
      },
      type: 'object',
      title: 'Child Output Mapping',
      description: 'The output case to check for mapping',
    },
    require_output_mapping: {
      type: 'boolean',
      title: 'Require Output Mapping',
      description:
        "Whether to throw an error when output doesn't match any case",
      default: false,
    },
  },
  additionalProperties: false,
  type: 'object',
  required: ['tool_name', 'child_output_mapping'],
  title: 'ConditionalToolRule',
  description:
    'A ToolRule that conditionally maps to different child tools based on the output.',
} as const;

export const $ConditionalToolRuleSchema = {
  properties: {
    tool_name: {
      type: 'string',
      title: 'Tool Name',
    },
    type: {
      type: 'string',
      title: 'Type',
    },
    default_child: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Default Child',
    },
    child_output_mapping: {
      additionalProperties: {
        type: 'string',
      },
      type: 'object',
      title: 'Child Output Mapping',
    },
    require_output_mapping: {
      type: 'boolean',
      title: 'Require Output Mapping',
    },
  },
  type: 'object',
  required: [
    'tool_name',
    'type',
    'default_child',
    'child_output_mapping',
    'require_output_mapping',
  ],
  title: 'ConditionalToolRuleSchema',
} as const;

export const $ContextWindowOverview = {
  properties: {
    context_window_size_max: {
      type: 'integer',
      title: 'Context Window Size Max',
      description: 'The maximum amount of tokens the context window can hold.',
    },
    context_window_size_current: {
      type: 'integer',
      title: 'Context Window Size Current',
      description: 'The current number of tokens in the context window.',
    },
    num_messages: {
      type: 'integer',
      title: 'Num Messages',
      description: 'The number of messages in the context window.',
    },
    num_archival_memory: {
      type: 'integer',
      title: 'Num Archival Memory',
      description: 'The number of messages in the archival memory.',
    },
    num_recall_memory: {
      type: 'integer',
      title: 'Num Recall Memory',
      description: 'The number of messages in the recall memory.',
    },
    num_tokens_external_memory_summary: {
      type: 'integer',
      title: 'Num Tokens External Memory Summary',
      description:
        'The number of tokens in the external memory summary (archival + recall metadata).',
    },
    external_memory_summary: {
      type: 'string',
      title: 'External Memory Summary',
      description:
        'The metadata summary of the external memory sources (archival + recall metadata).',
    },
    num_tokens_system: {
      type: 'integer',
      title: 'Num Tokens System',
      description: 'The number of tokens in the system prompt.',
    },
    system_prompt: {
      type: 'string',
      title: 'System Prompt',
      description: 'The content of the system prompt.',
    },
    num_tokens_core_memory: {
      type: 'integer',
      title: 'Num Tokens Core Memory',
      description: 'The number of tokens in the core memory.',
    },
    core_memory: {
      type: 'string',
      title: 'Core Memory',
      description: 'The content of the core memory.',
    },
    num_tokens_summary_memory: {
      type: 'integer',
      title: 'Num Tokens Summary Memory',
      description: 'The number of tokens in the summary memory.',
    },
    summary_memory: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Summary Memory',
      description: 'The content of the summary memory.',
    },
    num_tokens_functions_definitions: {
      type: 'integer',
      title: 'Num Tokens Functions Definitions',
      description: 'The number of tokens in the functions definitions.',
    },
    functions_definitions: {
      anyOf: [
        {
          items: {
            $ref: '#/components/schemas/FunctionTool',
          },
          type: 'array',
        },
        {
          type: 'null',
        },
      ],
      title: 'Functions Definitions',
      description: 'The content of the functions definitions.',
    },
    num_tokens_messages: {
      type: 'integer',
      title: 'Num Tokens Messages',
      description: 'The number of tokens in the messages list.',
    },
    messages: {
      items: {
        $ref: '#/components/schemas/Message',
      },
      type: 'array',
      title: 'Messages',
      description: 'The messages in the context window.',
    },
  },
  type: 'object',
  required: [
    'context_window_size_max',
    'context_window_size_current',
    'num_messages',
    'num_archival_memory',
    'num_recall_memory',
    'num_tokens_external_memory_summary',
    'external_memory_summary',
    'num_tokens_system',
    'system_prompt',
    'num_tokens_core_memory',
    'core_memory',
    'num_tokens_summary_memory',
    'num_tokens_functions_definitions',
    'functions_definitions',
    'num_tokens_messages',
    'messages',
  ],
  title: 'ContextWindowOverview',
  description:
    'Overview of the context window, including the number of messages and tokens.',
} as const;

export const $ContinueToolRule = {
  properties: {
    tool_name: {
      type: 'string',
      title: 'Tool Name',
      description:
        "The name of the tool. Must exist in the database for the user's organization.",
    },
    type: {
      type: 'string',
      const: 'continue_loop',
      title: 'Type',
      default: 'continue_loop',
    },
    prompt_template: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Prompt Template',
      description: 'Optional template string (ignored).',
    },
  },
  additionalProperties: false,
  type: 'object',
  required: ['tool_name'],
  title: 'ContinueToolRule',
  description:
    'Represents a tool rule configuration where if this tool gets called, it must continue the agent loop.',
} as const;

export const $CoreMemoryBlockSchema = {
  properties: {
    created_at: {
      type: 'string',
      title: 'Created At',
    },
    description: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Description',
    },
    is_template: {
      type: 'boolean',
      title: 'Is Template',
    },
    label: {
      type: 'string',
      title: 'Label',
    },
    limit: {
      type: 'integer',
      title: 'Limit',
    },
    metadata_: {
      anyOf: [
        {
          additionalProperties: true,
          type: 'object',
        },
        {
          type: 'null',
        },
      ],
      title: 'Metadata',
    },
    template_name: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Template Name',
    },
    updated_at: {
      type: 'string',
      title: 'Updated At',
    },
    value: {
      type: 'string',
      title: 'Value',
    },
  },
  type: 'object',
  required: [
    'created_at',
    'description',
    'is_template',
    'label',
    'limit',
    'template_name',
    'updated_at',
    'value',
  ],
  title: 'CoreMemoryBlockSchema',
} as const;

export const $CreateAgentRequest = {
  properties: {
    name: {
      type: 'string',
      title: 'Name',
      description: 'The name of the agent.',
    },
    memory_blocks: {
      anyOf: [
        {
          items: {
            $ref: '#/components/schemas/CreateBlock',
          },
          type: 'array',
        },
        {
          type: 'null',
        },
      ],
      title: 'Memory Blocks',
      description: "The blocks to create in the agent's in-context memory.",
    },
    tools: {
      anyOf: [
        {
          items: {
            type: 'string',
          },
          type: 'array',
        },
        {
          type: 'null',
        },
      ],
      title: 'Tools',
      description: 'The tools used by the agent.',
    },
    tool_ids: {
      anyOf: [
        {
          items: {
            type: 'string',
          },
          type: 'array',
        },
        {
          type: 'null',
        },
      ],
      title: 'Tool Ids',
      description: 'The ids of the tools used by the agent.',
    },
    source_ids: {
      anyOf: [
        {
          items: {
            type: 'string',
          },
          type: 'array',
        },
        {
          type: 'null',
        },
      ],
      title: 'Source Ids',
      description: 'The ids of the sources used by the agent.',
    },
    block_ids: {
      anyOf: [
        {
          items: {
            type: 'string',
          },
          type: 'array',
        },
        {
          type: 'null',
        },
      ],
      title: 'Block Ids',
      description: 'The ids of the blocks used by the agent.',
    },
    tool_rules: {
      anyOf: [
        {
          items: {
            oneOf: [
              {
                $ref: '#/components/schemas/ChildToolRule',
              },
              {
                $ref: '#/components/schemas/InitToolRule',
              },
              {
                $ref: '#/components/schemas/TerminalToolRule',
              },
              {
                $ref: '#/components/schemas/ConditionalToolRule',
              },
              {
                $ref: '#/components/schemas/ContinueToolRule',
              },
              {
                $ref: '#/components/schemas/RequiredBeforeExitToolRule',
              },
              {
                $ref: '#/components/schemas/MaxCountPerStepToolRule',
              },
              {
                $ref: '#/components/schemas/ParentToolRule',
              },
              {
                $ref: '#/components/schemas/RequiresApprovalToolRule',
              },
            ],
            discriminator: {
              propertyName: 'type',
              mapping: {
                conditional: '#/components/schemas/ConditionalToolRule',
                constrain_child_tools: '#/components/schemas/ChildToolRule',
                continue_loop: '#/components/schemas/ContinueToolRule',
                exit_loop: '#/components/schemas/TerminalToolRule',
                max_count_per_step:
                  '#/components/schemas/MaxCountPerStepToolRule',
                parent_last_tool: '#/components/schemas/ParentToolRule',
                required_before_exit:
                  '#/components/schemas/RequiredBeforeExitToolRule',
                requires_approval:
                  '#/components/schemas/RequiresApprovalToolRule',
                run_first: '#/components/schemas/InitToolRule',
              },
            },
          },
          type: 'array',
        },
        {
          type: 'null',
        },
      ],
      title: 'Tool Rules',
      description: 'The tool rules governing the agent.',
    },
    tags: {
      anyOf: [
        {
          items: {
            type: 'string',
          },
          type: 'array',
        },
        {
          type: 'null',
        },
      ],
      title: 'Tags',
      description: 'The tags associated with the agent.',
    },
    system: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'System',
      description: 'The system prompt used by the agent.',
    },
    agent_type: {
      $ref: '#/components/schemas/AgentType',
      description: 'The type of agent.',
    },
    llm_config: {
      anyOf: [
        {
          $ref: '#/components/schemas/LLMConfig',
        },
        {
          type: 'null',
        },
      ],
      description: 'The LLM configuration used by the agent.',
    },
    embedding_config: {
      anyOf: [
        {
          $ref: '#/components/schemas/EmbeddingConfig',
        },
        {
          type: 'null',
        },
      ],
      description: 'The embedding configuration used by the agent.',
    },
    initial_message_sequence: {
      anyOf: [
        {
          items: {
            $ref: '#/components/schemas/MessageCreate',
          },
          type: 'array',
        },
        {
          type: 'null',
        },
      ],
      title: 'Initial Message Sequence',
      description:
        "The initial set of messages to put in the agent's in-context memory.",
    },
    include_base_tools: {
      type: 'boolean',
      title: 'Include Base Tools',
      description:
        'If true, attaches the Letta core tools (e.g. core_memory related functions).',
      default: true,
    },
    include_multi_agent_tools: {
      type: 'boolean',
      title: 'Include Multi Agent Tools',
      description:
        'If true, attaches the Letta multi-agent tools (e.g. sending a message to another agent).',
      default: false,
    },
    include_base_tool_rules: {
      anyOf: [
        {
          type: 'boolean',
        },
        {
          type: 'null',
        },
      ],
      title: 'Include Base Tool Rules',
      description:
        'If true, attaches the Letta base tool rules (e.g. deny all tools not explicitly allowed).',
    },
    include_default_source: {
      type: 'boolean',
      title: 'Include Default Source',
      description:
        'If true, automatically creates and attaches a default data source for this agent.',
      default: false,
    },
    description: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Description',
      description: 'The description of the agent.',
    },
    metadata: {
      anyOf: [
        {
          additionalProperties: true,
          type: 'object',
        },
        {
          type: 'null',
        },
      ],
      title: 'Metadata',
      description: 'The metadata of the agent.',
    },
    model: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Model',
      description:
        'The LLM configuration handle used by the agent, specified in the format provider/model-name, as an alternative to specifying llm_config.',
    },
    embedding: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Embedding',
      description:
        'The embedding configuration handle used by the agent, specified in the format provider/model-name.',
    },
    context_window_limit: {
      anyOf: [
        {
          type: 'integer',
        },
        {
          type: 'null',
        },
      ],
      title: 'Context Window Limit',
      description: 'The context window limit used by the agent.',
    },
    embedding_chunk_size: {
      anyOf: [
        {
          type: 'integer',
        },
        {
          type: 'null',
        },
      ],
      title: 'Embedding Chunk Size',
      description: 'The embedding chunk size used by the agent.',
      default: 300,
    },
    max_tokens: {
      anyOf: [
        {
          type: 'integer',
        },
        {
          type: 'null',
        },
      ],
      title: 'Max Tokens',
      description:
        'The maximum number of tokens to generate, including reasoning step. If not set, the model will use its default value.',
    },
    max_reasoning_tokens: {
      anyOf: [
        {
          type: 'integer',
        },
        {
          type: 'null',
        },
      ],
      title: 'Max Reasoning Tokens',
      description:
        'The maximum number of tokens to generate for reasoning step. If not set, the model will use its default value.',
    },
    enable_reasoner: {
      anyOf: [
        {
          type: 'boolean',
        },
        {
          type: 'null',
        },
      ],
      title: 'Enable Reasoner',
      description:
        'Whether to enable internal extended thinking step for a reasoner model.',
      default: true,
    },
    reasoning: {
      anyOf: [
        {
          type: 'boolean',
        },
        {
          type: 'null',
        },
      ],
      title: 'Reasoning',
      description: 'Whether to enable reasoning for this agent.',
    },
    from_template: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'From Template',
      description:
        "Deprecated: please use the 'create agents from a template' endpoint instead.",
    },
    template: {
      type: 'boolean',
      title: 'Template',
      description: 'Deprecated: No longer used',
      default: false,
    },
    project: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Project',
      description:
        'Deprecated: Project should now be passed via the X-Project header instead of in the request body. If using the sdk, this can be done via the new x_project field below.',
      deprecated: true,
    },
    tool_exec_environment_variables: {
      anyOf: [
        {
          additionalProperties: {
            type: 'string',
          },
          type: 'object',
        },
        {
          type: 'null',
        },
      ],
      title: 'Tool Exec Environment Variables',
      description: 'Deprecated: use `secrets` field instead.',
    },
    secrets: {
      anyOf: [
        {
          additionalProperties: {
            type: 'string',
          },
          type: 'object',
        },
        {
          type: 'null',
        },
      ],
      title: 'Secrets',
      description:
        'The environment variables for tool execution specific to this agent.',
    },
    memory_variables: {
      anyOf: [
        {
          additionalProperties: {
            type: 'string',
          },
          type: 'object',
        },
        {
          type: 'null',
        },
      ],
      title: 'Memory Variables',
      description: 'The variables that should be set for the agent.',
    },
    project_id: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Project Id',
      description: 'The id of the project the agent belongs to.',
    },
    template_id: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Template Id',
      description: 'The id of the template the agent belongs to.',
    },
    base_template_id: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Base Template Id',
      description: 'The base template id of the agent.',
    },
    identity_ids: {
      anyOf: [
        {
          items: {
            type: 'string',
          },
          type: 'array',
        },
        {
          type: 'null',
        },
      ],
      title: 'Identity Ids',
      description: 'The ids of the identities associated with this agent.',
    },
    message_buffer_autoclear: {
      type: 'boolean',
      title: 'Message Buffer Autoclear',
      description:
        'If set to True, the agent will not remember previous messages (though the agent will still retain state via core memory blocks and archival/recall memory). Not recommended unless you have an advanced use case.',
      default: false,
    },
    enable_sleeptime: {
      anyOf: [
        {
          type: 'boolean',
        },
        {
          type: 'null',
        },
      ],
      title: 'Enable Sleeptime',
      description:
        'If set to True, memory management will move to a background agent thread.',
    },
    response_format: {
      anyOf: [
        {
          oneOf: [
            {
              $ref: '#/components/schemas/TextResponseFormat',
            },
            {
              $ref: '#/components/schemas/JsonSchemaResponseFormat',
            },
            {
              $ref: '#/components/schemas/JsonObjectResponseFormat',
            },
          ],
          discriminator: {
            propertyName: 'type',
            mapping: {
              json_object: '#/components/schemas/JsonObjectResponseFormat',
              json_schema: '#/components/schemas/JsonSchemaResponseFormat',
              text: '#/components/schemas/TextResponseFormat',
            },
          },
        },
        {
          type: 'null',
        },
      ],
      title: 'Response Format',
      description: 'The response format for the agent.',
    },
    timezone: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Timezone',
      description: 'The timezone of the agent (IANA format).',
    },
    max_files_open: {
      anyOf: [
        {
          type: 'integer',
        },
        {
          type: 'null',
        },
      ],
      title: 'Max Files Open',
      description:
        'Maximum number of files that can be open at once for this agent. Setting this too high may exceed the context window, which will break the agent.',
    },
    per_file_view_window_char_limit: {
      anyOf: [
        {
          type: 'integer',
        },
        {
          type: 'null',
        },
      ],
      title: 'Per File View Window Char Limit',
      description:
        'The per-file view window character limit for this agent. Setting this too high may exceed the context window, which will break the agent.',
    },
    hidden: {
      anyOf: [
        {
          type: 'boolean',
        },
        {
          type: 'null',
        },
      ],
      title: 'Hidden',
      description: 'If set to True, the agent will be hidden.',
    },
    actor_id: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Actor Id',
    },
  },
  type: 'object',
  title: 'CreateAgentRequest',
  description:
    'CreateAgent model specifically for POST request body, excluding user_id which comes from headers',
} as const;

export const $CreateArchivalMemory = {
  properties: {
    text: {
      type: 'string',
      title: 'Text',
      description: 'Text to write to archival memory.',
    },
    tags: {
      anyOf: [
        {
          items: {
            type: 'string',
          },
          type: 'array',
        },
        {
          type: 'null',
        },
      ],
      title: 'Tags',
      description: 'Optional list of tags to attach to the memory.',
    },
    created_at: {
      anyOf: [
        {
          type: 'string',
          format: 'date-time',
        },
        {
          type: 'null',
        },
      ],
      title: 'Created At',
      description:
        'Optional timestamp for the memory (defaults to current UTC time).',
    },
  },
  type: 'object',
  required: ['text'],
  title: 'CreateArchivalMemory',
} as const;

export const $CreateBatch = {
  properties: {
    requests: {
      items: {
        $ref: '#/components/schemas/LettaBatchRequest',
      },
      type: 'array',
      title: 'Requests',
      description: 'List of requests to be processed in batch.',
    },
    callback_url: {
      anyOf: [
        {
          type: 'string',
          maxLength: 2083,
          minLength: 1,
          format: 'uri',
        },
        {
          type: 'null',
        },
      ],
      title: 'Callback Url',
      description:
        "Optional URL to call via POST when the batch completes. The callback payload will be a JSON object with the following fields: {'job_id': string, 'status': string, 'completed_at': string}. Where 'job_id' is the unique batch job identifier, 'status' is the final batch status (e.g., 'completed', 'failed'), and 'completed_at' is an ISO 8601 timestamp indicating when the batch job completed.",
    },
  },
  type: 'object',
  required: ['requests'],
  title: 'CreateBatch',
} as const;

export const $CreateBlock = {
  properties: {
    value: {
      type: 'string',
      title: 'Value',
      description: 'Value of the block.',
    },
    limit: {
      type: 'integer',
      title: 'Limit',
      description: 'Character limit of the block.',
      default: 20000,
    },
    project_id: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Project Id',
      description: 'The associated project id.',
    },
    name: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Name',
      description: 'The id of the template.',
    },
    is_template: {
      type: 'boolean',
      title: 'Is Template',
      default: false,
    },
    base_template_id: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Base Template Id',
      description: 'The base template id of the block.',
    },
    deployment_id: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Deployment Id',
      description: 'The id of the deployment.',
    },
    entity_id: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Entity Id',
      description: 'The id of the entity within the template.',
    },
    preserve_on_migration: {
      anyOf: [
        {
          type: 'boolean',
        },
        {
          type: 'null',
        },
      ],
      title: 'Preserve On Migration',
      description: 'Preserve the block on template migration.',
      default: false,
    },
    label: {
      type: 'string',
      title: 'Label',
      description: 'Label of the block.',
    },
    read_only: {
      type: 'boolean',
      title: 'Read Only',
      description: 'Whether the agent has read-only access to the block.',
      default: false,
    },
    description: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Description',
      description: 'Description of the block.',
    },
    metadata: {
      anyOf: [
        {
          additionalProperties: true,
          type: 'object',
        },
        {
          type: 'null',
        },
      ],
      title: 'Metadata',
      description: 'Metadata of the block.',
      default: {},
    },
    hidden: {
      anyOf: [
        {
          type: 'boolean',
        },
        {
          type: 'null',
        },
      ],
      title: 'Hidden',
      description: 'If set to True, the block will be hidden.',
    },
  },
  type: 'object',
  required: ['value', 'label'],
  title: 'CreateBlock',
  description: 'Create a block',
} as const;

export const $DeleteDeploymentResponse = {
  properties: {
    deleted_blocks: {
      items: {
        type: 'string',
      },
      type: 'array',
      title: 'Deleted Blocks',
      default: [],
    },
    deleted_agents: {
      items: {
        type: 'string',
      },
      type: 'array',
      title: 'Deleted Agents',
      default: [],
    },
    deleted_groups: {
      items: {
        type: 'string',
      },
      type: 'array',
      title: 'Deleted Groups',
      default: [],
    },
    message: {
      type: 'string',
      title: 'Message',
    },
  },
  type: 'object',
  required: ['message'],
  title: 'DeleteDeploymentResponse',
  description: 'Response model for delete deployment operation.',
} as const;

export const $DeploymentEntity = {
  properties: {
    id: {
      type: 'string',
      title: 'Id',
    },
    type: {
      type: 'string',
      title: 'Type',
    },
    name: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Name',
    },
    description: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Description',
    },
    entity_id: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Entity Id',
    },
    project_id: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Project Id',
    },
  },
  type: 'object',
  required: ['id', 'type'],
  title: 'DeploymentEntity',
  description: 'A deployment entity.',
} as const;

export const $DuplicateFileHandling = {
  type: 'string',
  enum: ['skip', 'error', 'suffix', 'replace'],
  title: 'DuplicateFileHandling',
  description: 'How to handle duplicate filenames when uploading files',
} as const;

export const $DynamicManager = {
  properties: {
    manager_type: {
      type: 'string',
      const: 'dynamic',
      title: 'Manager Type',
      description: '',
      default: 'dynamic',
    },
    manager_agent_id: {
      type: 'string',
      title: 'Manager Agent Id',
      description: '',
    },
    termination_token: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Termination Token',
      description: '',
      default: 'DONE!',
    },
    max_turns: {
      anyOf: [
        {
          type: 'integer',
        },
        {
          type: 'null',
        },
      ],
      title: 'Max Turns',
      description: '',
    },
  },
  type: 'object',
  required: ['manager_agent_id'],
  title: 'DynamicManager',
} as const;

export const $DynamicManagerUpdate = {
  properties: {
    manager_type: {
      type: 'string',
      const: 'dynamic',
      title: 'Manager Type',
      description: '',
      default: 'dynamic',
    },
    manager_agent_id: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Manager Agent Id',
      description: '',
    },
    termination_token: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Termination Token',
      description: '',
    },
    max_turns: {
      anyOf: [
        {
          type: 'integer',
        },
        {
          type: 'null',
        },
      ],
      title: 'Max Turns',
      description: '',
    },
  },
  type: 'object',
  title: 'DynamicManagerUpdate',
} as const;

export const $E2BSandboxConfig = {
  properties: {
    timeout: {
      type: 'integer',
      title: 'Timeout',
      description: 'Time limit for the sandbox (in seconds).',
      default: 300,
    },
    template: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Template',
      description: 'The E2B template id (docker image).',
    },
    pip_requirements: {
      anyOf: [
        {
          items: {
            type: 'string',
          },
          type: 'array',
        },
        {
          type: 'null',
        },
      ],
      title: 'Pip Requirements',
      description: 'A list of pip packages to install on the E2B Sandbox',
    },
  },
  type: 'object',
  title: 'E2BSandboxConfig',
} as const;

export const $EmbeddingConfig = {
  properties: {
    embedding_endpoint_type: {
      type: 'string',
      enum: [
        'openai',
        'anthropic',
        'bedrock',
        'google_ai',
        'google_vertex',
        'azure',
        'groq',
        'ollama',
        'webui',
        'webui-legacy',
        'lmstudio',
        'lmstudio-legacy',
        'llamacpp',
        'koboldcpp',
        'vllm',
        'hugging-face',
        'mistral',
        'together',
        'pinecone',
      ],
      title: 'Embedding Endpoint Type',
      description: 'The endpoint type for the model.',
    },
    embedding_endpoint: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Embedding Endpoint',
      description: 'The endpoint for the model (`None` if local).',
    },
    embedding_model: {
      type: 'string',
      title: 'Embedding Model',
      description: 'The model for the embedding.',
    },
    embedding_dim: {
      type: 'integer',
      title: 'Embedding Dim',
      description: 'The dimension of the embedding.',
    },
    embedding_chunk_size: {
      anyOf: [
        {
          type: 'integer',
        },
        {
          type: 'null',
        },
      ],
      title: 'Embedding Chunk Size',
      description: 'The chunk size of the embedding.',
      default: 300,
    },
    handle: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Handle',
      description:
        'The handle for this config, in the format provider/model-name.',
    },
    batch_size: {
      type: 'integer',
      title: 'Batch Size',
      description: 'The maximum batch size for processing embeddings.',
      default: 32,
    },
    azure_endpoint: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Azure Endpoint',
      description: 'The Azure endpoint for the model.',
    },
    azure_version: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Azure Version',
      description: 'The Azure version for the model.',
    },
    azure_deployment: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Azure Deployment',
      description: 'The Azure deployment for the model.',
    },
  },
  type: 'object',
  required: ['embedding_endpoint_type', 'embedding_model', 'embedding_dim'],
  title: 'EmbeddingConfig',
  description:
    'Configuration for embedding model connection and processing parameters.',
} as const;

export const $FeedbackType = {
  type: 'string',
  enum: ['positive', 'negative'],
  title: 'FeedbackType',
} as const;

export const $FileAgentSchema = {
  properties: {
    agent_id: {
      type: 'string',
      title: 'Agent Id',
      description: 'Unique identifier of the agent.',
    },
    file_id: {
      type: 'string',
      title: 'File Id',
      description: 'Unique identifier of the file.',
    },
    source_id: {
      type: 'string',
      title: 'Source Id',
      description: 'Unique identifier of the source.',
    },
    file_name: {
      type: 'string',
      title: 'File Name',
      description: 'Name of the file.',
    },
    is_open: {
      type: 'boolean',
      title: 'Is Open',
      description: 'True if the agent currently has the file open.',
      default: true,
    },
    visible_content: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Visible Content',
      description:
        'Portion of the file the agent is focused on (may be large).',
    },
    last_accessed_at: {
      anyOf: [
        {
          type: 'string',
          format: 'date-time',
        },
        {
          type: 'null',
        },
      ],
      title: 'Last Accessed At',
      description:
        "UTC timestamp of the agent's most recent access to this file.",
    },
    start_line: {
      anyOf: [
        {
          type: 'integer',
        },
        {
          type: 'null',
        },
      ],
      title: 'Start Line',
      description:
        'Starting line number (1-indexed) when file was opened with line range.',
    },
    end_line: {
      anyOf: [
        {
          type: 'integer',
        },
        {
          type: 'null',
        },
      ],
      title: 'End Line',
      description:
        'Ending line number (exclusive) when file was opened with line range.',
    },
    id: {
      type: 'string',
      title: 'Id',
      description:
        'Human-readable identifier for this file-agent relationship in the file',
    },
  },
  additionalProperties: false,
  type: 'object',
  required: ['agent_id', 'file_id', 'source_id', 'file_name', 'id'],
  title: 'FileAgentSchema',
  description: 'File-Agent relationship with human-readable ID for agent file',
} as const;

export const $FileBlock = {
  properties: {
    value: {
      type: 'string',
      title: 'Value',
      description: 'Value of the block.',
    },
    limit: {
      type: 'integer',
      title: 'Limit',
      description: 'Character limit of the block.',
      default: 20000,
    },
    project_id: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Project Id',
      description: 'The associated project id.',
    },
    name: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Name',
      description: 'The id of the template.',
    },
    is_template: {
      type: 'boolean',
      title: 'Is Template',
      description:
        'Whether the block is a template (e.g. saved human/persona options).',
      default: false,
    },
    base_template_id: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Base Template Id',
      description: 'The base template id of the block.',
    },
    deployment_id: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Deployment Id',
      description: 'The id of the deployment.',
    },
    entity_id: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Entity Id',
      description: 'The id of the entity within the template.',
    },
    preserve_on_migration: {
      anyOf: [
        {
          type: 'boolean',
        },
        {
          type: 'null',
        },
      ],
      title: 'Preserve On Migration',
      description: 'Preserve the block on template migration.',
      default: false,
    },
    label: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Label',
      description:
        "Label of the block (e.g. 'human', 'persona') in the context window.",
    },
    read_only: {
      type: 'boolean',
      title: 'Read Only',
      description: 'Whether the agent has read-only access to the block.',
      default: false,
    },
    description: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Description',
      description: 'Description of the block.',
    },
    metadata: {
      anyOf: [
        {
          additionalProperties: true,
          type: 'object',
        },
        {
          type: 'null',
        },
      ],
      title: 'Metadata',
      description: 'Metadata of the block.',
      default: {},
    },
    hidden: {
      anyOf: [
        {
          type: 'boolean',
        },
        {
          type: 'null',
        },
      ],
      title: 'Hidden',
      description: 'If set to True, the block will be hidden.',
    },
    id: {
      type: 'string',
      pattern: '^block-[a-fA-F0-9]{8}',
      title: 'Id',
      description: 'The human-friendly ID of the Block',
      examples: ['block-123e4567-e89b-12d3-a456-426614174000'],
    },
    created_by_id: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Created By Id',
      description: 'The id of the user that made this Block.',
    },
    last_updated_by_id: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Last Updated By Id',
      description: 'The id of the user that last updated this Block.',
    },
    file_id: {
      type: 'string',
      title: 'File Id',
      description: 'Unique identifier of the file.',
    },
    source_id: {
      type: 'string',
      title: 'Source Id',
      description: 'Unique identifier of the source.',
    },
    is_open: {
      type: 'boolean',
      title: 'Is Open',
      description: 'True if the agent currently has the file open.',
    },
    last_accessed_at: {
      anyOf: [
        {
          type: 'string',
          format: 'date-time',
        },
        {
          type: 'null',
        },
      ],
      title: 'Last Accessed At',
      description:
        'UTC timestamp of the agent’s most recent access to this file. Any operations from the open, close, or search tools will update this field.',
    },
  },
  type: 'object',
  required: ['value', 'file_id', 'source_id', 'is_open'],
  title: 'FileBlock',
} as const;

export const $FileMetadata = {
  properties: {
    source_id: {
      type: 'string',
      title: 'Source Id',
      description:
        'The unique identifier of the source associated with the document.',
    },
    file_name: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'File Name',
      description: 'The name of the file.',
    },
    original_file_name: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Original File Name',
      description: 'The original name of the file as uploaded.',
    },
    file_path: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'File Path',
      description: 'The path to the file.',
    },
    file_type: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'File Type',
      description: 'The type of the file (MIME type).',
    },
    file_size: {
      anyOf: [
        {
          type: 'integer',
        },
        {
          type: 'null',
        },
      ],
      title: 'File Size',
      description: 'The size of the file in bytes.',
    },
    file_creation_date: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'File Creation Date',
      description: 'The creation date of the file.',
    },
    file_last_modified_date: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'File Last Modified Date',
      description: 'The last modified date of the file.',
    },
    processing_status: {
      $ref: '#/components/schemas/FileProcessingStatus',
      description:
        'The current processing status of the file (e.g. pending, parsing, embedding, completed, error).',
      default: 'pending',
    },
    error_message: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Error Message',
      description: 'Optional error message if the file failed processing.',
    },
    total_chunks: {
      anyOf: [
        {
          type: 'integer',
        },
        {
          type: 'null',
        },
      ],
      title: 'Total Chunks',
      description: 'Total number of chunks for the file.',
    },
    chunks_embedded: {
      anyOf: [
        {
          type: 'integer',
        },
        {
          type: 'null',
        },
      ],
      title: 'Chunks Embedded',
      description: 'Number of chunks that have been embedded.',
    },
    content: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Content',
      description:
        'Optional full-text content of the file; only populated on demand due to its size.',
    },
    id: {
      type: 'string',
      pattern: '^file-[a-fA-F0-9]{8}',
      title: 'Id',
      description: 'The human-friendly ID of the File',
      examples: ['file-123e4567-e89b-12d3-a456-426614174000'],
    },
    organization_id: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Organization Id',
      description:
        'The unique identifier of the organization associated with the document.',
    },
    created_at: {
      anyOf: [
        {
          type: 'string',
          format: 'date-time',
        },
        {
          type: 'null',
        },
      ],
      title: 'Created At',
      description: 'The creation date of the file.',
    },
    updated_at: {
      anyOf: [
        {
          type: 'string',
          format: 'date-time',
        },
        {
          type: 'null',
        },
      ],
      title: 'Updated At',
      description: 'The update date of the file.',
    },
  },
  additionalProperties: false,
  type: 'object',
  required: ['source_id'],
  title: 'FileMetadata',
  description: 'Representation of a single FileMetadata',
} as const;

export const $FileProcessingStatus = {
  type: 'string',
  enum: ['pending', 'parsing', 'embedding', 'completed', 'error'],
  title: 'FileProcessingStatus',
} as const;

export const $FileSchema = {
  properties: {
    source_id: {
      type: 'string',
      title: 'Source Id',
      description:
        'The unique identifier of the source associated with the document.',
    },
    file_name: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'File Name',
      description: 'The name of the file.',
    },
    original_file_name: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Original File Name',
      description: 'The original name of the file as uploaded.',
    },
    file_path: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'File Path',
      description: 'The path to the file.',
    },
    file_type: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'File Type',
      description: 'The type of the file (MIME type).',
    },
    file_size: {
      anyOf: [
        {
          type: 'integer',
        },
        {
          type: 'null',
        },
      ],
      title: 'File Size',
      description: 'The size of the file in bytes.',
    },
    file_creation_date: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'File Creation Date',
      description: 'The creation date of the file.',
    },
    file_last_modified_date: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'File Last Modified Date',
      description: 'The last modified date of the file.',
    },
    processing_status: {
      $ref: '#/components/schemas/FileProcessingStatus',
      description:
        'The current processing status of the file (e.g. pending, parsing, embedding, completed, error).',
      default: 'pending',
    },
    error_message: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Error Message',
      description: 'Optional error message if the file failed processing.',
    },
    total_chunks: {
      anyOf: [
        {
          type: 'integer',
        },
        {
          type: 'null',
        },
      ],
      title: 'Total Chunks',
      description: 'Total number of chunks for the file.',
    },
    chunks_embedded: {
      anyOf: [
        {
          type: 'integer',
        },
        {
          type: 'null',
        },
      ],
      title: 'Chunks Embedded',
      description: 'Number of chunks that have been embedded.',
    },
    content: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Content',
      description:
        'Optional full-text content of the file; only populated on demand due to its size.',
    },
    id: {
      type: 'string',
      title: 'Id',
      description: 'Human-readable identifier for this file in the file',
    },
  },
  additionalProperties: false,
  type: 'object',
  required: ['source_id', 'id'],
  title: 'FileSchema',
  description: 'File with human-readable ID for agent file',
} as const;

export const $FileStats = {
  properties: {
    file_id: {
      type: 'string',
      title: 'File Id',
      description: 'Unique identifier of the file',
    },
    file_name: {
      type: 'string',
      title: 'File Name',
      description: 'Name of the file',
    },
    file_size: {
      anyOf: [
        {
          type: 'integer',
        },
        {
          type: 'null',
        },
      ],
      title: 'File Size',
      description: 'Size of the file in bytes',
    },
  },
  additionalProperties: false,
  type: 'object',
  required: ['file_id', 'file_name'],
  title: 'FileStats',
  description: 'File statistics for metadata endpoint',
} as const;

export const $Folder = {
  properties: {
    name: {
      type: 'string',
      title: 'Name',
      description: 'The name of the folder.',
    },
    description: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Description',
      description: 'The description of the folder.',
    },
    instructions: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Instructions',
      description: 'Instructions for how to use the folder.',
    },
    metadata: {
      anyOf: [
        {
          additionalProperties: true,
          type: 'object',
        },
        {
          type: 'null',
        },
      ],
      title: 'Metadata',
      description: 'Metadata associated with the folder.',
    },
    id: {
      type: 'string',
      pattern: '^source-[a-fA-F0-9]{8}',
      title: 'Id',
      description: 'The human-friendly ID of the Source',
      examples: ['source-123e4567-e89b-12d3-a456-426614174000'],
    },
    embedding_config: {
      $ref: '#/components/schemas/EmbeddingConfig',
      description: 'The embedding configuration used by the folder.',
    },
    organization_id: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Organization Id',
      description: 'The ID of the organization that created the folder.',
    },
    created_by_id: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Created By Id',
      description: 'The id of the user that made this Tool.',
    },
    last_updated_by_id: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Last Updated By Id',
      description: 'The id of the user that made this Tool.',
    },
    created_at: {
      anyOf: [
        {
          type: 'string',
          format: 'date-time',
        },
        {
          type: 'null',
        },
      ],
      title: 'Created At',
      description: 'The timestamp when the folder was created.',
    },
    updated_at: {
      anyOf: [
        {
          type: 'string',
          format: 'date-time',
        },
        {
          type: 'null',
        },
      ],
      title: 'Updated At',
      description: 'The timestamp when the folder was last updated.',
    },
  },
  additionalProperties: false,
  type: 'object',
  required: ['name', 'embedding_config'],
  title: 'Folder',
  description: `Representation of a folder, which is a collection of files and passages.

Parameters:
    id (str): The ID of the folder
    name (str): The name of the folder.
    embedding_config (EmbeddingConfig): The embedding configuration used by the folder.
    user_id (str): The ID of the user that created the folder.
    metadata (dict): Metadata associated with the folder.
    description (str): The description of the folder.`,
} as const;

export const $Function = {
  properties: {
    arguments: {
      type: 'string',
      title: 'Arguments',
    },
    name: {
      type: 'string',
      title: 'Name',
    },
  },
  additionalProperties: true,
  type: 'object',
  required: ['arguments', 'name'],
  title: 'Function',
} as const;

export const $FunctionDefinition = {
  properties: {
    name: {
      type: 'string',
      title: 'Name',
    },
    description: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Description',
    },
    parameters: {
      anyOf: [
        {
          additionalProperties: true,
          type: 'object',
        },
        {
          type: 'null',
        },
      ],
      title: 'Parameters',
    },
    strict: {
      anyOf: [
        {
          type: 'boolean',
        },
        {
          type: 'null',
        },
      ],
      title: 'Strict',
    },
  },
  additionalProperties: true,
  type: 'object',
  required: ['name'],
  title: 'FunctionDefinition',
} as const;

export const $FunctionTool = {
  properties: {
    function: {
      $ref: '#/components/schemas/FunctionDefinition',
    },
    type: {
      type: 'string',
      const: 'function',
      title: 'Type',
    },
  },
  additionalProperties: true,
  type: 'object',
  required: ['function', 'type'],
  title: 'FunctionTool',
} as const;

export const $GenerateToolInput = {
  properties: {
    tool_name: {
      type: 'string',
      title: 'Tool Name',
      description: 'Name of the tool to generate code for',
    },
    prompt: {
      type: 'string',
      title: 'Prompt',
      description: 'User prompt to generate code',
    },
    handle: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Handle',
      description: 'Handle of the tool to generate code for',
    },
    starter_code: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Starter Code',
      description: 'Python source code to parse for JSON schema',
    },
    validation_errors: {
      items: {
        type: 'string',
      },
      type: 'array',
      title: 'Validation Errors',
      description: 'List of validation errors',
    },
  },
  type: 'object',
  required: ['tool_name', 'prompt', 'validation_errors'],
  title: 'GenerateToolInput',
} as const;

export const $GenerateToolOutput = {
  properties: {
    tool: {
      $ref: '#/components/schemas/Tool',
      description: 'Generated tool',
    },
    sample_args: {
      additionalProperties: true,
      type: 'object',
      title: 'Sample Args',
      description: 'Sample arguments for the tool',
    },
    response: {
      type: 'string',
      title: 'Response',
      description: 'Response from the assistant',
    },
  },
  type: 'object',
  required: ['tool', 'sample_args', 'response'],
  title: 'GenerateToolOutput',
} as const;

export const $Group = {
  properties: {
    id: {
      type: 'string',
      title: 'Id',
      description: 'The id of the group. Assigned by the database.',
    },
    manager_type: {
      $ref: '#/components/schemas/ManagerType',
      description: '',
    },
    agent_ids: {
      items: {
        type: 'string',
      },
      type: 'array',
      title: 'Agent Ids',
      description: '',
    },
    description: {
      type: 'string',
      title: 'Description',
      description: '',
    },
    project_id: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Project Id',
      description: 'The associated project id.',
    },
    template_id: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Template Id',
      description: 'The id of the template.',
    },
    base_template_id: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Base Template Id',
      description: 'The base template id.',
    },
    deployment_id: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Deployment Id',
      description: 'The id of the deployment.',
    },
    shared_block_ids: {
      items: {
        type: 'string',
      },
      type: 'array',
      title: 'Shared Block Ids',
      description: '',
      default: [],
    },
    manager_agent_id: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Manager Agent Id',
      description: '',
    },
    termination_token: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Termination Token',
      description: '',
    },
    max_turns: {
      anyOf: [
        {
          type: 'integer',
        },
        {
          type: 'null',
        },
      ],
      title: 'Max Turns',
      description: '',
    },
    sleeptime_agent_frequency: {
      anyOf: [
        {
          type: 'integer',
        },
        {
          type: 'null',
        },
      ],
      title: 'Sleeptime Agent Frequency',
      description: '',
    },
    turns_counter: {
      anyOf: [
        {
          type: 'integer',
        },
        {
          type: 'null',
        },
      ],
      title: 'Turns Counter',
      description: '',
    },
    last_processed_message_id: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Last Processed Message Id',
      description: '',
    },
    max_message_buffer_length: {
      anyOf: [
        {
          type: 'integer',
        },
        {
          type: 'null',
        },
      ],
      title: 'Max Message Buffer Length',
      description:
        'The desired maximum length of messages in the context window of the convo agent. This is a best effort, and may be off slightly due to user/assistant interleaving.',
    },
    min_message_buffer_length: {
      anyOf: [
        {
          type: 'integer',
        },
        {
          type: 'null',
        },
      ],
      title: 'Min Message Buffer Length',
      description:
        'The desired minimum length of messages in the context window of the convo agent. This is a best effort, and may be off-by-one due to user/assistant interleaving.',
    },
    hidden: {
      anyOf: [
        {
          type: 'boolean',
        },
        {
          type: 'null',
        },
      ],
      title: 'Hidden',
      description: 'If set to True, the group will be hidden.',
    },
  },
  additionalProperties: false,
  type: 'object',
  required: ['id', 'manager_type', 'agent_ids', 'description'],
  title: 'Group',
} as const;

export const $GroupCreate = {
  properties: {
    agent_ids: {
      items: {
        type: 'string',
      },
      type: 'array',
      title: 'Agent Ids',
      description: '',
    },
    description: {
      type: 'string',
      title: 'Description',
      description: '',
    },
    manager_config: {
      oneOf: [
        {
          $ref: '#/components/schemas/RoundRobinManager',
        },
        {
          $ref: '#/components/schemas/SupervisorManager',
        },
        {
          $ref: '#/components/schemas/DynamicManager',
        },
        {
          $ref: '#/components/schemas/SleeptimeManager',
        },
        {
          $ref: '#/components/schemas/VoiceSleeptimeManager',
        },
      ],
      title: 'Manager Config',
      description: '',
      default: {
        manager_type: 'round_robin',
      },
      discriminator: {
        propertyName: 'manager_type',
        mapping: {
          dynamic: '#/components/schemas/DynamicManager',
          round_robin: '#/components/schemas/RoundRobinManager',
          sleeptime: '#/components/schemas/SleeptimeManager',
          supervisor: '#/components/schemas/SupervisorManager',
          voice_sleeptime: '#/components/schemas/VoiceSleeptimeManager',
        },
      },
    },
    project_id: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Project Id',
      description: 'The associated project id.',
    },
    shared_block_ids: {
      items: {
        type: 'string',
      },
      type: 'array',
      title: 'Shared Block Ids',
      description: '',
      default: [],
    },
    hidden: {
      anyOf: [
        {
          type: 'boolean',
        },
        {
          type: 'null',
        },
      ],
      title: 'Hidden',
      description: 'If set to True, the group will be hidden.',
    },
  },
  type: 'object',
  required: ['agent_ids', 'description'],
  title: 'GroupCreate',
} as const;

export const $GroupSchema = {
  properties: {
    agent_ids: {
      items: {
        type: 'string',
      },
      type: 'array',
      title: 'Agent Ids',
      description: '',
    },
    description: {
      type: 'string',
      title: 'Description',
      description: '',
    },
    manager_config: {
      oneOf: [
        {
          $ref: '#/components/schemas/RoundRobinManager',
        },
        {
          $ref: '#/components/schemas/SupervisorManager',
        },
        {
          $ref: '#/components/schemas/DynamicManager',
        },
        {
          $ref: '#/components/schemas/SleeptimeManager',
        },
        {
          $ref: '#/components/schemas/VoiceSleeptimeManager',
        },
      ],
      title: 'Manager Config',
      description: '',
      default: {
        manager_type: 'round_robin',
      },
      discriminator: {
        propertyName: 'manager_type',
        mapping: {
          dynamic: '#/components/schemas/DynamicManager',
          round_robin: '#/components/schemas/RoundRobinManager',
          sleeptime: '#/components/schemas/SleeptimeManager',
          supervisor: '#/components/schemas/SupervisorManager',
          voice_sleeptime: '#/components/schemas/VoiceSleeptimeManager',
        },
      },
    },
    project_id: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Project Id',
      description: 'The associated project id.',
    },
    shared_block_ids: {
      items: {
        type: 'string',
      },
      type: 'array',
      title: 'Shared Block Ids',
      description: '',
      default: [],
    },
    hidden: {
      anyOf: [
        {
          type: 'boolean',
        },
        {
          type: 'null',
        },
      ],
      title: 'Hidden',
      description: 'If set to True, the group will be hidden.',
    },
    id: {
      type: 'string',
      title: 'Id',
      description: 'Human-readable identifier for this group in the file',
    },
  },
  type: 'object',
  required: ['agent_ids', 'description', 'id'],
  title: 'GroupSchema',
  description: 'Group with human-readable ID for agent file',
} as const;

export const $GroupUpdate = {
  properties: {
    agent_ids: {
      anyOf: [
        {
          items: {
            type: 'string',
          },
          type: 'array',
        },
        {
          type: 'null',
        },
      ],
      title: 'Agent Ids',
      description: '',
    },
    description: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Description',
      description: '',
    },
    manager_config: {
      anyOf: [
        {
          oneOf: [
            {
              $ref: '#/components/schemas/RoundRobinManagerUpdate',
            },
            {
              $ref: '#/components/schemas/SupervisorManagerUpdate',
            },
            {
              $ref: '#/components/schemas/DynamicManagerUpdate',
            },
            {
              $ref: '#/components/schemas/SleeptimeManagerUpdate',
            },
            {
              $ref: '#/components/schemas/VoiceSleeptimeManagerUpdate',
            },
          ],
          discriminator: {
            propertyName: 'manager_type',
            mapping: {
              dynamic: '#/components/schemas/DynamicManagerUpdate',
              round_robin: '#/components/schemas/RoundRobinManagerUpdate',
              sleeptime: '#/components/schemas/SleeptimeManagerUpdate',
              supervisor: '#/components/schemas/SupervisorManagerUpdate',
              voice_sleeptime:
                '#/components/schemas/VoiceSleeptimeManagerUpdate',
            },
          },
        },
        {
          type: 'null',
        },
      ],
      title: 'Manager Config',
      description: '',
    },
    project_id: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Project Id',
      description: 'The associated project id.',
    },
    shared_block_ids: {
      anyOf: [
        {
          items: {
            type: 'string',
          },
          type: 'array',
        },
        {
          type: 'null',
        },
      ],
      title: 'Shared Block Ids',
      description: '',
    },
  },
  type: 'object',
  title: 'GroupUpdate',
} as const;

export const $HTTPValidationError = {
  properties: {
    detail: {
      items: {
        $ref: '#/components/schemas/ValidationError',
      },
      type: 'array',
      title: 'Detail',
    },
  },
  type: 'object',
  title: 'HTTPValidationError',
} as const;

export const $Health = {
  properties: {
    version: {
      type: 'string',
      title: 'Version',
    },
    status: {
      type: 'string',
      title: 'Status',
    },
  },
  type: 'object',
  required: ['version', 'status'],
  title: 'Health',
  description: 'Health check response body',
} as const;

export const $HiddenReasoningMessage = {
  properties: {
    id: {
      type: 'string',
      title: 'Id',
    },
    date: {
      type: 'string',
      format: 'date-time',
      title: 'Date',
    },
    name: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Name',
    },
    message_type: {
      type: 'string',
      const: 'hidden_reasoning_message',
      title: 'Message Type',
      description: 'The type of the message.',
      default: 'hidden_reasoning_message',
    },
    otid: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Otid',
    },
    sender_id: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Sender Id',
    },
    step_id: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Step Id',
    },
    is_err: {
      anyOf: [
        {
          type: 'boolean',
        },
        {
          type: 'null',
        },
      ],
      title: 'Is Err',
    },
    seq_id: {
      anyOf: [
        {
          type: 'integer',
        },
        {
          type: 'null',
        },
      ],
      title: 'Seq Id',
    },
    run_id: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Run Id',
    },
    state: {
      type: 'string',
      enum: ['redacted', 'omitted'],
      title: 'State',
    },
    hidden_reasoning: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Hidden Reasoning',
    },
  },
  type: 'object',
  required: ['id', 'date', 'state'],
  title: 'HiddenReasoningMessage',
  description: `Representation of an agent's internal reasoning where reasoning content
has been hidden from the response.

Args:
    id (str): The ID of the message
    date (datetime): The date the message was created in ISO format
    name (Optional[str]): The name of the sender of the message
    state (Literal["redacted", "omitted"]): Whether the reasoning
        content was redacted by the provider or simply omitted by the API
    hidden_reasoning (Optional[str]): The internal reasoning of the agent`,
} as const;

export const $Identity = {
  properties: {
    id: {
      type: 'string',
      pattern: '^identity-[a-fA-F0-9]{8}',
      title: 'Id',
      description: 'The human-friendly ID of the Identity',
      examples: ['identity-123e4567-e89b-12d3-a456-426614174000'],
    },
    identifier_key: {
      type: 'string',
      title: 'Identifier Key',
      description: 'External, user-generated identifier key of the identity.',
    },
    name: {
      type: 'string',
      title: 'Name',
      description: 'The name of the identity.',
    },
    identity_type: {
      $ref: '#/components/schemas/IdentityType',
      description: 'The type of the identity.',
    },
    project_id: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Project Id',
      description: 'The project id of the identity, if applicable.',
    },
    agent_ids: {
      items: {
        type: 'string',
      },
      type: 'array',
      title: 'Agent Ids',
      description: 'The IDs of the agents associated with the identity.',
    },
    block_ids: {
      items: {
        type: 'string',
      },
      type: 'array',
      title: 'Block Ids',
      description: 'The IDs of the blocks associated with the identity.',
    },
    organization_id: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Organization Id',
      description: 'The organization id of the user',
    },
    properties: {
      items: {
        $ref: '#/components/schemas/IdentityProperty',
      },
      type: 'array',
      title: 'Properties',
      description: 'List of properties associated with the identity',
    },
  },
  additionalProperties: false,
  type: 'object',
  required: [
    'identifier_key',
    'name',
    'identity_type',
    'agent_ids',
    'block_ids',
  ],
  title: 'Identity',
} as const;

export const $IdentityCreate = {
  properties: {
    identifier_key: {
      type: 'string',
      title: 'Identifier Key',
      description: 'External, user-generated identifier key of the identity.',
    },
    name: {
      type: 'string',
      title: 'Name',
      description: 'The name of the identity.',
    },
    identity_type: {
      $ref: '#/components/schemas/IdentityType',
      description: 'The type of the identity.',
    },
    project_id: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Project Id',
      description: 'The project id of the identity, if applicable.',
    },
    agent_ids: {
      anyOf: [
        {
          items: {
            type: 'string',
          },
          type: 'array',
        },
        {
          type: 'null',
        },
      ],
      title: 'Agent Ids',
      description: 'The agent ids that are associated with the identity.',
    },
    block_ids: {
      anyOf: [
        {
          items: {
            type: 'string',
          },
          type: 'array',
        },
        {
          type: 'null',
        },
      ],
      title: 'Block Ids',
      description: 'The IDs of the blocks associated with the identity.',
    },
    properties: {
      anyOf: [
        {
          items: {
            $ref: '#/components/schemas/IdentityProperty',
          },
          type: 'array',
        },
        {
          type: 'null',
        },
      ],
      title: 'Properties',
      description: 'List of properties associated with the identity.',
    },
  },
  additionalProperties: false,
  type: 'object',
  required: ['identifier_key', 'name', 'identity_type'],
  title: 'IdentityCreate',
} as const;

export const $IdentityProperty = {
  properties: {
    key: {
      type: 'string',
      title: 'Key',
      description: 'The key of the property',
    },
    value: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'integer',
        },
        {
          type: 'number',
        },
        {
          type: 'boolean',
        },
        {
          additionalProperties: true,
          type: 'object',
        },
      ],
      title: 'Value',
      description: 'The value of the property',
    },
    type: {
      $ref: '#/components/schemas/IdentityPropertyType',
      description: 'The type of the property',
    },
  },
  additionalProperties: false,
  type: 'object',
  required: ['key', 'value', 'type'],
  title: 'IdentityProperty',
  description: 'A property of an identity',
} as const;

export const $IdentityPropertyType = {
  type: 'string',
  enum: ['string', 'number', 'boolean', 'json'],
  title: 'IdentityPropertyType',
  description: 'Enum to represent the type of the identity property.',
} as const;

export const $IdentityType = {
  type: 'string',
  enum: ['org', 'user', 'other'],
  title: 'IdentityType',
  description: 'Enum to represent the type of the identity.',
} as const;

export const $IdentityUpdate = {
  properties: {
    identifier_key: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Identifier Key',
      description: 'External, user-generated identifier key of the identity.',
    },
    name: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Name',
      description: 'The name of the identity.',
    },
    identity_type: {
      anyOf: [
        {
          $ref: '#/components/schemas/IdentityType',
        },
        {
          type: 'null',
        },
      ],
      description: 'The type of the identity.',
    },
    agent_ids: {
      anyOf: [
        {
          items: {
            type: 'string',
          },
          type: 'array',
        },
        {
          type: 'null',
        },
      ],
      title: 'Agent Ids',
      description: 'The agent ids that are associated with the identity.',
    },
    block_ids: {
      anyOf: [
        {
          items: {
            type: 'string',
          },
          type: 'array',
        },
        {
          type: 'null',
        },
      ],
      title: 'Block Ids',
      description: 'The IDs of the blocks associated with the identity.',
    },
    properties: {
      anyOf: [
        {
          items: {
            $ref: '#/components/schemas/IdentityProperty',
          },
          type: 'array',
        },
        {
          type: 'null',
        },
      ],
      title: 'Properties',
      description: 'List of properties associated with the identity.',
    },
  },
  additionalProperties: false,
  type: 'object',
  title: 'IdentityUpdate',
} as const;

export const $IdentityUpsert = {
  properties: {
    identifier_key: {
      type: 'string',
      title: 'Identifier Key',
      description: 'External, user-generated identifier key of the identity.',
    },
    name: {
      type: 'string',
      title: 'Name',
      description: 'The name of the identity.',
    },
    identity_type: {
      $ref: '#/components/schemas/IdentityType',
      description: 'The type of the identity.',
    },
    project_id: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Project Id',
      description: 'The project id of the identity, if applicable.',
    },
    agent_ids: {
      anyOf: [
        {
          items: {
            type: 'string',
          },
          type: 'array',
        },
        {
          type: 'null',
        },
      ],
      title: 'Agent Ids',
      description: 'The agent ids that are associated with the identity.',
    },
    block_ids: {
      anyOf: [
        {
          items: {
            type: 'string',
          },
          type: 'array',
        },
        {
          type: 'null',
        },
      ],
      title: 'Block Ids',
      description: 'The IDs of the blocks associated with the identity.',
    },
    properties: {
      anyOf: [
        {
          items: {
            $ref: '#/components/schemas/IdentityProperty',
          },
          type: 'array',
        },
        {
          type: 'null',
        },
      ],
      title: 'Properties',
      description: 'List of properties associated with the identity.',
    },
  },
  additionalProperties: false,
  type: 'object',
  required: ['identifier_key', 'name', 'identity_type'],
  title: 'IdentityUpsert',
} as const;

export const $ImageContent = {
  properties: {
    type: {
      type: 'string',
      const: 'image',
      title: 'Type',
      description: 'The type of the message.',
      default: 'image',
    },
    source: {
      oneOf: [
        {
          $ref: '#/components/schemas/UrlImage',
        },
        {
          $ref: '#/components/schemas/Base64Image',
        },
        {
          $ref: '#/components/schemas/LettaImage',
        },
      ],
      title: 'Source',
      description: 'The source of the image.',
      discriminator: {
        propertyName: 'type',
        mapping: {
          base64: '#/components/schemas/Base64Image',
          letta: '#/components/schemas/LettaImage',
          url: '#/components/schemas/UrlImage',
        },
      },
    },
  },
  type: 'object',
  required: ['source'],
  title: 'ImageContent',
} as const;

export const $ImportedAgentsResponse = {
  properties: {
    agent_ids: {
      items: {
        type: 'string',
      },
      type: 'array',
      title: 'Agent Ids',
      description: 'List of IDs of the imported agents',
    },
  },
  type: 'object',
  required: ['agent_ids'],
  title: 'ImportedAgentsResponse',
  description: 'Response model for imported agents',
} as const;

export const $InitToolRule = {
  properties: {
    tool_name: {
      type: 'string',
      title: 'Tool Name',
      description:
        "The name of the tool. Must exist in the database for the user's organization.",
    },
    type: {
      type: 'string',
      const: 'run_first',
      title: 'Type',
      default: 'run_first',
    },
    prompt_template: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Prompt Template',
      description:
        'Optional template string (ignored). Rendering uses fast built-in formatting for performance.',
    },
    args: {
      anyOf: [
        {
          additionalProperties: true,
          type: 'object',
        },
        {
          type: 'null',
        },
      ],
      title: 'Args',
      description:
        "Optional prefilled arguments for this tool. When present, these values will override any LLM-provided arguments with the same keys during invocation. Keys must match the tool's parameter names and values must satisfy the tool's JSON schema. Supports partial prefill; non-overlapping parameters are left to the model.",
    },
  },
  additionalProperties: false,
  type: 'object',
  required: ['tool_name'],
  title: 'InitToolRule',
  description: 'Represents the initial tool rule configuration.',
} as const;

export const $InternalTemplateAgentCreate = {
  properties: {
    name: {
      type: 'string',
      title: 'Name',
      description: 'The name of the agent.',
    },
    memory_blocks: {
      anyOf: [
        {
          items: {
            $ref: '#/components/schemas/CreateBlock',
          },
          type: 'array',
        },
        {
          type: 'null',
        },
      ],
      title: 'Memory Blocks',
      description: "The blocks to create in the agent's in-context memory.",
    },
    tools: {
      anyOf: [
        {
          items: {
            type: 'string',
          },
          type: 'array',
        },
        {
          type: 'null',
        },
      ],
      title: 'Tools',
      description: 'The tools used by the agent.',
    },
    tool_ids: {
      anyOf: [
        {
          items: {
            type: 'string',
          },
          type: 'array',
        },
        {
          type: 'null',
        },
      ],
      title: 'Tool Ids',
      description: 'The ids of the tools used by the agent.',
    },
    source_ids: {
      anyOf: [
        {
          items: {
            type: 'string',
          },
          type: 'array',
        },
        {
          type: 'null',
        },
      ],
      title: 'Source Ids',
      description: 'The ids of the sources used by the agent.',
    },
    block_ids: {
      anyOf: [
        {
          items: {
            type: 'string',
          },
          type: 'array',
        },
        {
          type: 'null',
        },
      ],
      title: 'Block Ids',
      description: 'The ids of the blocks used by the agent.',
    },
    tool_rules: {
      anyOf: [
        {
          items: {
            oneOf: [
              {
                $ref: '#/components/schemas/ChildToolRule',
              },
              {
                $ref: '#/components/schemas/InitToolRule',
              },
              {
                $ref: '#/components/schemas/TerminalToolRule',
              },
              {
                $ref: '#/components/schemas/ConditionalToolRule',
              },
              {
                $ref: '#/components/schemas/ContinueToolRule',
              },
              {
                $ref: '#/components/schemas/RequiredBeforeExitToolRule',
              },
              {
                $ref: '#/components/schemas/MaxCountPerStepToolRule',
              },
              {
                $ref: '#/components/schemas/ParentToolRule',
              },
              {
                $ref: '#/components/schemas/RequiresApprovalToolRule',
              },
            ],
            discriminator: {
              propertyName: 'type',
              mapping: {
                conditional: '#/components/schemas/ConditionalToolRule',
                constrain_child_tools: '#/components/schemas/ChildToolRule',
                continue_loop: '#/components/schemas/ContinueToolRule',
                exit_loop: '#/components/schemas/TerminalToolRule',
                max_count_per_step:
                  '#/components/schemas/MaxCountPerStepToolRule',
                parent_last_tool: '#/components/schemas/ParentToolRule',
                required_before_exit:
                  '#/components/schemas/RequiredBeforeExitToolRule',
                requires_approval:
                  '#/components/schemas/RequiresApprovalToolRule',
                run_first: '#/components/schemas/InitToolRule',
              },
            },
          },
          type: 'array',
        },
        {
          type: 'null',
        },
      ],
      title: 'Tool Rules',
      description: 'The tool rules governing the agent.',
    },
    tags: {
      anyOf: [
        {
          items: {
            type: 'string',
          },
          type: 'array',
        },
        {
          type: 'null',
        },
      ],
      title: 'Tags',
      description: 'The tags associated with the agent.',
    },
    system: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'System',
      description: 'The system prompt used by the agent.',
    },
    agent_type: {
      $ref: '#/components/schemas/AgentType',
      description: 'The type of agent.',
    },
    llm_config: {
      anyOf: [
        {
          $ref: '#/components/schemas/LLMConfig',
        },
        {
          type: 'null',
        },
      ],
      description: 'The LLM configuration used by the agent.',
    },
    embedding_config: {
      anyOf: [
        {
          $ref: '#/components/schemas/EmbeddingConfig',
        },
        {
          type: 'null',
        },
      ],
      description: 'The embedding configuration used by the agent.',
    },
    initial_message_sequence: {
      anyOf: [
        {
          items: {
            $ref: '#/components/schemas/MessageCreate',
          },
          type: 'array',
        },
        {
          type: 'null',
        },
      ],
      title: 'Initial Message Sequence',
      description:
        "The initial set of messages to put in the agent's in-context memory.",
    },
    include_base_tools: {
      type: 'boolean',
      title: 'Include Base Tools',
      description:
        'If true, attaches the Letta core tools (e.g. core_memory related functions).',
      default: true,
    },
    include_multi_agent_tools: {
      type: 'boolean',
      title: 'Include Multi Agent Tools',
      description:
        'If true, attaches the Letta multi-agent tools (e.g. sending a message to another agent).',
      default: false,
    },
    include_base_tool_rules: {
      anyOf: [
        {
          type: 'boolean',
        },
        {
          type: 'null',
        },
      ],
      title: 'Include Base Tool Rules',
      description:
        'If true, attaches the Letta base tool rules (e.g. deny all tools not explicitly allowed).',
    },
    include_default_source: {
      type: 'boolean',
      title: 'Include Default Source',
      description:
        'If true, automatically creates and attaches a default data source for this agent.',
      default: false,
    },
    description: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Description',
      description: 'The description of the agent.',
    },
    metadata: {
      anyOf: [
        {
          additionalProperties: true,
          type: 'object',
        },
        {
          type: 'null',
        },
      ],
      title: 'Metadata',
      description: 'The metadata of the agent.',
    },
    model: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Model',
      description:
        'The LLM configuration handle used by the agent, specified in the format provider/model-name, as an alternative to specifying llm_config.',
    },
    embedding: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Embedding',
      description:
        'The embedding configuration handle used by the agent, specified in the format provider/model-name.',
    },
    context_window_limit: {
      anyOf: [
        {
          type: 'integer',
        },
        {
          type: 'null',
        },
      ],
      title: 'Context Window Limit',
      description: 'The context window limit used by the agent.',
    },
    embedding_chunk_size: {
      anyOf: [
        {
          type: 'integer',
        },
        {
          type: 'null',
        },
      ],
      title: 'Embedding Chunk Size',
      description: 'The embedding chunk size used by the agent.',
      default: 300,
    },
    max_tokens: {
      anyOf: [
        {
          type: 'integer',
        },
        {
          type: 'null',
        },
      ],
      title: 'Max Tokens',
      description:
        'The maximum number of tokens to generate, including reasoning step. If not set, the model will use its default value.',
    },
    max_reasoning_tokens: {
      anyOf: [
        {
          type: 'integer',
        },
        {
          type: 'null',
        },
      ],
      title: 'Max Reasoning Tokens',
      description:
        'The maximum number of tokens to generate for reasoning step. If not set, the model will use its default value.',
    },
    enable_reasoner: {
      anyOf: [
        {
          type: 'boolean',
        },
        {
          type: 'null',
        },
      ],
      title: 'Enable Reasoner',
      description:
        'Whether to enable internal extended thinking step for a reasoner model.',
      default: true,
    },
    reasoning: {
      anyOf: [
        {
          type: 'boolean',
        },
        {
          type: 'null',
        },
      ],
      title: 'Reasoning',
      description: 'Whether to enable reasoning for this agent.',
    },
    from_template: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'From Template',
      description:
        "Deprecated: please use the 'create agents from a template' endpoint instead.",
    },
    template: {
      type: 'boolean',
      title: 'Template',
      description: 'Deprecated: No longer used',
      default: false,
    },
    project: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Project',
      description:
        'Deprecated: Project should now be passed via the X-Project header instead of in the request body. If using the sdk, this can be done via the new x_project field below.',
      deprecated: true,
    },
    tool_exec_environment_variables: {
      anyOf: [
        {
          additionalProperties: {
            type: 'string',
          },
          type: 'object',
        },
        {
          type: 'null',
        },
      ],
      title: 'Tool Exec Environment Variables',
      description: 'Deprecated: use `secrets` field instead.',
    },
    secrets: {
      anyOf: [
        {
          additionalProperties: {
            type: 'string',
          },
          type: 'object',
        },
        {
          type: 'null',
        },
      ],
      title: 'Secrets',
      description:
        'The environment variables for tool execution specific to this agent.',
    },
    memory_variables: {
      anyOf: [
        {
          additionalProperties: {
            type: 'string',
          },
          type: 'object',
        },
        {
          type: 'null',
        },
      ],
      title: 'Memory Variables',
      description: 'The variables that should be set for the agent.',
    },
    project_id: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Project Id',
      description: 'The id of the project the agent belongs to.',
    },
    template_id: {
      type: 'string',
      title: 'Template Id',
      description: 'The id of the template.',
    },
    base_template_id: {
      type: 'string',
      title: 'Base Template Id',
      description: 'The id of the base template.',
    },
    identity_ids: {
      anyOf: [
        {
          items: {
            type: 'string',
          },
          type: 'array',
        },
        {
          type: 'null',
        },
      ],
      title: 'Identity Ids',
      description: 'The ids of the identities associated with this agent.',
    },
    message_buffer_autoclear: {
      type: 'boolean',
      title: 'Message Buffer Autoclear',
      description:
        'If set to True, the agent will not remember previous messages (though the agent will still retain state via core memory blocks and archival/recall memory). Not recommended unless you have an advanced use case.',
      default: false,
    },
    enable_sleeptime: {
      anyOf: [
        {
          type: 'boolean',
        },
        {
          type: 'null',
        },
      ],
      title: 'Enable Sleeptime',
      description:
        'If set to True, memory management will move to a background agent thread.',
    },
    response_format: {
      anyOf: [
        {
          oneOf: [
            {
              $ref: '#/components/schemas/TextResponseFormat',
            },
            {
              $ref: '#/components/schemas/JsonSchemaResponseFormat',
            },
            {
              $ref: '#/components/schemas/JsonObjectResponseFormat',
            },
          ],
          discriminator: {
            propertyName: 'type',
            mapping: {
              json_object: '#/components/schemas/JsonObjectResponseFormat',
              json_schema: '#/components/schemas/JsonSchemaResponseFormat',
              text: '#/components/schemas/TextResponseFormat',
            },
          },
        },
        {
          type: 'null',
        },
      ],
      title: 'Response Format',
      description: 'The response format for the agent.',
    },
    timezone: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Timezone',
      description: 'The timezone of the agent (IANA format).',
    },
    max_files_open: {
      anyOf: [
        {
          type: 'integer',
        },
        {
          type: 'null',
        },
      ],
      title: 'Max Files Open',
      description:
        'Maximum number of files that can be open at once for this agent. Setting this too high may exceed the context window, which will break the agent.',
    },
    per_file_view_window_char_limit: {
      anyOf: [
        {
          type: 'integer',
        },
        {
          type: 'null',
        },
      ],
      title: 'Per File View Window Char Limit',
      description:
        'The per-file view window character limit for this agent. Setting this too high may exceed the context window, which will break the agent.',
    },
    hidden: {
      anyOf: [
        {
          type: 'boolean',
        },
        {
          type: 'null',
        },
      ],
      title: 'Hidden',
      description: 'If set to True, the agent will be hidden.',
    },
    deployment_id: {
      type: 'string',
      title: 'Deployment Id',
      description: 'The id of the deployment.',
    },
    entity_id: {
      type: 'string',
      title: 'Entity Id',
      description: 'The id of the entity within the template.',
    },
  },
  type: 'object',
  required: ['template_id', 'base_template_id', 'deployment_id', 'entity_id'],
  title: 'InternalTemplateAgentCreate',
  description: 'Used for Letta Cloud',
} as const;

export const $InternalTemplateBlockCreate = {
  properties: {
    value: {
      type: 'string',
      title: 'Value',
      description: 'Value of the block.',
    },
    limit: {
      type: 'integer',
      title: 'Limit',
      description: 'Character limit of the block.',
      default: 20000,
    },
    project_id: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Project Id',
      description: 'The associated project id.',
    },
    name: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Name',
      description: 'Name of the block if it is a template.',
    },
    is_template: {
      type: 'boolean',
      title: 'Is Template',
      default: false,
    },
    template_id: {
      type: 'string',
      title: 'Template Id',
      description: 'The id of the template.',
    },
    base_template_id: {
      type: 'string',
      title: 'Base Template Id',
      description: 'The id of the base template.',
    },
    deployment_id: {
      type: 'string',
      title: 'Deployment Id',
      description: 'The id of the deployment.',
    },
    entity_id: {
      type: 'string',
      title: 'Entity Id',
      description: 'The id of the entity within the template.',
    },
    preserve_on_migration: {
      anyOf: [
        {
          type: 'boolean',
        },
        {
          type: 'null',
        },
      ],
      title: 'Preserve On Migration',
      description: 'Preserve the block on template migration.',
      default: false,
    },
    label: {
      type: 'string',
      title: 'Label',
      description: 'Label of the block.',
    },
    read_only: {
      type: 'boolean',
      title: 'Read Only',
      description: 'Whether the agent has read-only access to the block.',
      default: false,
    },
    description: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Description',
      description: 'Description of the block.',
    },
    metadata: {
      anyOf: [
        {
          additionalProperties: true,
          type: 'object',
        },
        {
          type: 'null',
        },
      ],
      title: 'Metadata',
      description: 'Metadata of the block.',
      default: {},
    },
    hidden: {
      anyOf: [
        {
          type: 'boolean',
        },
        {
          type: 'null',
        },
      ],
      title: 'Hidden',
      description: 'If set to True, the block will be hidden.',
    },
  },
  type: 'object',
  required: [
    'value',
    'template_id',
    'base_template_id',
    'deployment_id',
    'entity_id',
    'label',
  ],
  title: 'InternalTemplateBlockCreate',
  description: 'Used for Letta Cloud',
} as const;

export const $InternalTemplateGroupCreate = {
  properties: {
    agent_ids: {
      items: {
        type: 'string',
      },
      type: 'array',
      title: 'Agent Ids',
      description: '',
    },
    description: {
      type: 'string',
      title: 'Description',
      description: '',
    },
    manager_config: {
      oneOf: [
        {
          $ref: '#/components/schemas/RoundRobinManager',
        },
        {
          $ref: '#/components/schemas/SupervisorManager',
        },
        {
          $ref: '#/components/schemas/DynamicManager',
        },
        {
          $ref: '#/components/schemas/SleeptimeManager',
        },
        {
          $ref: '#/components/schemas/VoiceSleeptimeManager',
        },
      ],
      title: 'Manager Config',
      description: '',
      default: {
        manager_type: 'round_robin',
      },
      discriminator: {
        propertyName: 'manager_type',
        mapping: {
          dynamic: '#/components/schemas/DynamicManager',
          round_robin: '#/components/schemas/RoundRobinManager',
          sleeptime: '#/components/schemas/SleeptimeManager',
          supervisor: '#/components/schemas/SupervisorManager',
          voice_sleeptime: '#/components/schemas/VoiceSleeptimeManager',
        },
      },
    },
    project_id: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Project Id',
      description: 'The associated project id.',
    },
    shared_block_ids: {
      items: {
        type: 'string',
      },
      type: 'array',
      title: 'Shared Block Ids',
      description: '',
      default: [],
    },
    hidden: {
      anyOf: [
        {
          type: 'boolean',
        },
        {
          type: 'null',
        },
      ],
      title: 'Hidden',
      description: 'If set to True, the group will be hidden.',
    },
    base_template_id: {
      type: 'string',
      title: 'Base Template Id',
      description: 'The id of the base template.',
    },
    template_id: {
      type: 'string',
      title: 'Template Id',
      description: 'The id of the template.',
    },
    deployment_id: {
      type: 'string',
      title: 'Deployment Id',
      description: 'The id of the deployment.',
    },
  },
  type: 'object',
  required: [
    'agent_ids',
    'description',
    'base_template_id',
    'template_id',
    'deployment_id',
  ],
  title: 'InternalTemplateGroupCreate',
  description: 'Used for Letta Cloud',
} as const;

export const $Job = {
  properties: {
    created_by_id: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Created By Id',
      description: 'The id of the user that made this object.',
    },
    last_updated_by_id: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Last Updated By Id',
      description: 'The id of the user that made this object.',
    },
    created_at: {
      type: 'string',
      format: 'date-time',
      title: 'Created At',
      description: 'The unix timestamp of when the job was created.',
    },
    updated_at: {
      anyOf: [
        {
          type: 'string',
          format: 'date-time',
        },
        {
          type: 'null',
        },
      ],
      title: 'Updated At',
      description: 'The timestamp when the object was last updated.',
    },
    status: {
      $ref: '#/components/schemas/JobStatus',
      description: 'The status of the job.',
      default: 'created',
    },
    completed_at: {
      anyOf: [
        {
          type: 'string',
          format: 'date-time',
        },
        {
          type: 'null',
        },
      ],
      title: 'Completed At',
      description: 'The unix timestamp of when the job was completed.',
    },
    stop_reason: {
      anyOf: [
        {
          $ref: '#/components/schemas/StopReasonType',
        },
        {
          type: 'null',
        },
      ],
      description: 'The reason why the job was stopped.',
    },
    metadata: {
      anyOf: [
        {
          additionalProperties: true,
          type: 'object',
        },
        {
          type: 'null',
        },
      ],
      title: 'Metadata',
      description: 'The metadata of the job.',
    },
    job_type: {
      $ref: '#/components/schemas/JobType',
      description: 'The type of the job.',
      default: 'job',
    },
    background: {
      anyOf: [
        {
          type: 'boolean',
        },
        {
          type: 'null',
        },
      ],
      title: 'Background',
      description: 'Whether the job was created in background mode.',
    },
    agent_id: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Agent Id',
      description: 'The agent associated with this job/run.',
    },
    callback_url: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Callback Url',
      description: 'If set, POST to this URL when the job completes.',
    },
    callback_sent_at: {
      anyOf: [
        {
          type: 'string',
          format: 'date-time',
        },
        {
          type: 'null',
        },
      ],
      title: 'Callback Sent At',
      description: 'Timestamp when the callback was last attempted.',
    },
    callback_status_code: {
      anyOf: [
        {
          type: 'integer',
        },
        {
          type: 'null',
        },
      ],
      title: 'Callback Status Code',
      description: 'HTTP status code returned by the callback endpoint.',
    },
    callback_error: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Callback Error',
      description:
        'Optional error message from attempting to POST the callback endpoint.',
    },
    ttft_ns: {
      anyOf: [
        {
          type: 'integer',
        },
        {
          type: 'null',
        },
      ],
      title: 'Ttft Ns',
      description: 'Time to first token for a run in nanoseconds',
    },
    total_duration_ns: {
      anyOf: [
        {
          type: 'integer',
        },
        {
          type: 'null',
        },
      ],
      title: 'Total Duration Ns',
      description: 'Total run duration in nanoseconds',
    },
    id: {
      type: 'string',
      pattern: '^(job|run)-[a-fA-F0-9]{8}',
      title: 'Id',
      description: 'The human-friendly ID of the Job',
      examples: ['job-123e4567-e89b-12d3-a456-426614174000'],
    },
    user_id: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'User Id',
      description: 'The unique identifier of the user associated with the job.',
    },
  },
  additionalProperties: false,
  type: 'object',
  title: 'Job',
  description: `Representation of offline jobs, used for tracking status of data loading tasks (involving parsing and embedding files).

Parameters:
    id (str): The unique identifier of the job.
    status (JobStatus): The status of the job.
    created_at (datetime): The unix timestamp of when the job was created.
    completed_at (datetime): The unix timestamp of when the job was completed.
    user_id (str): The unique identifier of the user associated with the.`,
} as const;

export const $JobStatus = {
  type: 'string',
  enum: [
    'created',
    'running',
    'completed',
    'failed',
    'pending',
    'cancelled',
    'expired',
  ],
  title: 'JobStatus',
  description: 'Status of the job.',
} as const;

export const $JobType = {
  type: 'string',
  enum: ['job', 'run', 'batch'],
  title: 'JobType',
} as const;

export const $JsonObjectResponseFormat = {
  properties: {
    type: {
      type: 'string',
      const: 'json_object',
      title: 'Type',
      description: 'The type of the response format.',
      default: 'json_object',
    },
  },
  type: 'object',
  title: 'JsonObjectResponseFormat',
  description: 'Response format for JSON object responses.',
} as const;

export const $JsonSchemaResponseFormat = {
  properties: {
    type: {
      type: 'string',
      const: 'json_schema',
      title: 'Type',
      description: 'The type of the response format.',
      default: 'json_schema',
    },
    json_schema: {
      additionalProperties: true,
      type: 'object',
      title: 'Json Schema',
      description: 'The JSON schema of the response.',
    },
  },
  type: 'object',
  required: ['json_schema'],
  title: 'JsonSchemaResponseFormat',
  description: 'Response format for JSON schema-based responses.',
} as const;

export const $LLMConfig = {
  properties: {
    model: {
      type: 'string',
      title: 'Model',
      description: 'LLM model name. ',
    },
    model_endpoint_type: {
      type: 'string',
      enum: [
        'openai',
        'anthropic',
        'google_ai',
        'google_vertex',
        'azure',
        'groq',
        'ollama',
        'webui',
        'webui-legacy',
        'lmstudio',
        'lmstudio-legacy',
        'lmstudio-chatcompletions',
        'llamacpp',
        'koboldcpp',
        'vllm',
        'hugging-face',
        'mistral',
        'together',
        'bedrock',
        'deepseek',
        'xai',
      ],
      title: 'Model Endpoint Type',
      description: 'The endpoint type for the model.',
    },
    model_endpoint: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Model Endpoint',
      description: 'The endpoint for the model.',
    },
    provider_name: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Provider Name',
      description: 'The provider name for the model.',
    },
    provider_category: {
      anyOf: [
        {
          $ref: '#/components/schemas/ProviderCategory',
        },
        {
          type: 'null',
        },
      ],
      description: 'The provider category for the model.',
    },
    model_wrapper: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Model Wrapper',
      description: 'The wrapper for the model.',
    },
    context_window: {
      type: 'integer',
      title: 'Context Window',
      description: 'The context window size for the model.',
    },
    put_inner_thoughts_in_kwargs: {
      anyOf: [
        {
          type: 'boolean',
        },
        {
          type: 'null',
        },
      ],
      title: 'Put Inner Thoughts In Kwargs',
      description:
        "Puts 'inner_thoughts' as a kwarg in the function call if this is set to True. This helps with function calling performance and also the generation of inner thoughts.",
      default: true,
    },
    handle: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Handle',
      description:
        'The handle for this config, in the format provider/model-name.',
    },
    temperature: {
      type: 'number',
      title: 'Temperature',
      description:
        'The temperature to use when generating text with the model. A higher temperature will result in more random text.',
      default: 0.7,
    },
    max_tokens: {
      anyOf: [
        {
          type: 'integer',
        },
        {
          type: 'null',
        },
      ],
      title: 'Max Tokens',
      description:
        'The maximum number of tokens to generate. If not set, the model will use its default value.',
    },
    enable_reasoner: {
      type: 'boolean',
      title: 'Enable Reasoner',
      description:
        "Whether or not the model should use extended thinking if it is a 'reasoning' style model",
      default: true,
    },
    reasoning_effort: {
      anyOf: [
        {
          type: 'string',
          enum: ['minimal', 'low', 'medium', 'high'],
        },
        {
          type: 'null',
        },
      ],
      title: 'Reasoning Effort',
      description:
        'The reasoning effort to use when generating text reasoning models',
    },
    max_reasoning_tokens: {
      type: 'integer',
      title: 'Max Reasoning Tokens',
      description:
        'Configurable thinking budget for extended thinking. Used for enable_reasoner and also for Google Vertex models like Gemini 2.5 Flash. Minimum value is 1024 when used with enable_reasoner.',
      default: 0,
    },
    frequency_penalty: {
      anyOf: [
        {
          type: 'number',
        },
        {
          type: 'null',
        },
      ],
      title: 'Frequency Penalty',
      description:
        "Positive values penalize new tokens based on their existing frequency in the text so far, decreasing the model's likelihood to repeat the same line verbatim. From OpenAI: Number between -2.0 and 2.0.",
    },
    compatibility_type: {
      anyOf: [
        {
          type: 'string',
          enum: ['gguf', 'mlx'],
        },
        {
          type: 'null',
        },
      ],
      title: 'Compatibility Type',
      description: 'The framework compatibility type for the model.',
    },
    verbosity: {
      anyOf: [
        {
          type: 'string',
          enum: ['low', 'medium', 'high'],
        },
        {
          type: 'null',
        },
      ],
      title: 'Verbosity',
      description:
        'Soft control for how verbose model output should be, used for GPT-5 models.',
    },
    tier: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Tier',
      description: 'The cost tier for the model (cloud only).',
    },
  },
  type: 'object',
  required: ['model', 'model_endpoint_type', 'context_window'],
  title: 'LLMConfig',
  description:
    'Configuration for Language Model (LLM) connection and generation parameters.',
} as const;

export const $LettaAsyncRequest = {
  properties: {
    messages: {
      items: {
        anyOf: [
          {
            $ref: '#/components/schemas/MessageCreate',
          },
          {
            $ref: '#/components/schemas/ApprovalCreate',
          },
        ],
      },
      type: 'array',
      title: 'Messages',
      description: 'The messages to be sent to the agent.',
    },
    max_steps: {
      type: 'integer',
      title: 'Max Steps',
      description:
        'Maximum number of steps the agent should take to process the request.',
      default: 50,
    },
    use_assistant_message: {
      type: 'boolean',
      title: 'Use Assistant Message',
      description:
        'Whether the server should parse specific tool call arguments (default `send_message`) as `AssistantMessage` objects.',
      default: true,
    },
    assistant_message_tool_name: {
      type: 'string',
      title: 'Assistant Message Tool Name',
      description: 'The name of the designated message tool.',
      default: 'send_message',
    },
    assistant_message_tool_kwarg: {
      type: 'string',
      title: 'Assistant Message Tool Kwarg',
      description:
        'The name of the message argument in the designated message tool.',
      default: 'message',
    },
    include_return_message_types: {
      anyOf: [
        {
          items: {
            $ref: '#/components/schemas/MessageType',
          },
          type: 'array',
        },
        {
          type: 'null',
        },
      ],
      title: 'Include Return Message Types',
      description:
        'Only return specified message types in the response. If `None` (default) returns all messages.',
    },
    enable_thinking: {
      type: 'string',
      title: 'Enable Thinking',
      description:
        'If set to True, enables reasoning before responses or tool calls from the agent.',
      default: true,
    },
    callback_url: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Callback Url',
      description: 'Optional callback URL to POST to when the job completes',
    },
  },
  type: 'object',
  required: ['messages'],
  title: 'LettaAsyncRequest',
} as const;

export const $LettaBatchMessages = {
  properties: {
    messages: {
      items: {
        $ref: '#/components/schemas/Message',
      },
      type: 'array',
      title: 'Messages',
    },
  },
  type: 'object',
  required: ['messages'],
  title: 'LettaBatchMessages',
} as const;

export const $LettaBatchRequest = {
  properties: {
    messages: {
      items: {
        anyOf: [
          {
            $ref: '#/components/schemas/MessageCreate',
          },
          {
            $ref: '#/components/schemas/ApprovalCreate',
          },
        ],
      },
      type: 'array',
      title: 'Messages',
      description: 'The messages to be sent to the agent.',
    },
    max_steps: {
      type: 'integer',
      title: 'Max Steps',
      description:
        'Maximum number of steps the agent should take to process the request.',
      default: 50,
    },
    use_assistant_message: {
      type: 'boolean',
      title: 'Use Assistant Message',
      description:
        'Whether the server should parse specific tool call arguments (default `send_message`) as `AssistantMessage` objects.',
      default: true,
    },
    assistant_message_tool_name: {
      type: 'string',
      title: 'Assistant Message Tool Name',
      description: 'The name of the designated message tool.',
      default: 'send_message',
    },
    assistant_message_tool_kwarg: {
      type: 'string',
      title: 'Assistant Message Tool Kwarg',
      description:
        'The name of the message argument in the designated message tool.',
      default: 'message',
    },
    include_return_message_types: {
      anyOf: [
        {
          items: {
            $ref: '#/components/schemas/MessageType',
          },
          type: 'array',
        },
        {
          type: 'null',
        },
      ],
      title: 'Include Return Message Types',
      description:
        'Only return specified message types in the response. If `None` (default) returns all messages.',
    },
    enable_thinking: {
      type: 'string',
      title: 'Enable Thinking',
      description:
        'If set to True, enables reasoning before responses or tool calls from the agent.',
      default: true,
    },
    agent_id: {
      type: 'string',
      title: 'Agent Id',
      description: 'The ID of the agent to send this batch request for',
    },
  },
  type: 'object',
  required: ['messages', 'agent_id'],
  title: 'LettaBatchRequest',
} as const;

export const $LettaImage = {
  properties: {
    type: {
      type: 'string',
      const: 'letta',
      title: 'Type',
      description: 'The source type for the image.',
      default: 'letta',
    },
    file_id: {
      type: 'string',
      title: 'File Id',
      description:
        'The unique identifier of the image file persisted in storage.',
    },
    media_type: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Media Type',
      description: 'The media type for the image.',
    },
    data: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Data',
      description: 'The base64 encoded image data.',
    },
    detail: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Detail',
      description:
        'What level of detail to use when processing and understanding the image (low, high, or auto to let the model decide)',
    },
  },
  type: 'object',
  required: ['file_id'],
  title: 'LettaImage',
} as const;

export const $LettaRequest = {
  properties: {
    messages: {
      items: {
        anyOf: [
          {
            $ref: '#/components/schemas/MessageCreate',
          },
          {
            $ref: '#/components/schemas/ApprovalCreate',
          },
        ],
      },
      type: 'array',
      title: 'Messages',
      description: 'The messages to be sent to the agent.',
    },
    max_steps: {
      type: 'integer',
      title: 'Max Steps',
      description:
        'Maximum number of steps the agent should take to process the request.',
      default: 50,
    },
    use_assistant_message: {
      type: 'boolean',
      title: 'Use Assistant Message',
      description:
        'Whether the server should parse specific tool call arguments (default `send_message`) as `AssistantMessage` objects.',
      default: true,
    },
    assistant_message_tool_name: {
      type: 'string',
      title: 'Assistant Message Tool Name',
      description: 'The name of the designated message tool.',
      default: 'send_message',
    },
    assistant_message_tool_kwarg: {
      type: 'string',
      title: 'Assistant Message Tool Kwarg',
      description:
        'The name of the message argument in the designated message tool.',
      default: 'message',
    },
    include_return_message_types: {
      anyOf: [
        {
          items: {
            $ref: '#/components/schemas/MessageType',
          },
          type: 'array',
        },
        {
          type: 'null',
        },
      ],
      title: 'Include Return Message Types',
      description:
        'Only return specified message types in the response. If `None` (default) returns all messages.',
    },
    enable_thinking: {
      type: 'string',
      title: 'Enable Thinking',
      description:
        'If set to True, enables reasoning before responses or tool calls from the agent.',
      default: true,
    },
  },
  type: 'object',
  required: ['messages'],
  title: 'LettaRequest',
} as const;

export const $LettaRequestConfig = {
  properties: {
    use_assistant_message: {
      type: 'boolean',
      title: 'Use Assistant Message',
      description:
        'Whether the server should parse specific tool call arguments (default `send_message`) as `AssistantMessage` objects.',
      default: true,
    },
    assistant_message_tool_name: {
      type: 'string',
      title: 'Assistant Message Tool Name',
      description: 'The name of the designated message tool.',
      default: 'send_message',
    },
    assistant_message_tool_kwarg: {
      type: 'string',
      title: 'Assistant Message Tool Kwarg',
      description:
        'The name of the message argument in the designated message tool.',
      default: 'message',
    },
    include_return_message_types: {
      anyOf: [
        {
          items: {
            $ref: '#/components/schemas/MessageType',
          },
          type: 'array',
        },
        {
          type: 'null',
        },
      ],
      title: 'Include Return Message Types',
      description:
        'Only return specified message types in the response. If `None` (default) returns all messages.',
    },
  },
  type: 'object',
  title: 'LettaRequestConfig',
} as const;

export const $LettaResponse = {
  properties: {
    messages: {
      items: {
        $ref: '#/components/schemas/LettaMessageUnion',
      },
      type: 'array',
      title: 'Messages',
      description: 'The messages returned by the agent.',
    },
    stop_reason: {
      $ref: '#/components/schemas/LettaStopReason',
    },
    usage: {
      $ref: '#/components/schemas/LettaUsageStatistics',
      description: 'The usage statistics of the agent.',
    },
  },
  type: 'object',
  required: ['messages', 'stop_reason', 'usage'],
  title: 'LettaResponse',
  description: `Response object from an agent interaction, consisting of the new messages generated by the agent and usage statistics.
The type of the returned messages can be either \`Message\` or \`LettaMessage\`, depending on what was specified in the request.

Attributes:
    messages (List[Union[Message, LettaMessage]]): The messages returned by the agent.
    usage (LettaUsageStatistics): The usage statistics`,
} as const;

export const $LettaStopReason = {
  properties: {
    message_type: {
      type: 'string',
      const: 'stop_reason',
      title: 'Message Type',
      description: 'The type of the message.',
      default: 'stop_reason',
    },
    stop_reason: {
      $ref: '#/components/schemas/StopReasonType',
      description: 'The reason why execution stopped.',
    },
  },
  type: 'object',
  required: ['stop_reason'],
  title: 'LettaStopReason',
  description:
    'The stop reason from Letta indicating why agent loop stopped execution.',
} as const;

export const $LettaStreamingRequest = {
  properties: {
    messages: {
      items: {
        anyOf: [
          {
            $ref: '#/components/schemas/MessageCreate',
          },
          {
            $ref: '#/components/schemas/ApprovalCreate',
          },
        ],
      },
      type: 'array',
      title: 'Messages',
      description: 'The messages to be sent to the agent.',
    },
    max_steps: {
      type: 'integer',
      title: 'Max Steps',
      description:
        'Maximum number of steps the agent should take to process the request.',
      default: 50,
    },
    use_assistant_message: {
      type: 'boolean',
      title: 'Use Assistant Message',
      description:
        'Whether the server should parse specific tool call arguments (default `send_message`) as `AssistantMessage` objects.',
      default: true,
    },
    assistant_message_tool_name: {
      type: 'string',
      title: 'Assistant Message Tool Name',
      description: 'The name of the designated message tool.',
      default: 'send_message',
    },
    assistant_message_tool_kwarg: {
      type: 'string',
      title: 'Assistant Message Tool Kwarg',
      description:
        'The name of the message argument in the designated message tool.',
      default: 'message',
    },
    include_return_message_types: {
      anyOf: [
        {
          items: {
            $ref: '#/components/schemas/MessageType',
          },
          type: 'array',
        },
        {
          type: 'null',
        },
      ],
      title: 'Include Return Message Types',
      description:
        'Only return specified message types in the response. If `None` (default) returns all messages.',
    },
    enable_thinking: {
      type: 'string',
      title: 'Enable Thinking',
      description:
        'If set to True, enables reasoning before responses or tool calls from the agent.',
      default: true,
    },
    stream_tokens: {
      type: 'boolean',
      title: 'Stream Tokens',
      description:
        'Flag to determine if individual tokens should be streamed, rather than streaming per step.',
      default: false,
    },
    include_pings: {
      type: 'boolean',
      title: 'Include Pings',
      description:
        'Whether to include periodic keepalive ping messages in the stream to prevent connection timeouts.',
      default: true,
    },
    background: {
      type: 'boolean',
      title: 'Background',
      description: 'Whether to process the request in the background.',
      default: false,
    },
  },
  type: 'object',
  required: ['messages'],
  title: 'LettaStreamingRequest',
} as const;

export const $LettaUsageStatistics = {
  properties: {
    message_type: {
      type: 'string',
      const: 'usage_statistics',
      title: 'Message Type',
      default: 'usage_statistics',
    },
    completion_tokens: {
      type: 'integer',
      title: 'Completion Tokens',
      description: 'The number of tokens generated by the agent.',
      default: 0,
    },
    prompt_tokens: {
      type: 'integer',
      title: 'Prompt Tokens',
      description: 'The number of tokens in the prompt.',
      default: 0,
    },
    total_tokens: {
      type: 'integer',
      title: 'Total Tokens',
      description: 'The total number of tokens processed by the agent.',
      default: 0,
    },
    step_count: {
      type: 'integer',
      title: 'Step Count',
      description: 'The number of steps taken by the agent.',
      default: 0,
    },
    steps_messages: {
      anyOf: [
        {
          items: {
            items: {
              $ref: '#/components/schemas/Message',
            },
            type: 'array',
          },
          type: 'array',
        },
        {
          type: 'null',
        },
      ],
      title: 'Steps Messages',
      description: 'The messages generated per step',
    },
    run_ids: {
      anyOf: [
        {
          items: {
            type: 'string',
          },
          type: 'array',
        },
        {
          type: 'null',
        },
      ],
      title: 'Run Ids',
      description:
        'The background task run IDs associated with the agent interaction',
    },
  },
  type: 'object',
  title: 'LettaUsageStatistics',
  description: `Usage statistics for the agent interaction.

Attributes:
    completion_tokens (int): The number of tokens generated by the agent.
    prompt_tokens (int): The number of tokens in the prompt.
    total_tokens (int): The total number of tokens processed by the agent.
    step_count (int): The number of steps taken by the agent.`,
} as const;

export const $ListDeploymentEntitiesResponse = {
  properties: {
    entities: {
      items: {
        $ref: '#/components/schemas/DeploymentEntity',
      },
      type: 'array',
      title: 'Entities',
      default: [],
    },
    total_count: {
      type: 'integer',
      title: 'Total Count',
    },
    deployment_id: {
      type: 'string',
      title: 'Deployment Id',
    },
    message: {
      type: 'string',
      title: 'Message',
    },
  },
  type: 'object',
  required: ['total_count', 'deployment_id', 'message'],
  title: 'ListDeploymentEntitiesResponse',
  description: 'Response model for listing deployment entities.',
} as const;

export const $LocalSandboxConfig = {
  properties: {
    sandbox_dir: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Sandbox Dir',
      description: 'Directory for the sandbox environment.',
    },
    use_venv: {
      type: 'boolean',
      title: 'Use Venv',
      description:
        'Whether or not to use the venv, or run directly in the same run loop.',
      default: false,
    },
    venv_name: {
      type: 'string',
      title: 'Venv Name',
      description:
        'The name for the venv in the sandbox directory. We first search for an existing venv with this name, otherwise, we make it from the requirements.txt.',
      default: 'venv',
    },
    pip_requirements: {
      items: {
        $ref: '#/components/schemas/PipRequirement',
      },
      type: 'array',
      title: 'Pip Requirements',
      description:
        'List of pip packages to install with mandatory name and optional version following semantic versioning. This only is considered when use_venv is True.',
    },
  },
  type: 'object',
  title: 'LocalSandboxConfig',
} as const;

export const $MCPServerSchema = {
  properties: {
    id: {
      type: 'string',
      title: 'Id',
      description: 'Human-readable MCP server ID',
    },
    server_type: {
      type: 'string',
      title: 'Server Type',
    },
    server_name: {
      type: 'string',
      title: 'Server Name',
    },
    server_url: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Server Url',
    },
    stdio_config: {
      anyOf: [
        {
          additionalProperties: true,
          type: 'object',
        },
        {
          type: 'null',
        },
      ],
      title: 'Stdio Config',
    },
    metadata_: {
      anyOf: [
        {
          additionalProperties: true,
          type: 'object',
        },
        {
          type: 'null',
        },
      ],
      title: 'Metadata',
    },
  },
  type: 'object',
  required: ['id', 'server_type', 'server_name'],
  title: 'MCPServerSchema',
  description: 'MCP server schema for agent files with remapped ID.',
} as const;

export const $MCPServerType = {
  type: 'string',
  enum: ['sse', 'stdio', 'streamable_http'],
  title: 'MCPServerType',
} as const;

export const $MCPTool = {
  properties: {
    name: {
      type: 'string',
      title: 'Name',
    },
    title: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Title',
    },
    description: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Description',
    },
    inputSchema: {
      additionalProperties: true,
      type: 'object',
      title: 'Inputschema',
    },
    outputSchema: {
      anyOf: [
        {
          additionalProperties: true,
          type: 'object',
        },
        {
          type: 'null',
        },
      ],
      title: 'Outputschema',
    },
    annotations: {
      anyOf: [
        {
          $ref: '#/components/schemas/ToolAnnotations',
        },
        {
          type: 'null',
        },
      ],
    },
    _meta: {
      anyOf: [
        {
          additionalProperties: true,
          type: 'object',
        },
        {
          type: 'null',
        },
      ],
      title: 'Meta',
    },
    health: {
      anyOf: [
        {
          $ref: '#/components/schemas/MCPToolHealth',
        },
        {
          type: 'null',
        },
      ],
      description: 'Schema health status for OpenAI strict mode',
    },
  },
  additionalProperties: true,
  type: 'object',
  required: ['name', 'inputSchema'],
  title: 'MCPTool',
  description:
    "A simple wrapper around MCP's tool definition (to avoid conflict with our own)",
} as const;

export const $MCPToolExecuteRequest = {
  properties: {
    args: {
      additionalProperties: true,
      type: 'object',
      title: 'Args',
      description: 'Arguments to pass to the MCP tool',
    },
  },
  type: 'object',
  title: 'MCPToolExecuteRequest',
} as const;

export const $MCPToolHealth = {
  properties: {
    status: {
      type: 'string',
      title: 'Status',
      description:
        'Schema health status: STRICT_COMPLIANT, NON_STRICT_ONLY, or INVALID',
    },
    reasons: {
      items: {
        type: 'string',
      },
      type: 'array',
      title: 'Reasons',
      description: 'List of reasons for the health status',
    },
  },
  type: 'object',
  required: ['status'],
  title: 'MCPToolHealth',
  description: "Health status for an MCP tool's schema.",
} as const;

export const $ManagerType = {
  type: 'string',
  enum: [
    'round_robin',
    'supervisor',
    'dynamic',
    'sleeptime',
    'voice_sleeptime',
    'swarm',
  ],
  title: 'ManagerType',
} as const;

export const $MaxCountPerStepToolRule = {
  properties: {
    tool_name: {
      type: 'string',
      title: 'Tool Name',
      description:
        "The name of the tool. Must exist in the database for the user's organization.",
    },
    type: {
      type: 'string',
      const: 'max_count_per_step',
      title: 'Type',
      default: 'max_count_per_step',
    },
    prompt_template: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Prompt Template',
      description: 'Optional template string (ignored).',
    },
    max_count_limit: {
      type: 'integer',
      title: 'Max Count Limit',
      description:
        'The max limit for the total number of times this tool can be invoked in a single step.',
    },
  },
  additionalProperties: false,
  type: 'object',
  required: ['tool_name', 'max_count_limit'],
  title: 'MaxCountPerStepToolRule',
  description:
    'Represents a tool rule configuration which constrains the total number of times this tool can be invoked in a single step.',
} as const;

export const $MaxCountPerStepToolRuleSchema = {
  properties: {
    tool_name: {
      type: 'string',
      title: 'Tool Name',
    },
    type: {
      type: 'string',
      title: 'Type',
    },
    max_count_limit: {
      type: 'integer',
      title: 'Max Count Limit',
    },
  },
  type: 'object',
  required: ['tool_name', 'type', 'max_count_limit'],
  title: 'MaxCountPerStepToolRuleSchema',
} as const;

export const $Memory = {
  properties: {
    agent_type: {
      anyOf: [
        {
          $ref: '#/components/schemas/AgentType',
        },
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Agent Type',
      description: 'Agent type controlling prompt rendering.',
    },
    blocks: {
      items: {
        $ref: '#/components/schemas/Block',
      },
      type: 'array',
      title: 'Blocks',
      description: "Memory blocks contained in the agent's in-context memory",
    },
    file_blocks: {
      items: {
        $ref: '#/components/schemas/FileBlock',
      },
      type: 'array',
      title: 'File Blocks',
      description:
        "Special blocks representing the agent's in-context memory of an attached file",
    },
    prompt_template: {
      type: 'string',
      title: 'Prompt Template',
      description: 'Deprecated. Ignored for performance.',
      default: '',
    },
  },
  type: 'object',
  required: ['blocks'],
  title: 'Memory',
  description:
    'Represents the in-context memory (i.e. Core memory) of the agent. This includes both the `Block` objects (labelled by sections), as well as tools to edit the blocks.',
} as const;

export const $Message = {
  properties: {
    created_by_id: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Created By Id',
      description: 'The id of the user that made this object.',
    },
    last_updated_by_id: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Last Updated By Id',
      description: 'The id of the user that made this object.',
    },
    created_at: {
      type: 'string',
      format: 'date-time',
      title: 'Created At',
      description: 'The timestamp when the object was created.',
    },
    updated_at: {
      anyOf: [
        {
          type: 'string',
          format: 'date-time',
        },
        {
          type: 'null',
        },
      ],
      title: 'Updated At',
      description: 'The timestamp when the object was last updated.',
    },
    id: {
      type: 'string',
      pattern: '^message-[a-fA-F0-9]{8}',
      title: 'Id',
      description: 'The human-friendly ID of the Message',
      examples: ['message-123e4567-e89b-12d3-a456-426614174000'],
    },
    agent_id: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Agent Id',
      description: 'The unique identifier of the agent.',
    },
    model: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Model',
      description: 'The model used to make the function call.',
    },
    role: {
      $ref: '#/components/schemas/MessageRole',
      description: 'The role of the participant.',
    },
    content: {
      anyOf: [
        {
          items: {
            oneOf: [
              {
                $ref: '#/components/schemas/TextContent',
              },
              {
                $ref: '#/components/schemas/ImageContent',
              },
              {
                $ref: '#/components/schemas/ToolCallContent',
              },
              {
                $ref: '#/components/schemas/ToolReturnContent',
              },
              {
                $ref: '#/components/schemas/ReasoningContent',
              },
              {
                $ref: '#/components/schemas/RedactedReasoningContent',
              },
              {
                $ref: '#/components/schemas/OmittedReasoningContent',
              },
              {
                $ref: '#/components/schemas/SummarizedReasoningContent',
              },
            ],
            discriminator: {
              propertyName: 'type',
              mapping: {
                image: '#/components/schemas/ImageContent',
                omitted_reasoning:
                  '#/components/schemas/OmittedReasoningContent',
                reasoning: '#/components/schemas/ReasoningContent',
                redacted_reasoning:
                  '#/components/schemas/RedactedReasoningContent',
                summarized_reasoning:
                  '#/components/schemas/SummarizedReasoningContent',
                text: '#/components/schemas/TextContent',
                tool_call: '#/components/schemas/ToolCallContent',
                tool_return: '#/components/schemas/ToolReturnContent',
              },
            },
          },
          type: 'array',
        },
        {
          type: 'null',
        },
      ],
      title: 'Content',
      description: 'The content of the message.',
    },
    name: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Name',
      description:
        'For role user/assistant: the (optional) name of the participant. For role tool/function: the name of the function called.',
    },
    tool_calls: {
      anyOf: [
        {
          items: {
            $ref: '#/components/schemas/ChatCompletionMessageFunctionToolCall',
          },
          type: 'array',
        },
        {
          type: 'null',
        },
      ],
      title: 'Tool Calls',
      description:
        'The list of tool calls requested. Only applicable for role assistant.',
    },
    tool_call_id: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Tool Call Id',
      description: 'The ID of the tool call. Only applicable for role tool.',
    },
    step_id: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Step Id',
      description: 'The id of the step that this message was created in.',
    },
    run_id: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Run Id',
      description: 'The id of the run that this message was created in.',
    },
    otid: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Otid',
      description: 'The offline threading id associated with this message',
    },
    tool_returns: {
      anyOf: [
        {
          items: {
            $ref: '#/components/schemas/ToolReturn',
          },
          type: 'array',
        },
        {
          type: 'null',
        },
      ],
      title: 'Tool Returns',
      description: 'Tool execution return information for prior tool calls',
    },
    group_id: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Group Id',
      description: 'The multi-agent group that the message was sent in',
    },
    sender_id: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Sender Id',
      description:
        'The id of the sender of the message, can be an identity id or agent id',
    },
    batch_item_id: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Batch Item Id',
      description:
        'The id of the LLMBatchItem that this message is associated with',
    },
    is_err: {
      anyOf: [
        {
          type: 'boolean',
        },
        {
          type: 'null',
        },
      ],
      title: 'Is Err',
      description:
        'Whether this message is part of an error step. Used only for debugging purposes.',
    },
    approval_request_id: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Approval Request Id',
      description:
        'The id of the approval request if this message is associated with a tool call request.',
    },
    approve: {
      anyOf: [
        {
          type: 'boolean',
        },
        {
          type: 'null',
        },
      ],
      title: 'Approve',
      description: 'Whether tool call is approved.',
    },
    denial_reason: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Denial Reason',
      description: 'The reason the tool call request was denied.',
    },
  },
  additionalProperties: false,
  type: 'object',
  required: ['role'],
  title: 'Message',
  description: `    Letta's internal representation of a message. Includes methods to convert to/from LLM provider formats.

    Attributes:
        id (str): The unique identifier of the message.
        role (MessageRole): The role of the participant.
        text (str): The text of the message.
        user_id (str): The unique identifier of the user.
        agent_id (str): The unique identifier of the agent.
        model (str): The model used to make the function call.
        name (str): The name of the participant.
        created_at (datetime): The time the message was created.
        tool_calls (List[OpenAIToolCall,]): The list of tool calls requested.
        tool_call_id (str): The id of the tool call.
        step_id (str): The id of the step that this message was created in.
        otid (str): The offline threading id associated with this message.
        tool_returns (List[ToolReturn]): The list of tool returns requested.
        group_id (str): The multi-agent group that the message was sent in.
        sender_id (str): The id of the sender of the message, can be an identity id or agent id.
t`,
} as const;

export const $MessageCreate = {
  properties: {
    type: {
      anyOf: [
        {
          type: 'string',
          const: 'message',
        },
        {
          type: 'null',
        },
      ],
      title: 'Type',
      description: 'The message type to be created.',
      default: 'message',
    },
    role: {
      type: 'string',
      enum: ['user', 'system', 'assistant'],
      title: 'Role',
      description: 'The role of the participant.',
    },
    content: {
      anyOf: [
        {
          items: {
            $ref: '#/components/schemas/LettaMessageContentUnion',
          },
          type: 'array',
        },
        {
          type: 'string',
        },
      ],
      title: 'Content',
      description: 'The content of the message.',
    },
    name: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Name',
      description: 'The name of the participant.',
    },
    otid: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Otid',
      description: 'The offline threading id associated with this message',
    },
    sender_id: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Sender Id',
      description:
        'The id of the sender of the message, can be an identity id or agent id',
    },
    batch_item_id: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Batch Item Id',
      description:
        'The id of the LLMBatchItem that this message is associated with',
    },
    group_id: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Group Id',
      description: 'The multi-agent group that the message was sent in',
    },
  },
  type: 'object',
  required: ['role', 'content'],
  title: 'MessageCreate',
  description: 'Request to create a message',
} as const;

export const $MessageRole = {
  type: 'string',
  enum: ['assistant', 'user', 'tool', 'function', 'system', 'approval'],
  title: 'MessageRole',
} as const;

export const $MessageSearchRequest = {
  properties: {
    query: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Query',
      description: 'Text query for full-text search',
    },
    search_mode: {
      type: 'string',
      enum: ['vector', 'fts', 'hybrid'],
      title: 'Search Mode',
      description: 'Search mode to use',
      default: 'hybrid',
    },
    roles: {
      anyOf: [
        {
          items: {
            $ref: '#/components/schemas/MessageRole',
          },
          type: 'array',
        },
        {
          type: 'null',
        },
      ],
      title: 'Roles',
      description: 'Filter messages by role',
    },
    project_id: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Project Id',
      description: 'Filter messages by project ID',
    },
    template_id: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Template Id',
      description: 'Filter messages by template ID',
    },
    limit: {
      type: 'integer',
      maximum: 100,
      minimum: 1,
      title: 'Limit',
      description: 'Maximum number of results to return',
      default: 50,
    },
    start_date: {
      anyOf: [
        {
          type: 'string',
          format: 'date-time',
        },
        {
          type: 'null',
        },
      ],
      title: 'Start Date',
      description: 'Filter messages created after this date',
    },
    end_date: {
      anyOf: [
        {
          type: 'string',
          format: 'date-time',
        },
        {
          type: 'null',
        },
      ],
      title: 'End Date',
      description: 'Filter messages created on or before this date',
    },
  },
  type: 'object',
  title: 'MessageSearchRequest',
  description: 'Request model for searching messages across the organization',
} as const;

export const $MessageSearchResult = {
  properties: {
    embedded_text: {
      type: 'string',
      title: 'Embedded Text',
      description: 'The embedded content (LLM-friendly)',
    },
    message: {
      $ref: '#/components/schemas/Message',
      description: 'The raw message object',
    },
    fts_rank: {
      anyOf: [
        {
          type: 'integer',
        },
        {
          type: 'null',
        },
      ],
      title: 'Fts Rank',
      description: 'Full-text search rank position if FTS was used',
    },
    vector_rank: {
      anyOf: [
        {
          type: 'integer',
        },
        {
          type: 'null',
        },
      ],
      title: 'Vector Rank',
      description: 'Vector search rank position if vector search was used',
    },
    rrf_score: {
      type: 'number',
      title: 'Rrf Score',
      description: 'Reciprocal Rank Fusion combined score',
    },
  },
  type: 'object',
  required: ['embedded_text', 'message', 'rrf_score'],
  title: 'MessageSearchResult',
  description: 'Result from a message search operation with scoring details.',
} as const;

export const $MessageType = {
  type: 'string',
  enum: [
    'system_message',
    'user_message',
    'assistant_message',
    'reasoning_message',
    'hidden_reasoning_message',
    'tool_call_message',
    'tool_return_message',
    'approval_request_message',
    'approval_response_message',
  ],
  title: 'MessageType',
} as const;

export const $ModalSandboxConfig = {
  properties: {
    timeout: {
      type: 'integer',
      title: 'Timeout',
      description: 'Time limit for the sandbox (in seconds).',
      default: 60,
    },
    pip_requirements: {
      anyOf: [
        {
          items: {
            type: 'string',
          },
          type: 'array',
        },
        {
          type: 'null',
        },
      ],
      title: 'Pip Requirements',
      description: 'A list of pip packages to install in the Modal sandbox',
    },
    npm_requirements: {
      anyOf: [
        {
          items: {
            type: 'string',
          },
          type: 'array',
        },
        {
          type: 'null',
        },
      ],
      title: 'Npm Requirements',
      description: 'A list of npm packages to install in the Modal sandbox',
    },
    language: {
      type: 'string',
      enum: ['python', 'typescript'],
      title: 'Language',
      default: 'python',
    },
  },
  type: 'object',
  title: 'ModalSandboxConfig',
} as const;

export const $ModifyFeedbackRequest = {
  properties: {
    feedback: {
      anyOf: [
        {
          $ref: '#/components/schemas/FeedbackType',
        },
        {
          type: 'null',
        },
      ],
      description: 'Whether this feedback is positive or negative',
    },
    tags: {
      anyOf: [
        {
          items: {
            type: 'string',
          },
          type: 'array',
        },
        {
          type: 'null',
        },
      ],
      title: 'Tags',
      description: 'Feedback tags to add to the step',
    },
  },
  type: 'object',
  title: 'ModifyFeedbackRequest',
} as const;

export const $NpmRequirement = {
  properties: {
    name: {
      type: 'string',
      minLength: 1,
      title: 'Name',
      description: 'Name of the npm package.',
    },
    version: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Version',
      description:
        'Optional version of the package, following semantic versioning.',
    },
  },
  type: 'object',
  required: ['name'],
  title: 'NpmRequirement',
} as const;

export const $OmittedReasoningContent = {
  properties: {
    type: {
      type: 'string',
      const: 'omitted_reasoning',
      title: 'Type',
      description: 'Indicates this is an omitted reasoning step.',
      default: 'omitted_reasoning',
    },
    signature: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Signature',
      description: 'A unique identifier for this reasoning step.',
    },
  },
  type: 'object',
  title: 'OmittedReasoningContent',
  description:
    "A placeholder for reasoning content we know is present, but isn't returned by the provider (e.g. OpenAI GPT-5 on ChatCompletions)",
} as const;

export const $Organization = {
  properties: {
    id: {
      type: 'string',
      pattern: '^org-[a-fA-F0-9]{8}',
      title: 'Id',
      description: 'The human-friendly ID of the Org',
      examples: ['org-123e4567-e89b-12d3-a456-426614174000'],
    },
    name: {
      type: 'string',
      title: 'Name',
      description: 'The name of the organization.',
      default: 'SincereYogurt',
    },
    created_at: {
      anyOf: [
        {
          type: 'string',
          format: 'date-time',
        },
        {
          type: 'null',
        },
      ],
      title: 'Created At',
      description: 'The creation date of the organization.',
    },
    privileged_tools: {
      type: 'boolean',
      title: 'Privileged Tools',
      description: 'Whether the organization has access to privileged tools.',
      default: false,
    },
  },
  additionalProperties: false,
  type: 'object',
  title: 'Organization',
} as const;

export const $OrganizationCreate = {
  properties: {
    name: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Name',
      description: 'The name of the organization.',
    },
    privileged_tools: {
      anyOf: [
        {
          type: 'boolean',
        },
        {
          type: 'null',
        },
      ],
      title: 'Privileged Tools',
      description: 'Whether the organization has access to privileged tools.',
      default: false,
    },
  },
  additionalProperties: false,
  type: 'object',
  title: 'OrganizationCreate',
} as const;

export const $OrganizationSourcesStats = {
  properties: {
    total_sources: {
      type: 'integer',
      title: 'Total Sources',
      description: 'Total number of sources',
      default: 0,
    },
    total_files: {
      type: 'integer',
      title: 'Total Files',
      description: 'Total number of files across all sources',
      default: 0,
    },
    total_size: {
      type: 'integer',
      title: 'Total Size',
      description: 'Total size of all files in bytes',
      default: 0,
    },
    sources: {
      items: {
        $ref: '#/components/schemas/SourceStats',
      },
      type: 'array',
      title: 'Sources',
      description: 'List of source metadata',
    },
  },
  additionalProperties: false,
  type: 'object',
  title: 'OrganizationSourcesStats',
  description: 'Complete metadata response for organization sources',
} as const;

export const $OrganizationUpdate = {
  properties: {
    name: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Name',
      description: 'The name of the organization.',
    },
    privileged_tools: {
      anyOf: [
        {
          type: 'boolean',
        },
        {
          type: 'null',
        },
      ],
      title: 'Privileged Tools',
      description: 'Whether the organization has access to privileged tools.',
      default: false,
    },
  },
  additionalProperties: false,
  type: 'object',
  title: 'OrganizationUpdate',
} as const;

export const $PaginatedAgentFiles = {
  properties: {
    files: {
      items: {
        $ref: '#/components/schemas/AgentFileAttachment',
      },
      type: 'array',
      title: 'Files',
      description: 'List of file attachments for the agent',
    },
    next_cursor: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Next Cursor',
      description:
        'Cursor for fetching the next page (file-agent relationship ID)',
    },
    has_more: {
      type: 'boolean',
      title: 'Has More',
      description: 'Whether more results exist after this page',
    },
  },
  additionalProperties: false,
  type: 'object',
  required: ['files', 'has_more'],
  title: 'PaginatedAgentFiles',
  description: 'Paginated response for agent files',
} as const;

export const $ParameterProperties = {
  properties: {
    type: {
      type: 'string',
      title: 'Type',
    },
    description: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Description',
    },
  },
  type: 'object',
  required: ['type'],
  title: 'ParameterProperties',
} as const;

export const $ParametersSchema = {
  properties: {
    type: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Type',
      default: 'object',
    },
    properties: {
      additionalProperties: {
        $ref: '#/components/schemas/ParameterProperties',
      },
      type: 'object',
      title: 'Properties',
    },
    required: {
      items: {
        type: 'string',
      },
      type: 'array',
      title: 'Required',
    },
  },
  type: 'object',
  required: ['properties'],
  title: 'ParametersSchema',
} as const;

export const $ParentToolRule = {
  properties: {
    tool_name: {
      type: 'string',
      title: 'Tool Name',
      description:
        "The name of the tool. Must exist in the database for the user's organization.",
    },
    type: {
      type: 'string',
      const: 'parent_last_tool',
      title: 'Type',
      default: 'parent_last_tool',
    },
    prompt_template: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Prompt Template',
      description: 'Optional template string (ignored).',
    },
    children: {
      items: {
        type: 'string',
      },
      type: 'array',
      title: 'Children',
      description: 'The children tools that can be invoked.',
    },
  },
  additionalProperties: false,
  type: 'object',
  required: ['tool_name', 'children'],
  title: 'ParentToolRule',
  description:
    'A ToolRule that only allows a child tool to be called if the parent has been called.',
} as const;

export const $Passage = {
  properties: {
    created_by_id: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Created By Id',
      description: 'The id of the user that made this object.',
    },
    last_updated_by_id: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Last Updated By Id',
      description: 'The id of the user that made this object.',
    },
    created_at: {
      type: 'string',
      format: 'date-time',
      title: 'Created At',
      description: 'The creation date of the passage.',
    },
    updated_at: {
      anyOf: [
        {
          type: 'string',
          format: 'date-time',
        },
        {
          type: 'null',
        },
      ],
      title: 'Updated At',
      description: 'The timestamp when the object was last updated.',
    },
    is_deleted: {
      type: 'boolean',
      title: 'Is Deleted',
      description: 'Whether this passage is deleted or not.',
      default: false,
    },
    organization_id: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Organization Id',
      description:
        'The unique identifier of the user associated with the passage.',
    },
    archive_id: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Archive Id',
      description:
        'The unique identifier of the archive containing this passage.',
    },
    source_id: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Source Id',
      description: 'The data source of the passage.',
    },
    file_id: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'File Id',
      description:
        'The unique identifier of the file associated with the passage.',
    },
    file_name: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'File Name',
      description: 'The name of the file (only for source passages).',
    },
    metadata: {
      anyOf: [
        {
          additionalProperties: true,
          type: 'object',
        },
        {
          type: 'null',
        },
      ],
      title: 'Metadata',
      description: 'The metadata of the passage.',
      default: {},
    },
    tags: {
      anyOf: [
        {
          items: {
            type: 'string',
          },
          type: 'array',
        },
        {
          type: 'null',
        },
      ],
      title: 'Tags',
      description: 'Tags associated with this passage.',
    },
    id: {
      type: 'string',
      pattern: '^passage-[a-fA-F0-9]{8}',
      title: 'Id',
      description: 'The human-friendly ID of the Passage',
      examples: ['passage-123e4567-e89b-12d3-a456-426614174000'],
    },
    text: {
      type: 'string',
      title: 'Text',
      description: 'The text of the passage.',
    },
    embedding: {
      anyOf: [
        {
          items: {
            type: 'number',
          },
          type: 'array',
        },
        {
          type: 'null',
        },
      ],
      title: 'Embedding',
      description: 'The embedding of the passage.',
    },
    embedding_config: {
      anyOf: [
        {
          $ref: '#/components/schemas/EmbeddingConfig',
        },
        {
          type: 'null',
        },
      ],
      description: 'The embedding configuration used by the passage.',
    },
  },
  additionalProperties: false,
  type: 'object',
  required: ['text', 'embedding', 'embedding_config'],
  title: 'Passage',
  description: `Representation of a passage, which is stored in archival memory.

Parameters:
    text (str): The text of the passage.
    embedding (List[float]): The embedding of the passage.
    embedding_config (EmbeddingConfig): The embedding configuration used by the passage.
    created_at (datetime): The creation date of the passage.
    organization_id (str): The unique identifier of the organization associated with the passage.
    archive_id (str): The unique identifier of the archive containing this passage.
    source_id (str): The data source of the passage.
    file_id (str): The unique identifier of the file associated with the passage.`,
} as const;

export const $PipRequirement = {
  properties: {
    name: {
      type: 'string',
      minLength: 1,
      title: 'Name',
      description: 'Name of the pip package.',
    },
    version: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Version',
      description:
        'Optional version of the package, following semantic versioning.',
    },
  },
  type: 'object',
  required: ['name'],
  title: 'PipRequirement',
} as const;

export const $Provider = {
  properties: {
    id: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Id',
      description:
        'The id of the provider, lazily created by the database manager.',
    },
    name: {
      type: 'string',
      title: 'Name',
      description: 'The name of the provider',
    },
    provider_type: {
      $ref: '#/components/schemas/ProviderType',
      description: 'The type of the provider',
    },
    provider_category: {
      $ref: '#/components/schemas/ProviderCategory',
      description: 'The category of the provider (base or byok)',
    },
    api_key: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Api Key',
      description: 'API key or secret key used for requests to the provider.',
    },
    base_url: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Base Url',
      description: 'Base URL for the provider.',
    },
    access_key: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Access Key',
      description: 'Access key used for requests to the provider.',
    },
    region: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Region',
      description: 'Region used for requests to the provider.',
    },
    api_version: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Api Version',
      description: 'API version used for requests to the provider.',
    },
    organization_id: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Organization Id',
      description: 'The organization id of the user',
    },
    updated_at: {
      anyOf: [
        {
          type: 'string',
          format: 'date-time',
        },
        {
          type: 'null',
        },
      ],
      title: 'Updated At',
      description: 'The last update timestamp of the provider.',
    },
  },
  additionalProperties: false,
  type: 'object',
  required: ['name', 'provider_type', 'provider_category'],
  title: 'Provider',
} as const;

export const $ProviderCategory = {
  type: 'string',
  enum: ['base', 'byok'],
  title: 'ProviderCategory',
} as const;

export const $ProviderCheck = {
  properties: {
    provider_type: {
      $ref: '#/components/schemas/ProviderType',
      description: 'The type of the provider.',
    },
    api_key: {
      type: 'string',
      title: 'Api Key',
      description: 'API key or secret key used for requests to the provider.',
    },
    access_key: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Access Key',
      description: 'Access key used for requests to the provider.',
    },
    region: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Region',
      description: 'Region used for requests to the provider.',
    },
    base_url: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Base Url',
      description: 'Base URL used for requests to the provider.',
    },
    api_version: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Api Version',
      description: 'API version used for requests to the provider.',
    },
  },
  type: 'object',
  required: ['provider_type', 'api_key'],
  title: 'ProviderCheck',
} as const;

export const $ProviderCreate = {
  properties: {
    name: {
      type: 'string',
      title: 'Name',
      description: 'The name of the provider.',
    },
    provider_type: {
      $ref: '#/components/schemas/ProviderType',
      description: 'The type of the provider.',
    },
    api_key: {
      type: 'string',
      title: 'Api Key',
      description: 'API key or secret key used for requests to the provider.',
    },
    access_key: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Access Key',
      description: 'Access key used for requests to the provider.',
    },
    region: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Region',
      description: 'Region used for requests to the provider.',
    },
    base_url: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Base Url',
      description: 'Base URL used for requests to the provider.',
    },
    api_version: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Api Version',
      description: 'API version used for requests to the provider.',
    },
  },
  additionalProperties: false,
  type: 'object',
  required: ['name', 'provider_type', 'api_key'],
  title: 'ProviderCreate',
} as const;

export const $ProviderTrace = {
  properties: {
    created_by_id: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Created By Id',
      description: 'The id of the user that made this object.',
    },
    last_updated_by_id: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Last Updated By Id',
      description: 'The id of the user that made this object.',
    },
    created_at: {
      type: 'string',
      format: 'date-time',
      title: 'Created At',
      description: 'The timestamp when the object was created.',
    },
    updated_at: {
      anyOf: [
        {
          type: 'string',
          format: 'date-time',
        },
        {
          type: 'null',
        },
      ],
      title: 'Updated At',
      description: 'The timestamp when the object was last updated.',
    },
    id: {
      type: 'string',
      pattern: '^provider_trace-[a-fA-F0-9]{8}',
      title: 'Id',
      description: 'The human-friendly ID of the Provider_trace',
      examples: ['provider_trace-123e4567-e89b-12d3-a456-426614174000'],
    },
    request_json: {
      additionalProperties: true,
      type: 'object',
      title: 'Request Json',
      description: 'JSON content of the provider request',
    },
    response_json: {
      additionalProperties: true,
      type: 'object',
      title: 'Response Json',
      description: 'JSON content of the provider response',
    },
    step_id: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Step Id',
      description: 'ID of the step that this trace is associated with',
    },
  },
  additionalProperties: false,
  type: 'object',
  required: ['request_json', 'response_json'],
  title: 'ProviderTrace',
  description: `Letta's internal representation of a provider trace.

Attributes:
    id (str): The unique identifier of the provider trace.
    request_json (Dict[str, Any]): JSON content of the provider request.
    response_json (Dict[str, Any]): JSON content of the provider response.
    step_id (str): ID of the step that this trace is associated with.
    organization_id (str): The unique identifier of the organization.
    created_at (datetime): The timestamp when the object was created.`,
} as const;

export const $ProviderType = {
  type: 'string',
  enum: [
    'anthropic',
    'azure',
    'bedrock',
    'cerebras',
    'deepseek',
    'google_ai',
    'google_vertex',
    'groq',
    'hugging-face',
    'letta',
    'lmstudio_openai',
    'mistral',
    'ollama',
    'openai',
    'together',
    'vllm',
    'xai',
  ],
  title: 'ProviderType',
} as const;

export const $ProviderUpdate = {
  properties: {
    api_key: {
      type: 'string',
      title: 'Api Key',
      description: 'API key or secret key used for requests to the provider.',
    },
    access_key: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Access Key',
      description: 'Access key used for requests to the provider.',
    },
    region: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Region',
      description: 'Region used for requests to the provider.',
    },
    base_url: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Base Url',
      description: 'Base URL used for requests to the provider.',
    },
    api_version: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Api Version',
      description: 'API version used for requests to the provider.',
    },
  },
  additionalProperties: false,
  type: 'object',
  required: ['api_key'],
  title: 'ProviderUpdate',
} as const;

export const $ReasoningContent = {
  properties: {
    type: {
      type: 'string',
      const: 'reasoning',
      title: 'Type',
      description: 'Indicates this is a reasoning/intermediate step.',
      default: 'reasoning',
    },
    is_native: {
      type: 'boolean',
      title: 'Is Native',
      description:
        'Whether the reasoning content was generated by a reasoner model that processed this step.',
    },
    reasoning: {
      type: 'string',
      title: 'Reasoning',
      description: 'The intermediate reasoning or thought process content.',
    },
    signature: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Signature',
      description: 'A unique identifier for this reasoning step.',
    },
  },
  type: 'object',
  required: ['is_native', 'reasoning'],
  title: 'ReasoningContent',
  description: 'Sent via the Anthropic Messages API',
} as const;

export const $ReasoningMessage = {
  properties: {
    id: {
      type: 'string',
      title: 'Id',
    },
    date: {
      type: 'string',
      format: 'date-time',
      title: 'Date',
    },
    name: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Name',
    },
    message_type: {
      type: 'string',
      const: 'reasoning_message',
      title: 'Message Type',
      description: 'The type of the message.',
      default: 'reasoning_message',
    },
    otid: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Otid',
    },
    sender_id: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Sender Id',
    },
    step_id: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Step Id',
    },
    is_err: {
      anyOf: [
        {
          type: 'boolean',
        },
        {
          type: 'null',
        },
      ],
      title: 'Is Err',
    },
    seq_id: {
      anyOf: [
        {
          type: 'integer',
        },
        {
          type: 'null',
        },
      ],
      title: 'Seq Id',
    },
    run_id: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Run Id',
    },
    source: {
      type: 'string',
      enum: ['reasoner_model', 'non_reasoner_model'],
      title: 'Source',
      default: 'non_reasoner_model',
    },
    reasoning: {
      type: 'string',
      title: 'Reasoning',
    },
    signature: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Signature',
    },
  },
  type: 'object',
  required: ['id', 'date', 'reasoning'],
  title: 'ReasoningMessage',
  description: `Representation of an agent's internal reasoning.

Args:
    id (str): The ID of the message
    date (datetime): The date the message was created in ISO format
    name (Optional[str]): The name of the sender of the message
    source (Literal["reasoner_model", "non_reasoner_model"]): Whether the reasoning
        content was generated natively by a reasoner model or derived via prompting
    reasoning (str): The internal reasoning of the agent
    signature (Optional[str]): The model-generated signature of the reasoning step`,
} as const;

export const $RedactedReasoningContent = {
  properties: {
    type: {
      type: 'string',
      const: 'redacted_reasoning',
      title: 'Type',
      description: 'Indicates this is a redacted thinking step.',
      default: 'redacted_reasoning',
    },
    data: {
      type: 'string',
      title: 'Data',
      description: 'The redacted or filtered intermediate reasoning content.',
    },
  },
  type: 'object',
  required: ['data'],
  title: 'RedactedReasoningContent',
  description: 'Sent via the Anthropic Messages API',
} as const;

export const $RequiredBeforeExitToolRule = {
  properties: {
    tool_name: {
      type: 'string',
      title: 'Tool Name',
      description:
        "The name of the tool. Must exist in the database for the user's organization.",
    },
    type: {
      type: 'string',
      const: 'required_before_exit',
      title: 'Type',
      default: 'required_before_exit',
    },
    prompt_template: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Prompt Template',
      description: 'Optional template string (ignored).',
    },
  },
  additionalProperties: false,
  type: 'object',
  required: ['tool_name'],
  title: 'RequiredBeforeExitToolRule',
  description:
    'Represents a tool rule configuration where this tool must be called before the agent loop can exit.',
} as const;

export const $RequiresApprovalToolRule = {
  properties: {
    tool_name: {
      type: 'string',
      title: 'Tool Name',
      description:
        "The name of the tool. Must exist in the database for the user's organization.",
    },
    type: {
      type: 'string',
      const: 'requires_approval',
      title: 'Type',
      default: 'requires_approval',
    },
    prompt_template: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Prompt Template',
      description:
        'Optional template string (ignored). Rendering uses fast built-in formatting for performance.',
    },
  },
  additionalProperties: false,
  type: 'object',
  required: ['tool_name'],
  title: 'RequiresApprovalToolRule',
  description:
    'Represents a tool rule configuration which requires approval before the tool can be invoked.',
} as const;

export const $RetrieveStreamRequest = {
  properties: {
    starting_after: {
      type: 'integer',
      title: 'Starting After',
      description:
        'Sequence id to use as a cursor for pagination. Response will start streaming after this chunk sequence id',
      default: 0,
    },
    include_pings: {
      anyOf: [
        {
          type: 'boolean',
        },
        {
          type: 'null',
        },
      ],
      title: 'Include Pings',
      description:
        'Whether to include periodic keepalive ping messages in the stream to prevent connection timeouts.',
      default: true,
    },
    poll_interval: {
      anyOf: [
        {
          type: 'number',
        },
        {
          type: 'null',
        },
      ],
      title: 'Poll Interval',
      description: 'Seconds to wait between polls when no new data.',
      default: 0.1,
    },
    batch_size: {
      anyOf: [
        {
          type: 'integer',
        },
        {
          type: 'null',
        },
      ],
      title: 'Batch Size',
      description: 'Number of entries to read per batch.',
      default: 100,
    },
  },
  type: 'object',
  title: 'RetrieveStreamRequest',
} as const;

export const $RoundRobinManager = {
  properties: {
    manager_type: {
      type: 'string',
      const: 'round_robin',
      title: 'Manager Type',
      description: '',
      default: 'round_robin',
    },
    max_turns: {
      anyOf: [
        {
          type: 'integer',
        },
        {
          type: 'null',
        },
      ],
      title: 'Max Turns',
      description: '',
    },
  },
  type: 'object',
  title: 'RoundRobinManager',
} as const;

export const $RoundRobinManagerUpdate = {
  properties: {
    manager_type: {
      type: 'string',
      const: 'round_robin',
      title: 'Manager Type',
      description: '',
      default: 'round_robin',
    },
    max_turns: {
      anyOf: [
        {
          type: 'integer',
        },
        {
          type: 'null',
        },
      ],
      title: 'Max Turns',
      description: '',
    },
  },
  type: 'object',
  title: 'RoundRobinManagerUpdate',
} as const;

export const $Run = {
  properties: {
    id: {
      type: 'string',
      pattern: '^(job|run)-[a-fA-F0-9]{8}',
      title: 'Id',
      description: 'The human-friendly ID of the Run',
      examples: ['run-123e4567-e89b-12d3-a456-426614174000'],
    },
    status: {
      $ref: '#/components/schemas/RunStatus',
      description: 'The current status of the run.',
      default: 'created',
    },
    created_at: {
      type: 'string',
      format: 'date-time',
      title: 'Created At',
      description: 'The timestamp when the run was created.',
    },
    completed_at: {
      anyOf: [
        {
          type: 'string',
          format: 'date-time',
        },
        {
          type: 'null',
        },
      ],
      title: 'Completed At',
      description: 'The timestamp when the run was completed.',
    },
    agent_id: {
      type: 'string',
      title: 'Agent Id',
      description:
        'The unique identifier of the agent associated with the run.',
    },
    background: {
      anyOf: [
        {
          type: 'boolean',
        },
        {
          type: 'null',
        },
      ],
      title: 'Background',
      description: 'Whether the run was created in background mode.',
    },
    metadata: {
      anyOf: [
        {
          additionalProperties: true,
          type: 'object',
        },
        {
          type: 'null',
        },
      ],
      title: 'Metadata',
      description: 'Additional metadata for the run.',
    },
    request_config: {
      anyOf: [
        {
          $ref: '#/components/schemas/LettaRequestConfig',
        },
        {
          type: 'null',
        },
      ],
      description: 'The request configuration for the run.',
    },
    stop_reason: {
      anyOf: [
        {
          $ref: '#/components/schemas/StopReasonType',
        },
        {
          type: 'null',
        },
      ],
      description: 'The reason why the run was stopped.',
    },
    callback_url: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Callback Url',
      description: 'If set, POST to this URL when the run completes.',
    },
    callback_sent_at: {
      anyOf: [
        {
          type: 'string',
          format: 'date-time',
        },
        {
          type: 'null',
        },
      ],
      title: 'Callback Sent At',
      description: 'Timestamp when the callback was last attempted.',
    },
    callback_status_code: {
      anyOf: [
        {
          type: 'integer',
        },
        {
          type: 'null',
        },
      ],
      title: 'Callback Status Code',
      description: 'HTTP status code returned by the callback endpoint.',
    },
    callback_error: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Callback Error',
      description:
        'Optional error message from attempting to POST the callback endpoint.',
    },
    ttft_ns: {
      anyOf: [
        {
          type: 'integer',
        },
        {
          type: 'null',
        },
      ],
      title: 'Ttft Ns',
      description: 'Time to first token for a run in nanoseconds',
    },
    total_duration_ns: {
      anyOf: [
        {
          type: 'integer',
        },
        {
          type: 'null',
        },
      ],
      title: 'Total Duration Ns',
      description: 'Total run duration in nanoseconds',
    },
  },
  additionalProperties: false,
  type: 'object',
  required: ['agent_id'],
  title: 'Run',
  description: `Representation of a run - a conversation or processing session for an agent.
Runs track when agents process messages and maintain the relationship between agents, steps, and messages.

Parameters:
    id (str): The unique identifier of the run (prefixed with 'run-').
    status (JobStatus): The current status of the run.
    created_at (datetime): The timestamp when the run was created.
    completed_at (datetime): The timestamp when the run was completed.
    agent_id (str): The unique identifier of the agent associated with the run.
    stop_reason (StopReasonType): The reason why the run was stopped.
    background (bool): Whether the run was created in background mode.
    metadata (dict): Additional metadata for the run.
    request_config (LettaRequestConfig): The request configuration for the run.`,
} as const;

export const $RunStatus = {
  type: 'string',
  enum: ['created', 'running', 'completed', 'failed', 'cancelled'],
  title: 'RunStatus',
  description: 'Status of the run.',
} as const;

export const $SSEServerConfig = {
  properties: {
    server_name: {
      type: 'string',
      title: 'Server Name',
      description: 'The name of the server',
    },
    type: {
      $ref: '#/components/schemas/MCPServerType',
      default: 'sse',
    },
    server_url: {
      type: 'string',
      title: 'Server Url',
      description:
        'The URL of the server (MCP SSE client will connect to this URL)',
    },
    auth_header: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Auth Header',
      description:
        "The name of the authentication header (e.g., 'Authorization')",
    },
    auth_token: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Auth Token',
      description: 'The authentication token or API key value',
    },
    custom_headers: {
      anyOf: [
        {
          additionalProperties: {
            type: 'string',
          },
          type: 'object',
        },
        {
          type: 'null',
        },
      ],
      title: 'Custom Headers',
      description: 'Custom HTTP headers to include with SSE requests',
    },
  },
  type: 'object',
  required: ['server_name', 'server_url'],
  title: 'SSEServerConfig',
  description: `Configuration for an MCP server using SSE

Authentication can be provided in multiple ways:
1. Using auth_header + auth_token: Will add a specific header with the token
   Example: auth_header="Authorization", auth_token="Bearer abc123"

2. Using the custom_headers dict: For more complex authentication scenarios
   Example: custom_headers={"X-API-Key": "abc123", "X-Custom-Header": "value"}`,
} as const;

export const $SandboxConfig = {
  properties: {
    created_by_id: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Created By Id',
      description: 'The id of the user that made this object.',
    },
    last_updated_by_id: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Last Updated By Id',
      description: 'The id of the user that made this object.',
    },
    created_at: {
      anyOf: [
        {
          type: 'string',
          format: 'date-time',
        },
        {
          type: 'null',
        },
      ],
      title: 'Created At',
      description: 'The timestamp when the object was created.',
    },
    updated_at: {
      anyOf: [
        {
          type: 'string',
          format: 'date-time',
        },
        {
          type: 'null',
        },
      ],
      title: 'Updated At',
      description: 'The timestamp when the object was last updated.',
    },
    id: {
      type: 'string',
      pattern: '^sandbox-[a-fA-F0-9]{8}',
      title: 'Id',
      description: 'The human-friendly ID of the Sandbox',
      examples: ['sandbox-123e4567-e89b-12d3-a456-426614174000'],
    },
    type: {
      $ref: '#/components/schemas/SandboxType',
      description: 'The type of sandbox.',
    },
    organization_id: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Organization Id',
      description:
        'The unique identifier of the organization associated with the sandbox.',
    },
    config: {
      additionalProperties: true,
      type: 'object',
      title: 'Config',
      description: 'The JSON sandbox settings data.',
    },
  },
  additionalProperties: false,
  type: 'object',
  title: 'SandboxConfig',
} as const;

export const $SandboxConfigCreate = {
  properties: {
    config: {
      anyOf: [
        {
          $ref: '#/components/schemas/LocalSandboxConfig',
        },
        {
          $ref: '#/components/schemas/E2BSandboxConfig',
        },
        {
          $ref: '#/components/schemas/ModalSandboxConfig',
        },
      ],
      title: 'Config',
      description: 'The configuration for the sandbox.',
    },
  },
  additionalProperties: false,
  type: 'object',
  required: ['config'],
  title: 'SandboxConfigCreate',
} as const;

export const $SandboxConfigUpdate = {
  properties: {
    config: {
      anyOf: [
        {
          $ref: '#/components/schemas/LocalSandboxConfig',
        },
        {
          $ref: '#/components/schemas/E2BSandboxConfig',
        },
        {
          $ref: '#/components/schemas/ModalSandboxConfig',
        },
      ],
      title: 'Config',
      description: 'The JSON configuration data for the sandbox.',
    },
  },
  additionalProperties: false,
  type: 'object',
  title: 'SandboxConfigUpdate',
  description: 'Pydantic model for updating SandboxConfig fields.',
} as const;

export const $SandboxEnvironmentVariable = {
  properties: {
    created_by_id: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Created By Id',
      description: 'The id of the user that made this object.',
    },
    last_updated_by_id: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Last Updated By Id',
      description: 'The id of the user that made this object.',
    },
    created_at: {
      anyOf: [
        {
          type: 'string',
          format: 'date-time',
        },
        {
          type: 'null',
        },
      ],
      title: 'Created At',
      description: 'The timestamp when the object was created.',
    },
    updated_at: {
      anyOf: [
        {
          type: 'string',
          format: 'date-time',
        },
        {
          type: 'null',
        },
      ],
      title: 'Updated At',
      description: 'The timestamp when the object was last updated.',
    },
    id: {
      type: 'string',
      pattern: '^sandbox-env-[a-fA-F0-9]{8}',
      title: 'Id',
      description: 'The human-friendly ID of the Sandbox-env',
      examples: ['sandbox-env-123e4567-e89b-12d3-a456-426614174000'],
    },
    key: {
      type: 'string',
      title: 'Key',
      description: 'The name of the environment variable.',
    },
    value: {
      type: 'string',
      title: 'Value',
      description: 'The value of the environment variable.',
    },
    description: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Description',
      description: 'An optional description of the environment variable.',
    },
    organization_id: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Organization Id',
      description:
        'The ID of the organization this environment variable belongs to.',
    },
    sandbox_config_id: {
      type: 'string',
      title: 'Sandbox Config Id',
      description:
        'The ID of the sandbox config this environment variable belongs to.',
    },
  },
  additionalProperties: false,
  type: 'object',
  required: ['key', 'value', 'sandbox_config_id'],
  title: 'SandboxEnvironmentVariable',
} as const;

export const $SandboxEnvironmentVariableCreate = {
  properties: {
    key: {
      type: 'string',
      title: 'Key',
      description: 'The name of the environment variable.',
    },
    value: {
      type: 'string',
      title: 'Value',
      description: 'The value of the environment variable.',
    },
    description: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Description',
      description: 'An optional description of the environment variable.',
    },
  },
  additionalProperties: false,
  type: 'object',
  required: ['key', 'value'],
  title: 'SandboxEnvironmentVariableCreate',
} as const;

export const $SandboxEnvironmentVariableUpdate = {
  properties: {
    key: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Key',
      description: 'The name of the environment variable.',
    },
    value: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Value',
      description: 'The value of the environment variable.',
    },
    description: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Description',
      description: 'An optional description of the environment variable.',
    },
  },
  additionalProperties: false,
  type: 'object',
  title: 'SandboxEnvironmentVariableUpdate',
} as const;

export const $SandboxType = {
  type: 'string',
  enum: ['e2b', 'modal', 'local'],
  title: 'SandboxType',
} as const;

export const $SleeptimeManager = {
  properties: {
    manager_type: {
      type: 'string',
      const: 'sleeptime',
      title: 'Manager Type',
      description: '',
      default: 'sleeptime',
    },
    manager_agent_id: {
      type: 'string',
      title: 'Manager Agent Id',
      description: '',
    },
    sleeptime_agent_frequency: {
      anyOf: [
        {
          type: 'integer',
        },
        {
          type: 'null',
        },
      ],
      title: 'Sleeptime Agent Frequency',
      description: '',
    },
  },
  type: 'object',
  required: ['manager_agent_id'],
  title: 'SleeptimeManager',
} as const;

export const $SleeptimeManagerUpdate = {
  properties: {
    manager_type: {
      type: 'string',
      const: 'sleeptime',
      title: 'Manager Type',
      description: '',
      default: 'sleeptime',
    },
    manager_agent_id: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Manager Agent Id',
      description: '',
    },
    sleeptime_agent_frequency: {
      anyOf: [
        {
          type: 'integer',
        },
        {
          type: 'null',
        },
      ],
      title: 'Sleeptime Agent Frequency',
      description: '',
    },
  },
  type: 'object',
  title: 'SleeptimeManagerUpdate',
} as const;

export const $Source = {
  properties: {
    name: {
      type: 'string',
      title: 'Name',
      description: 'The name of the source.',
    },
    description: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Description',
      description: 'The description of the source.',
    },
    instructions: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Instructions',
      description: 'Instructions for how to use the source.',
    },
    metadata: {
      anyOf: [
        {
          additionalProperties: true,
          type: 'object',
        },
        {
          type: 'null',
        },
      ],
      title: 'Metadata',
      description: 'Metadata associated with the source.',
    },
    id: {
      type: 'string',
      pattern: '^source-[a-fA-F0-9]{8}',
      title: 'Id',
      description: 'The human-friendly ID of the Source',
      examples: ['source-123e4567-e89b-12d3-a456-426614174000'],
    },
    embedding_config: {
      $ref: '#/components/schemas/EmbeddingConfig',
      description: 'The embedding configuration used by the source.',
    },
    organization_id: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Organization Id',
      description: 'The ID of the organization that created the source.',
    },
    vector_db_provider: {
      $ref: '#/components/schemas/VectorDBProvider',
      description:
        "The vector database provider used for this source's passages",
      default: 'native',
    },
    created_by_id: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Created By Id',
      description: 'The id of the user that made this Tool.',
    },
    last_updated_by_id: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Last Updated By Id',
      description: 'The id of the user that made this Tool.',
    },
    created_at: {
      anyOf: [
        {
          type: 'string',
          format: 'date-time',
        },
        {
          type: 'null',
        },
      ],
      title: 'Created At',
      description: 'The timestamp when the source was created.',
    },
    updated_at: {
      anyOf: [
        {
          type: 'string',
          format: 'date-time',
        },
        {
          type: 'null',
        },
      ],
      title: 'Updated At',
      description: 'The timestamp when the source was last updated.',
    },
  },
  additionalProperties: false,
  type: 'object',
  required: ['name', 'embedding_config'],
  title: 'Source',
  description: `Representation of a source, which is a collection of files and passages.

Parameters:
    id (str): The ID of the source
    name (str): The name of the source.
    embedding_config (EmbeddingConfig): The embedding configuration used by the source.
    user_id (str): The ID of the user that created the source.
    metadata (dict): Metadata associated with the source.
    description (str): The description of the source.`,
} as const;

export const $SourceCreate = {
  properties: {
    name: {
      type: 'string',
      title: 'Name',
      description: 'The name of the source.',
    },
    description: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Description',
      description: 'The description of the source.',
    },
    instructions: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Instructions',
      description: 'Instructions for how to use the source.',
    },
    metadata: {
      anyOf: [
        {
          additionalProperties: true,
          type: 'object',
        },
        {
          type: 'null',
        },
      ],
      title: 'Metadata',
      description: 'Metadata associated with the source.',
    },
    embedding: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Embedding',
      description: 'The handle for the embedding config used by the source.',
    },
    embedding_chunk_size: {
      anyOf: [
        {
          type: 'integer',
        },
        {
          type: 'null',
        },
      ],
      title: 'Embedding Chunk Size',
      description: 'The chunk size of the embedding.',
    },
    embedding_config: {
      anyOf: [
        {
          $ref: '#/components/schemas/EmbeddingConfig',
        },
        {
          type: 'null',
        },
      ],
      description: '(Legacy) The embedding configuration used by the source.',
    },
  },
  additionalProperties: false,
  type: 'object',
  required: ['name'],
  title: 'SourceCreate',
  description: 'Schema for creating a new Source.',
} as const;

export const $SourceSchema = {
  properties: {
    name: {
      type: 'string',
      title: 'Name',
      description: 'The name of the source.',
    },
    description: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Description',
      description: 'The description of the source.',
    },
    instructions: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Instructions',
      description: 'Instructions for how to use the source.',
    },
    metadata: {
      anyOf: [
        {
          additionalProperties: true,
          type: 'object',
        },
        {
          type: 'null',
        },
      ],
      title: 'Metadata',
      description: 'Metadata associated with the source.',
    },
    embedding: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Embedding',
      description: 'The handle for the embedding config used by the source.',
    },
    embedding_chunk_size: {
      anyOf: [
        {
          type: 'integer',
        },
        {
          type: 'null',
        },
      ],
      title: 'Embedding Chunk Size',
      description: 'The chunk size of the embedding.',
    },
    embedding_config: {
      anyOf: [
        {
          $ref: '#/components/schemas/EmbeddingConfig',
        },
        {
          type: 'null',
        },
      ],
      description: '(Legacy) The embedding configuration used by the source.',
    },
    id: {
      type: 'string',
      title: 'Id',
      description: 'Human-readable identifier for this source in the file',
    },
  },
  additionalProperties: false,
  type: 'object',
  required: ['name', 'id'],
  title: 'SourceSchema',
  description: 'Source with human-readable ID for agent file',
} as const;

export const $SourceStats = {
  properties: {
    source_id: {
      type: 'string',
      title: 'Source Id',
      description: 'Unique identifier of the source',
    },
    source_name: {
      type: 'string',
      title: 'Source Name',
      description: 'Name of the source',
    },
    file_count: {
      type: 'integer',
      title: 'File Count',
      description: 'Number of files in the source',
      default: 0,
    },
    total_size: {
      type: 'integer',
      title: 'Total Size',
      description: 'Total size of all files in bytes',
      default: 0,
    },
    files: {
      items: {
        $ref: '#/components/schemas/FileStats',
      },
      type: 'array',
      title: 'Files',
      description: 'List of file statistics',
    },
  },
  additionalProperties: false,
  type: 'object',
  required: ['source_id', 'source_name'],
  title: 'SourceStats',
  description: 'Aggregated metadata for a source',
} as const;

export const $SourceUpdate = {
  properties: {
    name: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Name',
      description: 'The name of the source.',
    },
    description: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Description',
      description: 'The description of the source.',
    },
    instructions: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Instructions',
      description: 'Instructions for how to use the source.',
    },
    metadata: {
      anyOf: [
        {
          additionalProperties: true,
          type: 'object',
        },
        {
          type: 'null',
        },
      ],
      title: 'Metadata',
      description: 'Metadata associated with the source.',
    },
    embedding_config: {
      anyOf: [
        {
          $ref: '#/components/schemas/EmbeddingConfig',
        },
        {
          type: 'null',
        },
      ],
      description: 'The embedding configuration used by the source.',
    },
  },
  additionalProperties: false,
  type: 'object',
  title: 'SourceUpdate',
  description: 'Schema for updating an existing Source.',
} as const;

export const $StdioServerConfig = {
  properties: {
    server_name: {
      type: 'string',
      title: 'Server Name',
      description: 'The name of the server',
    },
    type: {
      $ref: '#/components/schemas/MCPServerType',
      default: 'stdio',
    },
    command: {
      type: 'string',
      title: 'Command',
      description:
        "The command to run (MCP 'local' client will run this command)",
    },
    args: {
      items: {
        type: 'string',
      },
      type: 'array',
      title: 'Args',
      description: 'The arguments to pass to the command',
    },
    env: {
      anyOf: [
        {
          additionalProperties: {
            type: 'string',
          },
          type: 'object',
        },
        {
          type: 'null',
        },
      ],
      title: 'Env',
      description: 'Environment variables to set',
    },
  },
  type: 'object',
  required: ['server_name', 'command', 'args'],
  title: 'StdioServerConfig',
} as const;

export const $Step = {
  properties: {
    id: {
      type: 'string',
      title: 'Id',
      description: 'The id of the step. Assigned by the database.',
    },
    origin: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Origin',
      description: 'The surface that this agent step was initiated from.',
    },
    organization_id: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Organization Id',
      description:
        'The unique identifier of the organization associated with the step.',
    },
    provider_id: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Provider Id',
      description:
        'The unique identifier of the provider that was configured for this step',
    },
    run_id: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Run Id',
      description:
        'The unique identifier of the run that this step belongs to. Only included for async calls.',
    },
    agent_id: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Agent Id',
      description: 'The ID of the agent that performed the step.',
    },
    provider_name: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Provider Name',
      description: 'The name of the provider used for this step.',
    },
    provider_category: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Provider Category',
      description: 'The category of the provider used for this step.',
    },
    model: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Model',
      description: 'The name of the model used for this step.',
    },
    model_endpoint: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Model Endpoint',
      description: 'The model endpoint url used for this step.',
    },
    context_window_limit: {
      anyOf: [
        {
          type: 'integer',
        },
        {
          type: 'null',
        },
      ],
      title: 'Context Window Limit',
      description: 'The context window limit configured for this step.',
    },
    completion_tokens: {
      anyOf: [
        {
          type: 'integer',
        },
        {
          type: 'null',
        },
      ],
      title: 'Completion Tokens',
      description:
        'The number of tokens generated by the agent during this step.',
    },
    prompt_tokens: {
      anyOf: [
        {
          type: 'integer',
        },
        {
          type: 'null',
        },
      ],
      title: 'Prompt Tokens',
      description: 'The number of tokens in the prompt during this step.',
    },
    total_tokens: {
      anyOf: [
        {
          type: 'integer',
        },
        {
          type: 'null',
        },
      ],
      title: 'Total Tokens',
      description:
        'The total number of tokens processed by the agent during this step.',
    },
    completion_tokens_details: {
      anyOf: [
        {
          additionalProperties: true,
          type: 'object',
        },
        {
          type: 'null',
        },
      ],
      title: 'Completion Tokens Details',
      description: 'Metadata for the agent.',
    },
    stop_reason: {
      anyOf: [
        {
          $ref: '#/components/schemas/StopReasonType',
        },
        {
          type: 'null',
        },
      ],
      description: 'The stop reason associated with the step.',
    },
    tags: {
      items: {
        type: 'string',
      },
      type: 'array',
      title: 'Tags',
      description: 'Metadata tags.',
      default: [],
    },
    tid: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Tid',
      description:
        'The unique identifier of the transaction that processed this step.',
    },
    trace_id: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Trace Id',
      description: 'The trace id of the agent step.',
    },
    messages: {
      items: {
        $ref: '#/components/schemas/Message',
      },
      type: 'array',
      title: 'Messages',
      description:
        'The messages generated during this step. Deprecated: use `GET /v1/steps/{step_id}/messages` endpoint instead',
      default: [],
      deprecated: true,
    },
    feedback: {
      anyOf: [
        {
          type: 'string',
          enum: ['positive', 'negative'],
        },
        {
          type: 'null',
        },
      ],
      title: 'Feedback',
      description:
        "The feedback for this step. Must be either 'positive' or 'negative'.",
    },
    project_id: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Project Id',
      description:
        'The project that the agent that executed this step belongs to (cloud only).',
    },
    error_type: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Error Type',
      description: 'The type/class of the error that occurred',
    },
    error_data: {
      anyOf: [
        {
          additionalProperties: true,
          type: 'object',
        },
        {
          type: 'null',
        },
      ],
      title: 'Error Data',
      description:
        'Error details including message, traceback, and additional context',
    },
    status: {
      anyOf: [
        {
          $ref: '#/components/schemas/StepStatus',
        },
        {
          type: 'null',
        },
      ],
      description: 'Step status: pending, success, or failed',
      default: 'pending',
    },
  },
  additionalProperties: false,
  type: 'object',
  required: ['id'],
  title: 'Step',
} as const;

export const $StepMetrics = {
  properties: {
    id: {
      type: 'string',
      title: 'Id',
      description:
        'The id of the step this metric belongs to (matches steps.id).',
    },
    organization_id: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Organization Id',
      description: 'The unique identifier of the organization.',
    },
    provider_id: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Provider Id',
      description: 'The unique identifier of the provider.',
    },
    run_id: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Run Id',
      description: 'The unique identifier of the run.',
    },
    agent_id: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Agent Id',
      description: 'The unique identifier of the agent.',
    },
    step_start_ns: {
      anyOf: [
        {
          type: 'integer',
        },
        {
          type: 'null',
        },
      ],
      title: 'Step Start Ns',
      description: 'The timestamp of the start of the step in nanoseconds.',
    },
    llm_request_start_ns: {
      anyOf: [
        {
          type: 'integer',
        },
        {
          type: 'null',
        },
      ],
      title: 'Llm Request Start Ns',
      description:
        'The timestamp of the start of the llm request in nanoseconds.',
    },
    llm_request_ns: {
      anyOf: [
        {
          type: 'integer',
        },
        {
          type: 'null',
        },
      ],
      title: 'Llm Request Ns',
      description: 'Time spent on LLM requests in nanoseconds.',
    },
    tool_execution_ns: {
      anyOf: [
        {
          type: 'integer',
        },
        {
          type: 'null',
        },
      ],
      title: 'Tool Execution Ns',
      description: 'Time spent on tool execution in nanoseconds.',
    },
    step_ns: {
      anyOf: [
        {
          type: 'integer',
        },
        {
          type: 'null',
        },
      ],
      title: 'Step Ns',
      description: 'Total time for the step in nanoseconds.',
    },
    base_template_id: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Base Template Id',
      description:
        'The base template ID that the step belongs to (cloud only).',
    },
    template_id: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Template Id',
      description: 'The template ID that the step belongs to (cloud only).',
    },
    project_id: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Project Id',
      description: 'The project that the step belongs to (cloud only).',
    },
  },
  additionalProperties: false,
  type: 'object',
  required: ['id'],
  title: 'StepMetrics',
} as const;

export const $StepStatus = {
  type: 'string',
  enum: ['pending', 'success', 'failed', 'cancelled'],
  title: 'StepStatus',
  description: 'Status of a step execution',
} as const;

export const $StopReasonType = {
  type: 'string',
  enum: [
    'end_turn',
    'error',
    'llm_api_error',
    'invalid_llm_response',
    'invalid_tool_call',
    'max_steps',
    'no_tool_call',
    'tool_rule',
    'cancelled',
    'requires_approval',
  ],
  title: 'StopReasonType',
} as const;

export const $StreamableHTTPServerConfig = {
  properties: {
    server_name: {
      type: 'string',
      title: 'Server Name',
      description: 'The name of the server',
    },
    type: {
      $ref: '#/components/schemas/MCPServerType',
      default: 'streamable_http',
    },
    server_url: {
      type: 'string',
      title: 'Server Url',
      description:
        "The URL path for the streamable HTTP server (e.g., 'example/mcp')",
    },
    auth_header: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Auth Header',
      description:
        "The name of the authentication header (e.g., 'Authorization')",
    },
    auth_token: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Auth Token',
      description: 'The authentication token or API key value',
    },
    custom_headers: {
      anyOf: [
        {
          additionalProperties: {
            type: 'string',
          },
          type: 'object',
        },
        {
          type: 'null',
        },
      ],
      title: 'Custom Headers',
      description:
        'Custom HTTP headers to include with streamable HTTP requests',
    },
  },
  type: 'object',
  required: ['server_name', 'server_url'],
  title: 'StreamableHTTPServerConfig',
  description: `Configuration for an MCP server using Streamable HTTP

Authentication can be provided in multiple ways:
1. Using auth_header + auth_token: Will add a specific header with the token
   Example: auth_header="Authorization", auth_token="Bearer abc123"

2. Using the custom_headers dict: For more complex authentication scenarios
   Example: custom_headers={"X-API-Key": "abc123", "X-Custom-Header": "value"}`,
} as const;

export const $SummarizedReasoningContent = {
  properties: {
    type: {
      type: 'string',
      const: 'summarized_reasoning',
      title: 'Type',
      description: 'Indicates this is a summarized reasoning step.',
      default: 'summarized_reasoning',
    },
    id: {
      type: 'string',
      title: 'Id',
      description: 'The unique identifier for this reasoning step.',
    },
    summary: {
      items: {
        $ref: '#/components/schemas/SummarizedReasoningContentPart',
      },
      type: 'array',
      title: 'Summary',
      description: 'Summaries of the reasoning content.',
    },
    encrypted_content: {
      type: 'string',
      title: 'Encrypted Content',
      description: 'The encrypted reasoning content.',
    },
  },
  type: 'object',
  required: ['id', 'summary'],
  title: 'SummarizedReasoningContent',
  description:
    'The style of reasoning content returned by the OpenAI Responses API',
} as const;

export const $SummarizedReasoningContentPart = {
  properties: {
    index: {
      type: 'integer',
      title: 'Index',
      description: 'The index of the summary part.',
    },
    text: {
      type: 'string',
      title: 'Text',
      description: 'The text of the summary part.',
    },
  },
  type: 'object',
  required: ['index', 'text'],
  title: 'SummarizedReasoningContentPart',
} as const;

export const $SupervisorManager = {
  properties: {
    manager_type: {
      type: 'string',
      const: 'supervisor',
      title: 'Manager Type',
      description: '',
      default: 'supervisor',
    },
    manager_agent_id: {
      type: 'string',
      title: 'Manager Agent Id',
      description: '',
    },
  },
  type: 'object',
  required: ['manager_agent_id'],
  title: 'SupervisorManager',
} as const;

export const $SupervisorManagerUpdate = {
  properties: {
    manager_type: {
      type: 'string',
      const: 'supervisor',
      title: 'Manager Type',
      description: '',
      default: 'supervisor',
    },
    manager_agent_id: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Manager Agent Id',
      description: '',
    },
  },
  type: 'object',
  required: ['manager_agent_id'],
  title: 'SupervisorManagerUpdate',
} as const;

export const $SystemMessage = {
  properties: {
    id: {
      type: 'string',
      title: 'Id',
    },
    date: {
      type: 'string',
      format: 'date-time',
      title: 'Date',
    },
    name: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Name',
    },
    message_type: {
      type: 'string',
      const: 'system_message',
      title: 'Message Type',
      description: 'The type of the message.',
      default: 'system_message',
    },
    otid: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Otid',
    },
    sender_id: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Sender Id',
    },
    step_id: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Step Id',
    },
    is_err: {
      anyOf: [
        {
          type: 'boolean',
        },
        {
          type: 'null',
        },
      ],
      title: 'Is Err',
    },
    seq_id: {
      anyOf: [
        {
          type: 'integer',
        },
        {
          type: 'null',
        },
      ],
      title: 'Seq Id',
    },
    run_id: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Run Id',
    },
    content: {
      type: 'string',
      title: 'Content',
      description: 'The message content sent by the system',
    },
  },
  type: 'object',
  required: ['id', 'date', 'content'],
  title: 'SystemMessage',
  description: `A message generated by the system. Never streamed back on a response, only used for cursor pagination.

Args:
    id (str): The ID of the message
    date (datetime): The date the message was created in ISO format
    name (Optional[str]): The name of the sender of the message
    content (str): The message content sent by the system`,
} as const;

export const $TagSchema = {
  properties: {
    tag: {
      type: 'string',
      title: 'Tag',
    },
  },
  type: 'object',
  required: ['tag'],
  title: 'TagSchema',
} as const;

export const $TerminalToolRule = {
  properties: {
    tool_name: {
      type: 'string',
      title: 'Tool Name',
      description:
        "The name of the tool. Must exist in the database for the user's organization.",
    },
    type: {
      type: 'string',
      const: 'exit_loop',
      title: 'Type',
      default: 'exit_loop',
    },
    prompt_template: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Prompt Template',
      description: 'Optional template string (ignored).',
    },
  },
  additionalProperties: false,
  type: 'object',
  required: ['tool_name'],
  title: 'TerminalToolRule',
  description:
    'Represents a terminal tool rule configuration where if this tool gets called, it must end the agent loop.',
} as const;

export const $TextContent = {
  properties: {
    type: {
      type: 'string',
      const: 'text',
      title: 'Type',
      description: 'The type of the message.',
      default: 'text',
    },
    text: {
      type: 'string',
      title: 'Text',
      description: 'The text content of the message.',
    },
    signature: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Signature',
      description:
        'Stores a unique identifier for any reasoning associated with this text content.',
    },
  },
  type: 'object',
  required: ['text'],
  title: 'TextContent',
} as const;

export const $TextResponseFormat = {
  properties: {
    type: {
      type: 'string',
      const: 'text',
      title: 'Type',
      description: 'The type of the response format.',
      default: 'text',
    },
  },
  type: 'object',
  title: 'TextResponseFormat',
  description: 'Response format for plain text responses.',
} as const;

export const $Tool = {
  properties: {
    id: {
      type: 'string',
      pattern: '^tool-[a-fA-F0-9]{8}',
      title: 'Id',
      description: 'The human-friendly ID of the Tool',
      examples: ['tool-123e4567-e89b-12d3-a456-426614174000'],
    },
    tool_type: {
      $ref: '#/components/schemas/ToolType',
      description: 'The type of the tool.',
      default: 'custom',
    },
    description: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Description',
      description: 'The description of the tool.',
    },
    source_type: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Source Type',
      description: 'The type of the source code.',
    },
    name: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Name',
      description: 'The name of the function.',
    },
    tags: {
      items: {
        type: 'string',
      },
      type: 'array',
      title: 'Tags',
      description: 'Metadata tags.',
      default: [],
    },
    source_code: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Source Code',
      description: 'The source code of the function.',
    },
    json_schema: {
      anyOf: [
        {
          additionalProperties: true,
          type: 'object',
        },
        {
          type: 'null',
        },
      ],
      title: 'Json Schema',
      description: 'The JSON schema of the function.',
    },
    args_json_schema: {
      anyOf: [
        {
          additionalProperties: true,
          type: 'object',
        },
        {
          type: 'null',
        },
      ],
      title: 'Args Json Schema',
      description: 'The args JSON schema of the function.',
    },
    return_char_limit: {
      type: 'integer',
      title: 'Return Char Limit',
      description: 'The maximum number of characters in the response.',
      default: 50000,
    },
    pip_requirements: {
      anyOf: [
        {
          items: {
            $ref: '#/components/schemas/PipRequirement',
          },
          type: 'array',
        },
        {
          type: 'null',
        },
      ],
      title: 'Pip Requirements',
      description: 'Optional list of pip packages required by this tool.',
    },
    npm_requirements: {
      anyOf: [
        {
          items: {
            $ref: '#/components/schemas/NpmRequirement',
          },
          type: 'array',
        },
        {
          type: 'null',
        },
      ],
      title: 'Npm Requirements',
      description: 'Optional list of npm packages required by this tool.',
    },
    default_requires_approval: {
      anyOf: [
        {
          type: 'boolean',
        },
        {
          type: 'null',
        },
      ],
      title: 'Default Requires Approval',
      description:
        'Default value for whether or not executing this tool requires approval.',
    },
    created_by_id: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Created By Id',
      description: 'The id of the user that made this Tool.',
    },
    last_updated_by_id: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Last Updated By Id',
      description: 'The id of the user that made this Tool.',
    },
    metadata_: {
      anyOf: [
        {
          additionalProperties: true,
          type: 'object',
        },
        {
          type: 'null',
        },
      ],
      title: 'Metadata',
      description: 'A dictionary of additional metadata for the tool.',
    },
  },
  additionalProperties: false,
  type: 'object',
  title: 'Tool',
  description: `Representation of a tool, which is a function that can be called by the agent.

Parameters:
    id (str): The unique identifier of the tool.
    name (str): The name of the function.
    tags (List[str]): Metadata tags.
    source_code (str): The source code of the function.
    json_schema (Dict): The JSON schema of the function.`,
} as const;

export const $ToolAnnotations = {
  properties: {
    title: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Title',
    },
    readOnlyHint: {
      anyOf: [
        {
          type: 'boolean',
        },
        {
          type: 'null',
        },
      ],
      title: 'Readonlyhint',
    },
    destructiveHint: {
      anyOf: [
        {
          type: 'boolean',
        },
        {
          type: 'null',
        },
      ],
      title: 'Destructivehint',
    },
    idempotentHint: {
      anyOf: [
        {
          type: 'boolean',
        },
        {
          type: 'null',
        },
      ],
      title: 'Idempotenthint',
    },
    openWorldHint: {
      anyOf: [
        {
          type: 'boolean',
        },
        {
          type: 'null',
        },
      ],
      title: 'Openworldhint',
    },
  },
  additionalProperties: true,
  type: 'object',
  title: 'ToolAnnotations',
  description: `Additional properties describing a Tool to clients.

NOTE: all properties in ToolAnnotations are **hints**.
They are not guaranteed to provide a faithful description of
tool behavior (including descriptive properties like \`title\`).

Clients should never make tool use decisions based on ToolAnnotations
received from untrusted servers.`,
} as const;

export const $ToolCall = {
  properties: {
    name: {
      type: 'string',
      title: 'Name',
    },
    arguments: {
      type: 'string',
      title: 'Arguments',
    },
    tool_call_id: {
      type: 'string',
      title: 'Tool Call Id',
    },
  },
  type: 'object',
  required: ['name', 'arguments', 'tool_call_id'],
  title: 'ToolCall',
} as const;

export const $ToolCallContent = {
  properties: {
    type: {
      type: 'string',
      const: 'tool_call',
      title: 'Type',
      description: 'Indicates this content represents a tool call event.',
      default: 'tool_call',
    },
    id: {
      type: 'string',
      title: 'Id',
      description: 'A unique identifier for this specific tool call instance.',
    },
    name: {
      type: 'string',
      title: 'Name',
      description: 'The name of the tool being called.',
    },
    input: {
      additionalProperties: true,
      type: 'object',
      title: 'Input',
      description:
        'The parameters being passed to the tool, structured as a dictionary of parameter names to values.',
    },
    signature: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Signature',
      description:
        'Stores a unique identifier for any reasoning associated with this tool call.',
    },
  },
  type: 'object',
  required: ['id', 'name', 'input'],
  title: 'ToolCallContent',
} as const;

export const $ToolCallDelta = {
  properties: {
    name: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Name',
    },
    arguments: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Arguments',
    },
    tool_call_id: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Tool Call Id',
    },
  },
  type: 'object',
  title: 'ToolCallDelta',
} as const;

export const $ToolCallMessage = {
  properties: {
    id: {
      type: 'string',
      title: 'Id',
    },
    date: {
      type: 'string',
      format: 'date-time',
      title: 'Date',
    },
    name: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Name',
    },
    message_type: {
      type: 'string',
      const: 'tool_call_message',
      title: 'Message Type',
      description: 'The type of the message.',
      default: 'tool_call_message',
    },
    otid: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Otid',
    },
    sender_id: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Sender Id',
    },
    step_id: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Step Id',
    },
    is_err: {
      anyOf: [
        {
          type: 'boolean',
        },
        {
          type: 'null',
        },
      ],
      title: 'Is Err',
    },
    seq_id: {
      anyOf: [
        {
          type: 'integer',
        },
        {
          type: 'null',
        },
      ],
      title: 'Seq Id',
    },
    run_id: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Run Id',
    },
    tool_call: {
      anyOf: [
        {
          $ref: '#/components/schemas/ToolCall',
        },
        {
          $ref: '#/components/schemas/ToolCallDelta',
        },
      ],
      title: 'Tool Call',
    },
  },
  type: 'object',
  required: ['id', 'date', 'tool_call'],
  title: 'ToolCallMessage',
  description: `A message representing a request to call a tool (generated by the LLM to trigger tool execution).

Args:
    id (str): The ID of the message
    date (datetime): The date the message was created in ISO format
    name (Optional[str]): The name of the sender of the message
    tool_call (Union[ToolCall, ToolCallDelta]): The tool call`,
} as const;

export const $ToolCallNode = {
  properties: {
    name: {
      type: 'string',
      title: 'Name',
      description: 'The name of the child tool to invoke next.',
    },
    args: {
      anyOf: [
        {
          additionalProperties: true,
          type: 'object',
        },
        {
          type: 'null',
        },
      ],
      title: 'Args',
      description:
        "Optional prefilled arguments for this child tool. Keys must match the tool's parameter names and values must satisfy the tool's JSON schema. Supports partial prefill; non-overlapping parameters are left to the model.",
    },
  },
  type: 'object',
  required: ['name'],
  title: 'ToolCallNode',
  description: `Typed child override for prefilled arguments.

When used in a ChildToolRule, if this child is selected next, its \`args\` will be
applied as prefilled arguments (overriding overlapping LLM-provided values).`,
} as const;

export const $ToolCreate = {
  properties: {
    description: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Description',
      description: 'The description of the tool.',
    },
    tags: {
      anyOf: [
        {
          items: {
            type: 'string',
          },
          type: 'array',
        },
        {
          type: 'null',
        },
      ],
      title: 'Tags',
      description: 'Metadata tags.',
    },
    source_code: {
      type: 'string',
      title: 'Source Code',
      description: 'The source code of the function.',
    },
    source_type: {
      type: 'string',
      title: 'Source Type',
      description: 'The source type of the function.',
      default: 'python',
    },
    json_schema: {
      anyOf: [
        {
          additionalProperties: true,
          type: 'object',
        },
        {
          type: 'null',
        },
      ],
      title: 'Json Schema',
      description:
        'The JSON schema of the function (auto-generated from source_code if not provided)',
    },
    args_json_schema: {
      anyOf: [
        {
          additionalProperties: true,
          type: 'object',
        },
        {
          type: 'null',
        },
      ],
      title: 'Args Json Schema',
      description: 'The args JSON schema of the function.',
    },
    return_char_limit: {
      type: 'integer',
      title: 'Return Char Limit',
      description: 'The maximum number of characters in the response.',
      default: 50000,
    },
    pip_requirements: {
      anyOf: [
        {
          items: {
            $ref: '#/components/schemas/PipRequirement',
          },
          type: 'array',
        },
        {
          type: 'null',
        },
      ],
      title: 'Pip Requirements',
      description: 'Optional list of pip packages required by this tool.',
    },
    npm_requirements: {
      anyOf: [
        {
          items: {
            $ref: '#/components/schemas/NpmRequirement',
          },
          type: 'array',
        },
        {
          type: 'null',
        },
      ],
      title: 'Npm Requirements',
      description: 'Optional list of npm packages required by this tool.',
    },
    default_requires_approval: {
      anyOf: [
        {
          type: 'boolean',
        },
        {
          type: 'null',
        },
      ],
      title: 'Default Requires Approval',
      description:
        'Whether or not to require approval before executing this tool.',
    },
  },
  additionalProperties: false,
  type: 'object',
  required: ['source_code'],
  title: 'ToolCreate',
} as const;

export const $ToolEnvVarSchema = {
  properties: {
    created_at: {
      type: 'string',
      title: 'Created At',
    },
    description: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Description',
    },
    key: {
      type: 'string',
      title: 'Key',
    },
    updated_at: {
      type: 'string',
      title: 'Updated At',
    },
    value: {
      type: 'string',
      title: 'Value',
    },
  },
  type: 'object',
  required: ['created_at', 'description', 'key', 'updated_at', 'value'],
  title: 'ToolEnvVarSchema',
} as const;

export const $ToolJSONSchema = {
  properties: {
    name: {
      type: 'string',
      title: 'Name',
    },
    description: {
      type: 'string',
      title: 'Description',
    },
    parameters: {
      $ref: '#/components/schemas/ParametersSchema',
    },
    type: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Type',
    },
    required: {
      anyOf: [
        {
          items: {
            type: 'string',
          },
          type: 'array',
        },
        {
          type: 'null',
        },
      ],
      title: 'Required',
    },
  },
  type: 'object',
  required: ['name', 'description', 'parameters'],
  title: 'ToolJSONSchema',
} as const;

export const $ToolReturn = {
  properties: {
    status: {
      type: 'string',
      enum: ['success', 'error'],
      title: 'Status',
      description: 'The status of the tool call',
    },
    stdout: {
      anyOf: [
        {
          items: {
            type: 'string',
          },
          type: 'array',
        },
        {
          type: 'null',
        },
      ],
      title: 'Stdout',
      description:
        'Captured stdout (e.g. prints, logs) from the tool invocation',
    },
    stderr: {
      anyOf: [
        {
          items: {
            type: 'string',
          },
          type: 'array',
        },
        {
          type: 'null',
        },
      ],
      title: 'Stderr',
      description: 'Captured stderr from the tool invocation',
    },
  },
  type: 'object',
  required: ['status'],
  title: 'ToolReturn',
} as const;

export const $ToolReturnContent = {
  properties: {
    type: {
      type: 'string',
      const: 'tool_return',
      title: 'Type',
      description: 'Indicates this content represents a tool return event.',
      default: 'tool_return',
    },
    tool_call_id: {
      type: 'string',
      title: 'Tool Call Id',
      description:
        'References the ID of the ToolCallContent that initiated this tool call.',
    },
    content: {
      type: 'string',
      title: 'Content',
      description: 'The content returned by the tool execution.',
    },
    is_error: {
      type: 'boolean',
      title: 'Is Error',
      description: 'Indicates whether the tool execution resulted in an error.',
    },
  },
  type: 'object',
  required: ['tool_call_id', 'content', 'is_error'],
  title: 'ToolReturnContent',
} as const;

export const $ToolReturnMessage = {
  properties: {
    id: {
      type: 'string',
      title: 'Id',
    },
    date: {
      type: 'string',
      format: 'date-time',
      title: 'Date',
    },
    name: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Name',
    },
    message_type: {
      type: 'string',
      const: 'tool_return_message',
      title: 'Message Type',
      description: 'The type of the message.',
      default: 'tool_return_message',
    },
    otid: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Otid',
    },
    sender_id: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Sender Id',
    },
    step_id: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Step Id',
    },
    is_err: {
      anyOf: [
        {
          type: 'boolean',
        },
        {
          type: 'null',
        },
      ],
      title: 'Is Err',
    },
    seq_id: {
      anyOf: [
        {
          type: 'integer',
        },
        {
          type: 'null',
        },
      ],
      title: 'Seq Id',
    },
    run_id: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Run Id',
    },
    tool_return: {
      type: 'string',
      title: 'Tool Return',
    },
    status: {
      type: 'string',
      enum: ['success', 'error'],
      title: 'Status',
    },
    tool_call_id: {
      type: 'string',
      title: 'Tool Call Id',
    },
    stdout: {
      anyOf: [
        {
          items: {
            type: 'string',
          },
          type: 'array',
        },
        {
          type: 'null',
        },
      ],
      title: 'Stdout',
    },
    stderr: {
      anyOf: [
        {
          items: {
            type: 'string',
          },
          type: 'array',
        },
        {
          type: 'null',
        },
      ],
      title: 'Stderr',
    },
  },
  type: 'object',
  required: ['id', 'date', 'tool_return', 'status', 'tool_call_id'],
  title: 'ToolReturnMessage',
  description: `A message representing the return value of a tool call (generated by Letta executing the requested tool).

Args:
    id (str): The ID of the message
    date (datetime): The date the message was created in ISO format
    name (Optional[str]): The name of the sender of the message
    tool_return (str): The return value of the tool
    status (Literal["success", "error"]): The status of the tool call
    tool_call_id (str): A unique identifier for the tool call that generated this message
    stdout (Optional[List(str)]): Captured stdout (e.g. prints, logs) from the tool invocation
    stderr (Optional[List(str)]): Captured stderr from the tool invocation`,
} as const;

export const $ToolRunFromSource = {
  properties: {
    source_code: {
      type: 'string',
      title: 'Source Code',
      description: 'The source code of the function.',
    },
    args: {
      additionalProperties: true,
      type: 'object',
      title: 'Args',
      description: 'The arguments to pass to the tool.',
    },
    env_vars: {
      additionalProperties: {
        type: 'string',
      },
      type: 'object',
      title: 'Env Vars',
      description: 'The environment variables to pass to the tool.',
    },
    name: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Name',
      description: 'The name of the tool to run.',
    },
    source_type: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Source Type',
      description: 'The type of the source code.',
    },
    args_json_schema: {
      anyOf: [
        {
          additionalProperties: true,
          type: 'object',
        },
        {
          type: 'null',
        },
      ],
      title: 'Args Json Schema',
      description: 'The args JSON schema of the function.',
    },
    json_schema: {
      anyOf: [
        {
          additionalProperties: true,
          type: 'object',
        },
        {
          type: 'null',
        },
      ],
      title: 'Json Schema',
      description:
        'The JSON schema of the function (auto-generated from source_code if not provided)',
    },
    pip_requirements: {
      anyOf: [
        {
          items: {
            $ref: '#/components/schemas/PipRequirement',
          },
          type: 'array',
        },
        {
          type: 'null',
        },
      ],
      title: 'Pip Requirements',
      description: 'Optional list of pip packages required by this tool.',
    },
    npm_requirements: {
      anyOf: [
        {
          items: {
            $ref: '#/components/schemas/NpmRequirement',
          },
          type: 'array',
        },
        {
          type: 'null',
        },
      ],
      title: 'Npm Requirements',
      description: 'Optional list of npm packages required by this tool.',
    },
  },
  additionalProperties: false,
  type: 'object',
  required: ['source_code', 'args'],
  title: 'ToolRunFromSource',
} as const;

export const $ToolType = {
  type: 'string',
  enum: [
    'custom',
    'letta_core',
    'letta_memory_core',
    'letta_multi_agent_core',
    'letta_sleeptime_core',
    'letta_voice_sleeptime_core',
    'letta_builtin',
    'letta_files_core',
    'external_langchain',
    'external_composio',
    'external_mcp',
  ],
  title: 'ToolType',
} as const;

export const $ToolUpdate = {
  properties: {
    description: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Description',
      description: 'The description of the tool.',
    },
    tags: {
      anyOf: [
        {
          items: {
            type: 'string',
          },
          type: 'array',
        },
        {
          type: 'null',
        },
      ],
      title: 'Tags',
      description: 'Metadata tags.',
    },
    source_code: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Source Code',
      description: 'The source code of the function.',
    },
    source_type: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Source Type',
      description: 'The type of the source code.',
    },
    json_schema: {
      anyOf: [
        {
          additionalProperties: true,
          type: 'object',
        },
        {
          type: 'null',
        },
      ],
      title: 'Json Schema',
      description:
        'The JSON schema of the function (auto-generated from source_code if not provided)',
    },
    args_json_schema: {
      anyOf: [
        {
          additionalProperties: true,
          type: 'object',
        },
        {
          type: 'null',
        },
      ],
      title: 'Args Json Schema',
      description: 'The args JSON schema of the function.',
    },
    return_char_limit: {
      anyOf: [
        {
          type: 'integer',
        },
        {
          type: 'null',
        },
      ],
      title: 'Return Char Limit',
      description: 'The maximum number of characters in the response.',
    },
    pip_requirements: {
      anyOf: [
        {
          items: {
            $ref: '#/components/schemas/PipRequirement',
          },
          type: 'array',
        },
        {
          type: 'null',
        },
      ],
      title: 'Pip Requirements',
      description: 'Optional list of pip packages required by this tool.',
    },
    npm_requirements: {
      anyOf: [
        {
          items: {
            $ref: '#/components/schemas/NpmRequirement',
          },
          type: 'array',
        },
        {
          type: 'null',
        },
      ],
      title: 'Npm Requirements',
      description: 'Optional list of npm packages required by this tool.',
    },
    metadata_: {
      anyOf: [
        {
          additionalProperties: true,
          type: 'object',
        },
        {
          type: 'null',
        },
      ],
      title: 'Metadata',
      description: 'A dictionary of additional metadata for the tool.',
    },
    default_requires_approval: {
      anyOf: [
        {
          type: 'boolean',
        },
        {
          type: 'null',
        },
      ],
      title: 'Default Requires Approval',
      description:
        'Whether or not to require approval before executing this tool.',
    },
  },
  type: 'object',
  title: 'ToolUpdate',
} as const;

export const $UpdateAgent = {
  properties: {
    name: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Name',
      description: 'The name of the agent.',
    },
    tool_ids: {
      anyOf: [
        {
          items: {
            type: 'string',
          },
          type: 'array',
        },
        {
          type: 'null',
        },
      ],
      title: 'Tool Ids',
      description: 'The ids of the tools used by the agent.',
    },
    source_ids: {
      anyOf: [
        {
          items: {
            type: 'string',
          },
          type: 'array',
        },
        {
          type: 'null',
        },
      ],
      title: 'Source Ids',
      description: 'The ids of the sources used by the agent.',
    },
    block_ids: {
      anyOf: [
        {
          items: {
            type: 'string',
          },
          type: 'array',
        },
        {
          type: 'null',
        },
      ],
      title: 'Block Ids',
      description: 'The ids of the blocks used by the agent.',
    },
    tags: {
      anyOf: [
        {
          items: {
            type: 'string',
          },
          type: 'array',
        },
        {
          type: 'null',
        },
      ],
      title: 'Tags',
      description: 'The tags associated with the agent.',
    },
    system: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'System',
      description: 'The system prompt used by the agent.',
    },
    tool_rules: {
      anyOf: [
        {
          items: {
            oneOf: [
              {
                $ref: '#/components/schemas/ChildToolRule',
              },
              {
                $ref: '#/components/schemas/InitToolRule',
              },
              {
                $ref: '#/components/schemas/TerminalToolRule',
              },
              {
                $ref: '#/components/schemas/ConditionalToolRule',
              },
              {
                $ref: '#/components/schemas/ContinueToolRule',
              },
              {
                $ref: '#/components/schemas/RequiredBeforeExitToolRule',
              },
              {
                $ref: '#/components/schemas/MaxCountPerStepToolRule',
              },
              {
                $ref: '#/components/schemas/ParentToolRule',
              },
              {
                $ref: '#/components/schemas/RequiresApprovalToolRule',
              },
            ],
            discriminator: {
              propertyName: 'type',
              mapping: {
                conditional: '#/components/schemas/ConditionalToolRule',
                constrain_child_tools: '#/components/schemas/ChildToolRule',
                continue_loop: '#/components/schemas/ContinueToolRule',
                exit_loop: '#/components/schemas/TerminalToolRule',
                max_count_per_step:
                  '#/components/schemas/MaxCountPerStepToolRule',
                parent_last_tool: '#/components/schemas/ParentToolRule',
                required_before_exit:
                  '#/components/schemas/RequiredBeforeExitToolRule',
                requires_approval:
                  '#/components/schemas/RequiresApprovalToolRule',
                run_first: '#/components/schemas/InitToolRule',
              },
            },
          },
          type: 'array',
        },
        {
          type: 'null',
        },
      ],
      title: 'Tool Rules',
      description: 'The tool rules governing the agent.',
    },
    llm_config: {
      anyOf: [
        {
          $ref: '#/components/schemas/LLMConfig',
        },
        {
          type: 'null',
        },
      ],
      description: 'The LLM configuration used by the agent.',
    },
    embedding_config: {
      anyOf: [
        {
          $ref: '#/components/schemas/EmbeddingConfig',
        },
        {
          type: 'null',
        },
      ],
      description: 'The embedding configuration used by the agent.',
    },
    message_ids: {
      anyOf: [
        {
          items: {
            type: 'string',
          },
          type: 'array',
        },
        {
          type: 'null',
        },
      ],
      title: 'Message Ids',
      description: "The ids of the messages in the agent's in-context memory.",
    },
    description: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Description',
      description: 'The description of the agent.',
    },
    metadata: {
      anyOf: [
        {
          additionalProperties: true,
          type: 'object',
        },
        {
          type: 'null',
        },
      ],
      title: 'Metadata',
      description: 'The metadata of the agent.',
    },
    tool_exec_environment_variables: {
      anyOf: [
        {
          additionalProperties: {
            type: 'string',
          },
          type: 'object',
        },
        {
          type: 'null',
        },
      ],
      title: 'Tool Exec Environment Variables',
      description: 'Deprecated: use `secrets` field instead',
    },
    secrets: {
      anyOf: [
        {
          additionalProperties: {
            type: 'string',
          },
          type: 'object',
        },
        {
          type: 'null',
        },
      ],
      title: 'Secrets',
      description:
        'The environment variables for tool execution specific to this agent.',
    },
    project_id: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Project Id',
      description: 'The id of the project the agent belongs to.',
    },
    template_id: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Template Id',
      description: 'The id of the template the agent belongs to.',
    },
    base_template_id: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Base Template Id',
      description: 'The base template id of the agent.',
    },
    identity_ids: {
      anyOf: [
        {
          items: {
            type: 'string',
          },
          type: 'array',
        },
        {
          type: 'null',
        },
      ],
      title: 'Identity Ids',
      description: 'The ids of the identities associated with this agent.',
    },
    message_buffer_autoclear: {
      anyOf: [
        {
          type: 'boolean',
        },
        {
          type: 'null',
        },
      ],
      title: 'Message Buffer Autoclear',
      description:
        'If set to True, the agent will not remember previous messages (though the agent will still retain state via core memory blocks and archival/recall memory). Not recommended unless you have an advanced use case.',
    },
    model: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Model',
      description:
        'The LLM configuration handle used by the agent, specified in the format provider/model-name, as an alternative to specifying llm_config.',
    },
    embedding: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Embedding',
      description:
        'The embedding configuration handle used by the agent, specified in the format provider/model-name.',
    },
    reasoning: {
      anyOf: [
        {
          type: 'boolean',
        },
        {
          type: 'null',
        },
      ],
      title: 'Reasoning',
      description: 'Whether to enable reasoning for this agent.',
    },
    enable_sleeptime: {
      anyOf: [
        {
          type: 'boolean',
        },
        {
          type: 'null',
        },
      ],
      title: 'Enable Sleeptime',
      description:
        'If set to True, memory management will move to a background agent thread.',
    },
    response_format: {
      anyOf: [
        {
          oneOf: [
            {
              $ref: '#/components/schemas/TextResponseFormat',
            },
            {
              $ref: '#/components/schemas/JsonSchemaResponseFormat',
            },
            {
              $ref: '#/components/schemas/JsonObjectResponseFormat',
            },
          ],
          discriminator: {
            propertyName: 'type',
            mapping: {
              json_object: '#/components/schemas/JsonObjectResponseFormat',
              json_schema: '#/components/schemas/JsonSchemaResponseFormat',
              text: '#/components/schemas/TextResponseFormat',
            },
          },
        },
        {
          type: 'null',
        },
      ],
      title: 'Response Format',
      description: 'The response format for the agent.',
    },
    last_run_completion: {
      anyOf: [
        {
          type: 'string',
          format: 'date-time',
        },
        {
          type: 'null',
        },
      ],
      title: 'Last Run Completion',
      description: 'The timestamp when the agent last completed a run.',
    },
    last_run_duration_ms: {
      anyOf: [
        {
          type: 'integer',
        },
        {
          type: 'null',
        },
      ],
      title: 'Last Run Duration Ms',
      description: "The duration in milliseconds of the agent's last run.",
    },
    timezone: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Timezone',
      description: 'The timezone of the agent (IANA format).',
    },
    max_files_open: {
      anyOf: [
        {
          type: 'integer',
        },
        {
          type: 'null',
        },
      ],
      title: 'Max Files Open',
      description:
        'Maximum number of files that can be open at once for this agent. Setting this too high may exceed the context window, which will break the agent.',
    },
    per_file_view_window_char_limit: {
      anyOf: [
        {
          type: 'integer',
        },
        {
          type: 'null',
        },
      ],
      title: 'Per File View Window Char Limit',
      description:
        'The per-file view window character limit for this agent. Setting this too high may exceed the context window, which will break the agent.',
    },
    hidden: {
      anyOf: [
        {
          type: 'boolean',
        },
        {
          type: 'null',
        },
      ],
      title: 'Hidden',
      description: 'If set to True, the agent will be hidden.',
    },
  },
  type: 'object',
  title: 'UpdateAgent',
} as const;

export const $UpdateAssistantMessage = {
  properties: {
    message_type: {
      type: 'string',
      const: 'assistant_message',
      title: 'Message Type',
      default: 'assistant_message',
    },
    content: {
      anyOf: [
        {
          items: {
            $ref: '#/components/schemas/LettaAssistantMessageContentUnion',
          },
          type: 'array',
        },
        {
          type: 'string',
        },
      ],
      title: 'Content',
      description:
        'The message content sent by the assistant (can be a string or an array of content parts)',
    },
  },
  type: 'object',
  required: ['content'],
  title: 'UpdateAssistantMessage',
} as const;

export const $UpdateReasoningMessage = {
  properties: {
    reasoning: {
      type: 'string',
      title: 'Reasoning',
    },
    message_type: {
      type: 'string',
      const: 'reasoning_message',
      title: 'Message Type',
      default: 'reasoning_message',
    },
  },
  type: 'object',
  required: ['reasoning'],
  title: 'UpdateReasoningMessage',
} as const;

export const $UpdateSSEMCPServer = {
  properties: {
    server_url: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Server Url',
      description:
        'The URL of the server (MCP SSE client will connect to this URL)',
    },
    token: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Token',
      description:
        'The access token or API key for the MCP server (used for SSE authentication)',
    },
    custom_headers: {
      anyOf: [
        {
          additionalProperties: {
            type: 'string',
          },
          type: 'object',
        },
        {
          type: 'null',
        },
      ],
      title: 'Custom Headers',
      description: 'Custom authentication headers as key-value pairs',
    },
  },
  additionalProperties: false,
  type: 'object',
  title: 'UpdateSSEMCPServer',
  description: 'Update an SSE MCP server',
} as const;

export const $UpdateStdioMCPServer = {
  properties: {
    stdio_config: {
      anyOf: [
        {
          $ref: '#/components/schemas/StdioServerConfig',
        },
        {
          type: 'null',
        },
      ],
      description:
        "The configuration for the server (MCP 'local' client will run this command)",
    },
  },
  additionalProperties: false,
  type: 'object',
  title: 'UpdateStdioMCPServer',
  description: 'Update a Stdio MCP server',
} as const;

export const $UpdateStreamableHTTPMCPServer = {
  properties: {
    server_url: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Server Url',
      description:
        "The URL path for the streamable HTTP server (e.g., 'example/mcp')",
    },
    auth_header: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Auth Header',
      description:
        "The name of the authentication header (e.g., 'Authorization')",
    },
    auth_token: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Auth Token',
      description: 'The authentication token or API key value',
    },
    custom_headers: {
      anyOf: [
        {
          additionalProperties: {
            type: 'string',
          },
          type: 'object',
        },
        {
          type: 'null',
        },
      ],
      title: 'Custom Headers',
      description: 'Custom authentication headers as key-value pairs',
    },
  },
  additionalProperties: false,
  type: 'object',
  title: 'UpdateStreamableHTTPMCPServer',
  description: 'Update a Streamable HTTP MCP server',
} as const;

export const $UpdateSystemMessage = {
  properties: {
    message_type: {
      type: 'string',
      const: 'system_message',
      title: 'Message Type',
      default: 'system_message',
    },
    content: {
      type: 'string',
      title: 'Content',
      description:
        'The message content sent by the system (can be a string or an array of multi-modal content parts)',
    },
  },
  type: 'object',
  required: ['content'],
  title: 'UpdateSystemMessage',
} as const;

export const $UpdateUserMessage = {
  properties: {
    message_type: {
      type: 'string',
      const: 'user_message',
      title: 'Message Type',
      default: 'user_message',
    },
    content: {
      anyOf: [
        {
          items: {
            $ref: '#/components/schemas/LettaUserMessageContentUnion',
          },
          type: 'array',
        },
        {
          type: 'string',
        },
      ],
      title: 'Content',
      description:
        'The message content sent by the user (can be a string or an array of multi-modal content parts)',
    },
  },
  type: 'object',
  required: ['content'],
  title: 'UpdateUserMessage',
} as const;

export const $UrlImage = {
  properties: {
    type: {
      type: 'string',
      const: 'url',
      title: 'Type',
      description: 'The source type for the image.',
      default: 'url',
    },
    url: {
      type: 'string',
      title: 'Url',
      description: 'The URL of the image.',
    },
  },
  type: 'object',
  required: ['url'],
  title: 'UrlImage',
} as const;

export const $UsageStatistics = {
  properties: {
    completion_tokens: {
      type: 'integer',
      title: 'Completion Tokens',
      default: 0,
    },
    prompt_tokens: {
      type: 'integer',
      title: 'Prompt Tokens',
      default: 0,
    },
    total_tokens: {
      type: 'integer',
      title: 'Total Tokens',
      default: 0,
    },
    prompt_tokens_details: {
      anyOf: [
        {
          $ref: '#/components/schemas/UsageStatisticsPromptTokenDetails',
        },
        {
          type: 'null',
        },
      ],
    },
    completion_tokens_details: {
      anyOf: [
        {
          $ref: '#/components/schemas/UsageStatisticsCompletionTokenDetails',
        },
        {
          type: 'null',
        },
      ],
    },
  },
  type: 'object',
  title: 'UsageStatistics',
} as const;

export const $UsageStatisticsCompletionTokenDetails = {
  properties: {
    reasoning_tokens: {
      type: 'integer',
      title: 'Reasoning Tokens',
      default: 0,
    },
  },
  type: 'object',
  title: 'UsageStatisticsCompletionTokenDetails',
} as const;

export const $UsageStatisticsPromptTokenDetails = {
  properties: {
    cached_tokens: {
      type: 'integer',
      title: 'Cached Tokens',
      default: 0,
    },
  },
  type: 'object',
  title: 'UsageStatisticsPromptTokenDetails',
} as const;

export const $User = {
  properties: {
    id: {
      type: 'string',
      pattern: '^user-[a-fA-F0-9]{8}',
      title: 'Id',
      description: 'The human-friendly ID of the User',
      examples: ['user-123e4567-e89b-12d3-a456-426614174000'],
    },
    organization_id: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Organization Id',
      description: 'The organization id of the user',
      default: 'org-00000000-0000-4000-8000-000000000000',
    },
    name: {
      type: 'string',
      title: 'Name',
      description: 'The name of the user.',
    },
    created_at: {
      anyOf: [
        {
          type: 'string',
          format: 'date-time',
        },
        {
          type: 'null',
        },
      ],
      title: 'Created At',
      description: 'The creation date of the user.',
    },
    updated_at: {
      anyOf: [
        {
          type: 'string',
          format: 'date-time',
        },
        {
          type: 'null',
        },
      ],
      title: 'Updated At',
      description: 'The update date of the user.',
    },
    is_deleted: {
      type: 'boolean',
      title: 'Is Deleted',
      description: 'Whether this user is deleted or not.',
      default: false,
    },
  },
  additionalProperties: false,
  type: 'object',
  required: ['name'],
  title: 'User',
  description: `Representation of a user.

Parameters:
    id (str): The unique identifier of the user.
    name (str): The name of the user.
    created_at (datetime): The creation date of the user.`,
} as const;

export const $UserCreate = {
  properties: {
    name: {
      type: 'string',
      title: 'Name',
      description: 'The name of the user.',
    },
    organization_id: {
      type: 'string',
      title: 'Organization Id',
      description: 'The organization id of the user.',
    },
  },
  additionalProperties: false,
  type: 'object',
  required: ['name', 'organization_id'],
  title: 'UserCreate',
} as const;

export const $UserMessage = {
  properties: {
    id: {
      type: 'string',
      title: 'Id',
    },
    date: {
      type: 'string',
      format: 'date-time',
      title: 'Date',
    },
    name: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Name',
    },
    message_type: {
      type: 'string',
      const: 'user_message',
      title: 'Message Type',
      description: 'The type of the message.',
      default: 'user_message',
    },
    otid: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Otid',
    },
    sender_id: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Sender Id',
    },
    step_id: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Step Id',
    },
    is_err: {
      anyOf: [
        {
          type: 'boolean',
        },
        {
          type: 'null',
        },
      ],
      title: 'Is Err',
    },
    seq_id: {
      anyOf: [
        {
          type: 'integer',
        },
        {
          type: 'null',
        },
      ],
      title: 'Seq Id',
    },
    run_id: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Run Id',
    },
    content: {
      anyOf: [
        {
          items: {
            $ref: '#/components/schemas/LettaUserMessageContentUnion',
          },
          type: 'array',
        },
        {
          type: 'string',
        },
      ],
      title: 'Content',
      description:
        'The message content sent by the user (can be a string or an array of multi-modal content parts)',
    },
  },
  type: 'object',
  required: ['id', 'date', 'content'],
  title: 'UserMessage',
  description: `A message sent by the user. Never streamed back on a response, only used for cursor pagination.

Args:
    id (str): The ID of the message
    date (datetime): The date the message was created in ISO format
    name (Optional[str]): The name of the sender of the message
    content (Union[str, List[LettaUserMessageContentUnion]]): The message content sent by the user (can be a string or an array of multi-modal content parts)`,
} as const;

export const $UserUpdate = {
  properties: {
    id: {
      type: 'string',
      title: 'Id',
      description: 'The id of the user to update.',
    },
    name: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Name',
      description: 'The new name of the user.',
    },
    organization_id: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Organization Id',
      description: 'The new organization id of the user.',
    },
  },
  additionalProperties: false,
  type: 'object',
  required: ['id'],
  title: 'UserUpdate',
} as const;

export const $ValidationError = {
  properties: {
    loc: {
      items: {
        anyOf: [
          {
            type: 'string',
          },
          {
            type: 'integer',
          },
        ],
      },
      type: 'array',
      title: 'Location',
    },
    msg: {
      type: 'string',
      title: 'Message',
    },
    type: {
      type: 'string',
      title: 'Error Type',
    },
  },
  type: 'object',
  required: ['loc', 'msg', 'type'],
  title: 'ValidationError',
} as const;

export const $VectorDBProvider = {
  type: 'string',
  enum: ['native', 'tpuf', 'pinecone'],
  title: 'VectorDBProvider',
  description: 'Supported vector database providers for archival memory',
} as const;

export const $VoiceSleeptimeManager = {
  properties: {
    manager_type: {
      type: 'string',
      const: 'voice_sleeptime',
      title: 'Manager Type',
      description: '',
      default: 'voice_sleeptime',
    },
    manager_agent_id: {
      type: 'string',
      title: 'Manager Agent Id',
      description: '',
    },
    max_message_buffer_length: {
      anyOf: [
        {
          type: 'integer',
        },
        {
          type: 'null',
        },
      ],
      title: 'Max Message Buffer Length',
      description:
        'The desired maximum length of messages in the context window of the convo agent. This is a best effort, and may be off slightly due to user/assistant interleaving.',
    },
    min_message_buffer_length: {
      anyOf: [
        {
          type: 'integer',
        },
        {
          type: 'null',
        },
      ],
      title: 'Min Message Buffer Length',
      description:
        'The desired minimum length of messages in the context window of the convo agent. This is a best effort, and may be off-by-one due to user/assistant interleaving.',
    },
  },
  type: 'object',
  required: ['manager_agent_id'],
  title: 'VoiceSleeptimeManager',
} as const;

export const $VoiceSleeptimeManagerUpdate = {
  properties: {
    manager_type: {
      type: 'string',
      const: 'voice_sleeptime',
      title: 'Manager Type',
      description: '',
      default: 'voice_sleeptime',
    },
    manager_agent_id: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Manager Agent Id',
      description: '',
    },
    max_message_buffer_length: {
      anyOf: [
        {
          type: 'integer',
        },
        {
          type: 'null',
        },
      ],
      title: 'Max Message Buffer Length',
      description:
        'The desired maximum length of messages in the context window of the convo agent. This is a best effort, and may be off slightly due to user/assistant interleaving.',
    },
    min_message_buffer_length: {
      anyOf: [
        {
          type: 'integer',
        },
        {
          type: 'null',
        },
      ],
      title: 'Min Message Buffer Length',
      description:
        'The desired minimum length of messages in the context window of the convo agent. This is a best effort, and may be off-by-one due to user/assistant interleaving.',
    },
  },
  type: 'object',
  title: 'VoiceSleeptimeManagerUpdate',
} as const;

export const $letta__schemas__agent_file__AgentSchema = {
  properties: {
    name: {
      type: 'string',
      title: 'Name',
      description: 'The name of the agent.',
    },
    memory_blocks: {
      anyOf: [
        {
          items: {
            $ref: '#/components/schemas/CreateBlock',
          },
          type: 'array',
        },
        {
          type: 'null',
        },
      ],
      title: 'Memory Blocks',
      description: "The blocks to create in the agent's in-context memory.",
    },
    tools: {
      anyOf: [
        {
          items: {
            type: 'string',
          },
          type: 'array',
        },
        {
          type: 'null',
        },
      ],
      title: 'Tools',
      description: 'The tools used by the agent.',
    },
    tool_ids: {
      anyOf: [
        {
          items: {
            type: 'string',
          },
          type: 'array',
        },
        {
          type: 'null',
        },
      ],
      title: 'Tool Ids',
      description: 'The ids of the tools used by the agent.',
    },
    source_ids: {
      anyOf: [
        {
          items: {
            type: 'string',
          },
          type: 'array',
        },
        {
          type: 'null',
        },
      ],
      title: 'Source Ids',
      description: 'The ids of the sources used by the agent.',
    },
    block_ids: {
      anyOf: [
        {
          items: {
            type: 'string',
          },
          type: 'array',
        },
        {
          type: 'null',
        },
      ],
      title: 'Block Ids',
      description: 'The ids of the blocks used by the agent.',
    },
    tool_rules: {
      anyOf: [
        {
          items: {
            oneOf: [
              {
                $ref: '#/components/schemas/ChildToolRule',
              },
              {
                $ref: '#/components/schemas/InitToolRule',
              },
              {
                $ref: '#/components/schemas/TerminalToolRule',
              },
              {
                $ref: '#/components/schemas/ConditionalToolRule',
              },
              {
                $ref: '#/components/schemas/ContinueToolRule',
              },
              {
                $ref: '#/components/schemas/RequiredBeforeExitToolRule',
              },
              {
                $ref: '#/components/schemas/MaxCountPerStepToolRule',
              },
              {
                $ref: '#/components/schemas/ParentToolRule',
              },
              {
                $ref: '#/components/schemas/RequiresApprovalToolRule',
              },
            ],
            discriminator: {
              propertyName: 'type',
              mapping: {
                conditional: '#/components/schemas/ConditionalToolRule',
                constrain_child_tools: '#/components/schemas/ChildToolRule',
                continue_loop: '#/components/schemas/ContinueToolRule',
                exit_loop: '#/components/schemas/TerminalToolRule',
                max_count_per_step:
                  '#/components/schemas/MaxCountPerStepToolRule',
                parent_last_tool: '#/components/schemas/ParentToolRule',
                required_before_exit:
                  '#/components/schemas/RequiredBeforeExitToolRule',
                requires_approval:
                  '#/components/schemas/RequiresApprovalToolRule',
                run_first: '#/components/schemas/InitToolRule',
              },
            },
          },
          type: 'array',
        },
        {
          type: 'null',
        },
      ],
      title: 'Tool Rules',
      description: 'The tool rules governing the agent.',
    },
    tags: {
      anyOf: [
        {
          items: {
            type: 'string',
          },
          type: 'array',
        },
        {
          type: 'null',
        },
      ],
      title: 'Tags',
      description: 'The tags associated with the agent.',
    },
    system: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'System',
      description: 'The system prompt used by the agent.',
    },
    agent_type: {
      $ref: '#/components/schemas/AgentType',
      description: 'The type of agent.',
    },
    llm_config: {
      anyOf: [
        {
          $ref: '#/components/schemas/LLMConfig',
        },
        {
          type: 'null',
        },
      ],
      description: 'The LLM configuration used by the agent.',
    },
    embedding_config: {
      anyOf: [
        {
          $ref: '#/components/schemas/EmbeddingConfig',
        },
        {
          type: 'null',
        },
      ],
      description: 'The embedding configuration used by the agent.',
    },
    initial_message_sequence: {
      anyOf: [
        {
          items: {
            $ref: '#/components/schemas/MessageCreate',
          },
          type: 'array',
        },
        {
          type: 'null',
        },
      ],
      title: 'Initial Message Sequence',
      description:
        "The initial set of messages to put in the agent's in-context memory.",
    },
    include_base_tools: {
      type: 'boolean',
      title: 'Include Base Tools',
      description:
        'If true, attaches the Letta core tools (e.g. core_memory related functions).',
      default: true,
    },
    include_multi_agent_tools: {
      type: 'boolean',
      title: 'Include Multi Agent Tools',
      description:
        'If true, attaches the Letta multi-agent tools (e.g. sending a message to another agent).',
      default: false,
    },
    include_base_tool_rules: {
      anyOf: [
        {
          type: 'boolean',
        },
        {
          type: 'null',
        },
      ],
      title: 'Include Base Tool Rules',
      description:
        'If true, attaches the Letta base tool rules (e.g. deny all tools not explicitly allowed).',
    },
    include_default_source: {
      type: 'boolean',
      title: 'Include Default Source',
      description:
        'If true, automatically creates and attaches a default data source for this agent.',
      default: false,
    },
    description: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Description',
      description: 'The description of the agent.',
    },
    metadata: {
      anyOf: [
        {
          additionalProperties: true,
          type: 'object',
        },
        {
          type: 'null',
        },
      ],
      title: 'Metadata',
      description: 'The metadata of the agent.',
    },
    model: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Model',
      description:
        'The LLM configuration handle used by the agent, specified in the format provider/model-name, as an alternative to specifying llm_config.',
    },
    embedding: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Embedding',
      description:
        'The embedding configuration handle used by the agent, specified in the format provider/model-name.',
    },
    context_window_limit: {
      anyOf: [
        {
          type: 'integer',
        },
        {
          type: 'null',
        },
      ],
      title: 'Context Window Limit',
      description: 'The context window limit used by the agent.',
    },
    embedding_chunk_size: {
      anyOf: [
        {
          type: 'integer',
        },
        {
          type: 'null',
        },
      ],
      title: 'Embedding Chunk Size',
      description: 'The embedding chunk size used by the agent.',
      default: 300,
    },
    max_tokens: {
      anyOf: [
        {
          type: 'integer',
        },
        {
          type: 'null',
        },
      ],
      title: 'Max Tokens',
      description:
        'The maximum number of tokens to generate, including reasoning step. If not set, the model will use its default value.',
    },
    max_reasoning_tokens: {
      anyOf: [
        {
          type: 'integer',
        },
        {
          type: 'null',
        },
      ],
      title: 'Max Reasoning Tokens',
      description:
        'The maximum number of tokens to generate for reasoning step. If not set, the model will use its default value.',
    },
    enable_reasoner: {
      anyOf: [
        {
          type: 'boolean',
        },
        {
          type: 'null',
        },
      ],
      title: 'Enable Reasoner',
      description:
        'Whether to enable internal extended thinking step for a reasoner model.',
      default: true,
    },
    reasoning: {
      anyOf: [
        {
          type: 'boolean',
        },
        {
          type: 'null',
        },
      ],
      title: 'Reasoning',
      description: 'Whether to enable reasoning for this agent.',
    },
    from_template: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'From Template',
      description:
        "Deprecated: please use the 'create agents from a template' endpoint instead.",
    },
    template: {
      type: 'boolean',
      title: 'Template',
      description: 'Deprecated: No longer used',
      default: false,
    },
    project: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Project',
      description:
        'Deprecated: Project should now be passed via the X-Project header instead of in the request body. If using the sdk, this can be done via the new x_project field below.',
      deprecated: true,
    },
    tool_exec_environment_variables: {
      anyOf: [
        {
          additionalProperties: {
            type: 'string',
          },
          type: 'object',
        },
        {
          type: 'null',
        },
      ],
      title: 'Tool Exec Environment Variables',
      description: 'Deprecated: use `secrets` field instead.',
    },
    secrets: {
      anyOf: [
        {
          additionalProperties: {
            type: 'string',
          },
          type: 'object',
        },
        {
          type: 'null',
        },
      ],
      title: 'Secrets',
      description:
        'The environment variables for tool execution specific to this agent.',
    },
    memory_variables: {
      anyOf: [
        {
          additionalProperties: {
            type: 'string',
          },
          type: 'object',
        },
        {
          type: 'null',
        },
      ],
      title: 'Memory Variables',
      description: 'The variables that should be set for the agent.',
    },
    project_id: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Project Id',
      description: 'The id of the project the agent belongs to.',
    },
    template_id: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Template Id',
      description: 'The id of the template the agent belongs to.',
    },
    base_template_id: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Base Template Id',
      description: 'The base template id of the agent.',
    },
    identity_ids: {
      anyOf: [
        {
          items: {
            type: 'string',
          },
          type: 'array',
        },
        {
          type: 'null',
        },
      ],
      title: 'Identity Ids',
      description: 'The ids of the identities associated with this agent.',
    },
    message_buffer_autoclear: {
      type: 'boolean',
      title: 'Message Buffer Autoclear',
      description:
        'If set to True, the agent will not remember previous messages (though the agent will still retain state via core memory blocks and archival/recall memory). Not recommended unless you have an advanced use case.',
      default: false,
    },
    enable_sleeptime: {
      anyOf: [
        {
          type: 'boolean',
        },
        {
          type: 'null',
        },
      ],
      title: 'Enable Sleeptime',
      description:
        'If set to True, memory management will move to a background agent thread.',
    },
    response_format: {
      anyOf: [
        {
          oneOf: [
            {
              $ref: '#/components/schemas/TextResponseFormat',
            },
            {
              $ref: '#/components/schemas/JsonSchemaResponseFormat',
            },
            {
              $ref: '#/components/schemas/JsonObjectResponseFormat',
            },
          ],
          discriminator: {
            propertyName: 'type',
            mapping: {
              json_object: '#/components/schemas/JsonObjectResponseFormat',
              json_schema: '#/components/schemas/JsonSchemaResponseFormat',
              text: '#/components/schemas/TextResponseFormat',
            },
          },
        },
        {
          type: 'null',
        },
      ],
      title: 'Response Format',
      description: 'The response format for the agent.',
    },
    timezone: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Timezone',
      description: 'The timezone of the agent (IANA format).',
    },
    max_files_open: {
      anyOf: [
        {
          type: 'integer',
        },
        {
          type: 'null',
        },
      ],
      title: 'Max Files Open',
      description:
        'Maximum number of files that can be open at once for this agent. Setting this too high may exceed the context window, which will break the agent.',
    },
    per_file_view_window_char_limit: {
      anyOf: [
        {
          type: 'integer',
        },
        {
          type: 'null',
        },
      ],
      title: 'Per File View Window Char Limit',
      description:
        'The per-file view window character limit for this agent. Setting this too high may exceed the context window, which will break the agent.',
    },
    hidden: {
      anyOf: [
        {
          type: 'boolean',
        },
        {
          type: 'null',
        },
      ],
      title: 'Hidden',
      description: 'If set to True, the agent will be hidden.',
    },
    id: {
      type: 'string',
      title: 'Id',
      description: 'Human-readable identifier for this agent in the file',
    },
    in_context_message_ids: {
      items: {
        type: 'string',
      },
      type: 'array',
      title: 'In Context Message Ids',
      description:
        "List of message IDs that are currently in the agent's context",
    },
    messages: {
      items: {
        $ref: '#/components/schemas/letta__schemas__agent_file__MessageSchema',
      },
      type: 'array',
      title: 'Messages',
      description: "List of messages in the agent's conversation history",
    },
    files_agents: {
      items: {
        $ref: '#/components/schemas/FileAgentSchema',
      },
      type: 'array',
      title: 'Files Agents',
      description: 'List of file-agent relationships for this agent',
    },
    group_ids: {
      items: {
        type: 'string',
      },
      type: 'array',
      title: 'Group Ids',
      description: 'List of groups that the agent manages',
    },
  },
  type: 'object',
  required: ['id'],
  title: 'AgentSchema',
  description: 'Agent with human-readable ID for agent file',
} as const;

export const $letta__schemas__agent_file__MessageSchema = {
  properties: {
    type: {
      anyOf: [
        {
          type: 'string',
          const: 'message',
        },
        {
          type: 'null',
        },
      ],
      title: 'Type',
      description: 'The message type to be created.',
      default: 'message',
    },
    role: {
      $ref: '#/components/schemas/MessageRole',
      description: 'The role of the participant.',
    },
    content: {
      anyOf: [
        {
          items: {
            $ref: '#/components/schemas/LettaMessageContentUnion',
          },
          type: 'array',
        },
        {
          type: 'string',
        },
      ],
      title: 'Content',
      description: 'The content of the message.',
    },
    name: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Name',
      description: 'The name of the participant.',
    },
    otid: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Otid',
      description: 'The offline threading id associated with this message',
    },
    sender_id: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Sender Id',
      description:
        'The id of the sender of the message, can be an identity id or agent id',
    },
    batch_item_id: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Batch Item Id',
      description:
        'The id of the LLMBatchItem that this message is associated with',
    },
    group_id: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Group Id',
      description: 'The multi-agent group that the message was sent in',
    },
    id: {
      type: 'string',
      title: 'Id',
      description: 'Human-readable identifier for this message in the file',
    },
    model: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Model',
      description: 'The model used to make the function call',
    },
    agent_id: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Agent Id',
      description: 'The unique identifier of the agent',
    },
    tool_calls: {
      anyOf: [
        {
          items: {
            $ref: '#/components/schemas/ChatCompletionMessageFunctionToolCall',
          },
          type: 'array',
        },
        {
          type: 'null',
        },
      ],
      title: 'Tool Calls',
      description:
        'The list of tool calls requested. Only applicable for role assistant.',
    },
    tool_call_id: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Tool Call Id',
      description: 'The ID of the tool call. Only applicable for role tool.',
    },
    tool_returns: {
      anyOf: [
        {
          items: {
            $ref: '#/components/schemas/ToolReturn',
          },
          type: 'array',
        },
        {
          type: 'null',
        },
      ],
      title: 'Tool Returns',
      description: 'Tool execution return information for prior tool calls',
    },
    created_at: {
      type: 'string',
      format: 'date-time',
      title: 'Created At',
      description: 'The timestamp when the object was created.',
    },
  },
  type: 'object',
  required: ['role', 'content', 'id'],
  title: 'MessageSchema',
  description: 'Message with human-readable ID for agent file',
} as const;

export const $letta__schemas__agent_file__ToolSchema = {
  properties: {
    id: {
      type: 'string',
      title: 'Id',
      description: 'Human-readable identifier for this tool in the file',
    },
    tool_type: {
      $ref: '#/components/schemas/ToolType',
      description: 'The type of the tool.',
      default: 'custom',
    },
    description: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Description',
      description: 'The description of the tool.',
    },
    source_type: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Source Type',
      description: 'The type of the source code.',
    },
    name: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Name',
      description: 'The name of the function.',
    },
    tags: {
      items: {
        type: 'string',
      },
      type: 'array',
      title: 'Tags',
      description: 'Metadata tags.',
      default: [],
    },
    source_code: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Source Code',
      description: 'The source code of the function.',
    },
    json_schema: {
      anyOf: [
        {
          additionalProperties: true,
          type: 'object',
        },
        {
          type: 'null',
        },
      ],
      title: 'Json Schema',
      description: 'The JSON schema of the function.',
    },
    args_json_schema: {
      anyOf: [
        {
          additionalProperties: true,
          type: 'object',
        },
        {
          type: 'null',
        },
      ],
      title: 'Args Json Schema',
      description: 'The args JSON schema of the function.',
    },
    return_char_limit: {
      type: 'integer',
      title: 'Return Char Limit',
      description: 'The maximum number of characters in the response.',
      default: 50000,
    },
    pip_requirements: {
      anyOf: [
        {
          items: {
            $ref: '#/components/schemas/PipRequirement',
          },
          type: 'array',
        },
        {
          type: 'null',
        },
      ],
      title: 'Pip Requirements',
      description: 'Optional list of pip packages required by this tool.',
    },
    npm_requirements: {
      anyOf: [
        {
          items: {
            $ref: '#/components/schemas/NpmRequirement',
          },
          type: 'array',
        },
        {
          type: 'null',
        },
      ],
      title: 'Npm Requirements',
      description: 'Optional list of npm packages required by this tool.',
    },
    default_requires_approval: {
      anyOf: [
        {
          type: 'boolean',
        },
        {
          type: 'null',
        },
      ],
      title: 'Default Requires Approval',
      description:
        'Default value for whether or not executing this tool requires approval.',
    },
    created_by_id: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Created By Id',
      description: 'The id of the user that made this Tool.',
    },
    last_updated_by_id: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Last Updated By Id',
      description: 'The id of the user that made this Tool.',
    },
    metadata_: {
      anyOf: [
        {
          additionalProperties: true,
          type: 'object',
        },
        {
          type: 'null',
        },
      ],
      title: 'Metadata',
      description: 'A dictionary of additional metadata for the tool.',
    },
  },
  additionalProperties: false,
  type: 'object',
  required: ['id'],
  title: 'ToolSchema',
  description: 'Tool with human-readable ID for agent file',
} as const;

export const $letta__serialize_schemas__pydantic_agent_schema__AgentSchema = {
  properties: {
    agent_type: {
      type: 'string',
      title: 'Agent Type',
    },
    core_memory: {
      items: {
        $ref: '#/components/schemas/CoreMemoryBlockSchema',
      },
      type: 'array',
      title: 'Core Memory',
    },
    created_at: {
      type: 'string',
      title: 'Created At',
    },
    description: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Description',
    },
    embedding_config: {
      $ref: '#/components/schemas/EmbeddingConfig',
    },
    llm_config: {
      $ref: '#/components/schemas/LLMConfig',
    },
    message_buffer_autoclear: {
      type: 'boolean',
      title: 'Message Buffer Autoclear',
    },
    in_context_message_indices: {
      items: {
        type: 'integer',
      },
      type: 'array',
      title: 'In Context Message Indices',
    },
    messages: {
      items: {
        $ref: '#/components/schemas/letta__serialize_schemas__pydantic_agent_schema__MessageSchema',
      },
      type: 'array',
      title: 'Messages',
    },
    metadata_: {
      anyOf: [
        {
          additionalProperties: true,
          type: 'object',
        },
        {
          type: 'null',
        },
      ],
      title: 'Metadata',
    },
    multi_agent_group: {
      anyOf: [
        {},
        {
          type: 'null',
        },
      ],
      title: 'Multi Agent Group',
    },
    name: {
      type: 'string',
      title: 'Name',
    },
    system: {
      type: 'string',
      title: 'System',
    },
    tags: {
      items: {
        $ref: '#/components/schemas/TagSchema',
      },
      type: 'array',
      title: 'Tags',
    },
    tool_exec_environment_variables: {
      items: {
        $ref: '#/components/schemas/ToolEnvVarSchema',
      },
      type: 'array',
      title: 'Tool Exec Environment Variables',
    },
    tool_rules: {
      items: {
        anyOf: [
          {
            $ref: '#/components/schemas/BaseToolRuleSchema',
          },
          {
            $ref: '#/components/schemas/ChildToolRuleSchema',
          },
          {
            $ref: '#/components/schemas/MaxCountPerStepToolRuleSchema',
          },
          {
            $ref: '#/components/schemas/ConditionalToolRuleSchema',
          },
        ],
      },
      type: 'array',
      title: 'Tool Rules',
    },
    tools: {
      items: {
        $ref: '#/components/schemas/letta__serialize_schemas__pydantic_agent_schema__ToolSchema',
      },
      type: 'array',
      title: 'Tools',
    },
    updated_at: {
      type: 'string',
      title: 'Updated At',
    },
    version: {
      type: 'string',
      title: 'Version',
    },
  },
  type: 'object',
  required: [
    'agent_type',
    'core_memory',
    'created_at',
    'description',
    'embedding_config',
    'llm_config',
    'message_buffer_autoclear',
    'in_context_message_indices',
    'messages',
    'multi_agent_group',
    'name',
    'system',
    'tags',
    'tool_exec_environment_variables',
    'tool_rules',
    'tools',
    'updated_at',
    'version',
  ],
  title: 'AgentSchema',
} as const;

export const $letta__serialize_schemas__pydantic_agent_schema__MessageSchema = {
  properties: {
    created_at: {
      type: 'string',
      title: 'Created At',
    },
    group_id: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Group Id',
    },
    model: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Model',
    },
    name: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Name',
    },
    role: {
      type: 'string',
      title: 'Role',
    },
    content: {
      items: {
        $ref: '#/components/schemas/LettaMessageContentUnion',
      },
      type: 'array',
      title: 'Content',
    },
    tool_call_id: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Tool Call Id',
    },
    tool_calls: {
      items: {},
      type: 'array',
      title: 'Tool Calls',
    },
    tool_returns: {
      items: {},
      type: 'array',
      title: 'Tool Returns',
    },
    updated_at: {
      type: 'string',
      title: 'Updated At',
    },
  },
  type: 'object',
  required: [
    'created_at',
    'group_id',
    'model',
    'name',
    'role',
    'content',
    'tool_call_id',
    'tool_calls',
    'tool_returns',
    'updated_at',
  ],
  title: 'MessageSchema',
} as const;

export const $letta__serialize_schemas__pydantic_agent_schema__ToolSchema = {
  properties: {
    args_json_schema: {
      anyOf: [
        {},
        {
          type: 'null',
        },
      ],
      title: 'Args Json Schema',
    },
    created_at: {
      type: 'string',
      title: 'Created At',
    },
    description: {
      type: 'string',
      title: 'Description',
    },
    json_schema: {
      $ref: '#/components/schemas/ToolJSONSchema',
    },
    name: {
      type: 'string',
      title: 'Name',
    },
    return_char_limit: {
      type: 'integer',
      title: 'Return Char Limit',
    },
    source_code: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Source Code',
    },
    source_type: {
      type: 'string',
      title: 'Source Type',
    },
    tags: {
      items: {
        type: 'string',
      },
      type: 'array',
      title: 'Tags',
    },
    tool_type: {
      type: 'string',
      title: 'Tool Type',
    },
    updated_at: {
      type: 'string',
      title: 'Updated At',
    },
    metadata_: {
      anyOf: [
        {
          additionalProperties: true,
          type: 'object',
        },
        {
          type: 'null',
        },
      ],
      title: 'Metadata',
    },
  },
  type: 'object',
  required: [
    'args_json_schema',
    'created_at',
    'description',
    'json_schema',
    'name',
    'return_char_limit',
    'source_code',
    'source_type',
    'tags',
    'tool_type',
    'updated_at',
  ],
  title: 'ToolSchema',
} as const;

export const $LettaMessageUnion = {
  oneOf: [
    {
      $ref: '#/components/schemas/SystemMessage',
    },
    {
      $ref: '#/components/schemas/UserMessage',
    },
    {
      $ref: '#/components/schemas/ReasoningMessage',
    },
    {
      $ref: '#/components/schemas/HiddenReasoningMessage',
    },
    {
      $ref: '#/components/schemas/ToolCallMessage',
    },
    {
      $ref: '#/components/schemas/ToolReturnMessage',
    },
    {
      $ref: '#/components/schemas/AssistantMessage',
    },
    {
      $ref: '#/components/schemas/ApprovalRequestMessage',
    },
    {
      $ref: '#/components/schemas/ApprovalResponseMessage',
    },
  ],
  discriminator: {
    propertyName: 'message_type',
    mapping: {
      system_message: '#/components/schemas/SystemMessage',
      user_message: '#/components/schemas/UserMessage',
      reasoning_message: '#/components/schemas/ReasoningMessage',
      hidden_reasoning_message: '#/components/schemas/HiddenReasoningMessage',
      tool_call_message: '#/components/schemas/ToolCallMessage',
      tool_return_message: '#/components/schemas/ToolReturnMessage',
      assistant_message: '#/components/schemas/AssistantMessage',
      approval_request_message: '#/components/schemas/ApprovalRequestMessage',
      approval_response_message: '#/components/schemas/ApprovalResponseMessage',
    },
  },
} as const;

export const $LettaMessageContentUnion = {
  oneOf: [
    {
      $ref: '#/components/schemas/TextContent',
    },
    {
      $ref: '#/components/schemas/ImageContent',
    },
    {
      $ref: '#/components/schemas/ToolCallContent',
    },
    {
      $ref: '#/components/schemas/ToolReturnContent',
    },
    {
      $ref: '#/components/schemas/ReasoningContent',
    },
    {
      $ref: '#/components/schemas/RedactedReasoningContent',
    },
    {
      $ref: '#/components/schemas/OmittedReasoningContent',
    },
  ],
  discriminator: {
    propertyName: 'type',
    mapping: {
      text: '#/components/schemas/TextContent',
      image: '#/components/schemas/ImageContent',
      tool_call: '#/components/schemas/ToolCallContent',
      tool_return: '#/components/schemas/ToolCallContent',
      reasoning: '#/components/schemas/ReasoningContent',
      redacted_reasoning: '#/components/schemas/RedactedReasoningContent',
      omitted_reasoning: '#/components/schemas/OmittedReasoningContent',
    },
  },
} as const;

export const $LettaAssistantMessageContentUnion = {
  oneOf: [
    {
      $ref: '#/components/schemas/TextContent',
    },
  ],
  discriminator: {
    propertyName: 'type',
    mapping: {
      text: '#/components/schemas/TextContent',
    },
  },
} as const;

export const $LettaUserMessageContentUnion = {
  oneOf: [
    {
      $ref: '#/components/schemas/TextContent',
    },
    {
      $ref: '#/components/schemas/ImageContent',
    },
  ],
  discriminator: {
    propertyName: 'type',
    mapping: {
      text: '#/components/schemas/TextContent',
      image: '#/components/schemas/ImageContent',
    },
  },
} as const;

export const $LettaPing = {
  properties: {
    message_type: {
      type: 'string',
      const: 'ping',
      title: 'Message Type',
      description: 'The type of the message.',
      default: 'ping',
    },
  },
  type: 'object',
  required: ['message_type'],
  title: 'LettaPing',
  description:
    'Ping messages are a keep-alive to prevent SSE streams from timing out during long running requests.',
} as const;
