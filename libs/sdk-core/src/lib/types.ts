import { z } from 'zod';
import { jsonrepair } from 'jsonrepair';
import type {
  AgentState,
  SSEServerConfig,
  StdioServerConfig,
} from './_autogenerated/requests';
import { initContract } from '@ts-rest/core';
import {
  EmbeddingConfig,
  LettaUserMessageContentUnion,
  LLMConfig,
} from './_autogenerated/requests/zod.types.gen';

export interface AttachedAgent {
  id: string;
  name: string;
}

export interface SourceMetadata {
  num_documents: number;
  num_passages: number;
  attached_agents: AttachedAgent[];
}

export const SystemMessageSchema = z.object({
  message_type: z.literal('system_message'),
  content: z.string(),
  step_id: z.string().nullish(),
  date: z.string(),
  id: z.string(),
});

export const SystemAlertSchema = z.object({
  type: z.literal('system_alert'),
  message: z.string(),
  time: z.string(),
});

export const UserMessageSchema = z.object({
  message_type: z.literal('user_message'),
  formattedMessage: z.record(z.unknown()).optional(),
  content: z.union([z.string(), z.array(LettaUserMessageContentUnion)]),
  step_id: z.string().nullish(),
  otid: z.string().nullish(),
  name: z.string().nullish(),
  date: z.string(),
  id: z.string(),
  is_err: z.boolean().nullish(),
});

export const ReasoningMessageSchema = z.object({
  message_type: z.literal('reasoning_message'),
  source: z.enum(['reasoner_model', 'non_reasoner_model']),
  signature: z.string().nullish(),
  reasoning: z.string(),
  step_id: z.string().nullish(),
  otid: z.string().nullish(),
  name: z.string().nullish(),
  date: z.string(),
  id: z.string(),
  is_err: z.boolean().nullish(),
});

export const HiddenReasoningMessageSchema = z.object({
  message_type: z.literal('hidden_reasoning_message'),
  state: z.enum(['redacted', 'omitted']),
  hidden_reasoning: z.string().nullish(),
  otid: z.string().nullish(),
  name: z.string().nullish(),
  step_id: z.string().nullish(),
  date: z.string(),
  id: z.string(),
  is_err: z.boolean().nullish(),
});

export const SendMessageFunctionCallSchema = z.object({
  message: z.string(),
});

export const ToolCallMessageSchema = z.object({
  message_type: z.literal('tool_call_message'),
  tool_call: z.object({
    message_type: z.literal('tool_call_message').optional(),
    type: z.literal('tool_call').optional(),
    name: z.string().optional(),
    tool_call_id: z.string().optional(),
    arguments: z.string().optional(),
    formattedArguments: z.record(z.unknown()).optional(),
  }),
  otid: z.string().nullish(),
  name: z.string().nullish(),
  date: z.string(),
  step_id: z.string().nullish(),
  id: z.string(),
  is_err: z.boolean().nullish(),
});

export const ToolReturnMessageSchema = z.object({
  message_type: z.literal('tool_return_message'),
  stderr: z.array(z.string()).nullish(),
  stdout: z.array(z.string()).nullish(),
  tool_return: z.string(),
  tool_call_id: z.string(),
  status: z.string(),
  otid: z.string().nullish(),
  name: z.string().nullish(),
  date: z.string(),
  step_id: z.string().nullish(),
  id: z.string(),
  is_err: z.boolean().nullish(),
});

export type ToolReturnMessageSchemaType = z.infer<
  typeof ToolReturnMessageSchema
>;

export const AgentMessageSchema = z.discriminatedUnion('message_type', [
  ToolReturnMessageSchema,
  ToolCallMessageSchema,
  ReasoningMessageSchema,
  HiddenReasoningMessageSchema,
  UserMessageSchema,
  SystemMessageSchema,
]);

const ErrorCodeSchema = z.enum([
  'INTERNAL_SERVER_ERROR',
  'CONTEXT_WINDOW_EXCEEDED',
  'RATE_LIMIT_EXCEEDED',
  'AGENT_LIMIT_EXCEEDED',
  'CREDIT_LIMIT_EXCEEDED',
  'FREE_USAGE_EXCEEDED',
  'PREMIUM_USAGE_EXCEEDED',
]);

export const ErrorMessageSchema = z.object({
  error: z.string(),
  code: ErrorCodeSchema.optional(),
});

export const AgentMessageTypeSchema = z.enum([
  'tool_return_message',
  'tool_call_message',
  'reasoning_message',
  'user_message',
  'system_message',
]);

export function safeParseArguments(message: string): Record<string, any> {
  try {
    return JSON.parse(jsonrepair(message));
  } catch (_e) {
    return {};
  }
}

export type AgentMessage = z.infer<typeof AgentMessageSchema>;

const modelEndpointTypesSchema = LLMConfig.shape.model_endpoint_type;
const embeddingEndpointTypes = EmbeddingConfig.shape.embedding_endpoint_type;

// matches LLMConfig but enum is broken with ToZod
export const LLMConfigSchema = z.object({
  model: z.string(),
  handle: z.string().optional().nullable(),
  model_endpoint_type: modelEndpointTypesSchema,
  model_endpoint: z.string().optional().nullable(),
  model_wrapper: z.string().nullish(),
  context_window: z.number(),
});

export const EmbeddingConfigSchema = z.object({
  embedding_endpoint_type: embeddingEndpointTypes,
  embedding_endpoint: z.string().optional().nullable(),
  embedding_model: z.string(),
  embedding_dim: z.number(),
  embedding_chunk_size: z.number().optional().nullable(),
  azure_endpoint: z.string().optional().nullable(),
  azure_version: z.string().optional().nullable(),
  azure_deployment: z.string().optional().nullable(),
});


const c = initContract();

export const VersionedTemplateType = c.type<{
  id: string;
  fullVersion: string;
  version: string;
  state?: AgentState;
}>();

export type MCPServerItemType = SSEServerConfig | StdioServerConfig;

export const DatasetItemCreateMessageSchema = z.object({
  data: z.record(z.any()), // Objects could be anything
});

export type DatasetItemCreateMessageType = z.infer<
  typeof DatasetItemCreateMessageSchema
>;

export const LLMConfigPropertiesForAgentTemplateSchema = z.object({
  model: z.string(),
  model_endpoint_type: z.enum([
    'openai',
    'anthropic',
    'cohere',
    'google_ai',
    'google_vertex',
    'azure',
    'groq',
    'ollama',
    'webui',
    'webui-legacy',
    'lmstudio',
    'lmstudio-legacy',
    'lmstudio-chatcompletions',
    'llamacpp',
    'koboldcpp',
    'vllm',
    'hugging-face',
    'mistral',
    'together',
    'bedrock',
    'deepseek',
    'xai',
  ]),
  model_endpoint: z.string().optional().nullable(),
  provider_name: z.string().optional().nullable(),
  provider_category: z.enum(['byok', 'base']).nullable(),
  model_wrapper: z.string().nullish(),
  context_window: z.number(),
  put_inner_thoughts_in_kwargs: z.boolean().optional(),
  handle: z.string().optional().nullable(),
  temperature: z.number().optional(),
  max_tokens: z.number().optional(),
  enable_reasoner: z.boolean().optional(),
  reasoning_effort: z
    .enum(['minimal', 'low', 'medium', 'high'])
    .optional()
    .nullable(),
  max_reasoning_tokens: z.number().optional(),
  frequency_penalty: z.number().optional().nullable(),
  compatibility_type: z.enum(['gguf', 'mlx']).optional().nullable(),
});

export type LLMConfigPropertiesForAgentTemplateType = z.infer<
  typeof LLMConfigPropertiesForAgentTemplateSchema
>;



export const SupportedAgentTypeSchema = z.enum([
  'memgpt_agent',
  'memgpt_v2_agent',
  'react_agent',
  'workflow_agent',
  'split_thread_agent',
  'sleeptime_agent',
  'voice_convo_agent',
  'voice_sleeptime_agent',
]);

export type SupportedAgentTemplateType = z.infer<typeof SupportedAgentTypeSchema>;

/* the schema is purposly not structured as to allow for more flexibility in the agent template */
export const AgentTemplateProperties = z.object({
  enable_reasoner: z.boolean().nullable(),
  put_inner_thoughts_in_kwargs: z.boolean().nullable(),
  context_window_limit: z.number().nullable(),
  max_tokens: z.number().nullable(),
  max_reasoning_tokens: z.number().nullable(),
  max_files_open: z.number().nullable(),
  message_buffer_autoclear: z.boolean().nullable(),
  verbosity_level: z.enum(['low', 'medium', 'high']).nullable(),
  reasoning_effort: z.enum(['minimal', 'low', 'medium', 'high']).nullable(),
  per_file_view_window_char_limit: z.number().nullable(),
  temperature: z.number().nullable(),
});

export type AgentTemplatePropertiesType = z.infer<
  typeof AgentTemplateProperties
>;

export const GroupConfigurationSchema = z.object({
  managerAgentEntityId: z.string().optional(),
  managerType: z.string().optional(),
  terminationToken: z.string().optional(),
  maxTurns: z.number().optional(),
  sleeptimeAgentFrequency: z.number().optional(),
  maxMessageBufferLength: z.number().optional(),
  minMessageBufferLength: z.number().optional(),
});

export type GroupConfigurationType = z.infer<typeof GroupConfigurationSchema>;

export const LettaTemplateTypes = z.enum([
  'classic',
  'cluster',
  'sleeptime',
  'round_robin',
  'supervisor',
  'dynamic',
  'voice_sleeptime',
]);

export type LettaTemplateTypesType = z.infer<typeof LettaTemplateTypes>;
