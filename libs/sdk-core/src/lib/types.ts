import { z } from 'zod';
import { jsonrepair } from 'jsonrepair';
import type { ToZod } from '@letta-cloud/utils-types';
import type {
  AgentState,
  Block,
  CreateBlock,
  SSEServerConfig,
  StdioServerConfig,
} from './_autogenerated/requests';
import { initContract } from '@ts-rest/core';
import {
  EmbeddingConfig,
  LettaUserMessageContentUnion,
  LLMConfig,
} from './_autogenerated/requests/zod.types.gen';

export interface AttachedAgent {
  id: string;
  name: string;
}

export interface SourceMetadata {
  num_documents: number;
  num_passages: number;
  attached_agents: AttachedAgent[];
}

export const SystemMessageSchema = z.object({
  message_type: z.literal('system_message'),
  content: z.string(),
  step_id: z.string().nullish(),
  date: z.string(),
  id: z.string(),
});

export const SystemAlertSchema = z.object({
  type: z.literal('system_alert'),
  message: z.string(),
  time: z.string(),
});

export const UserMessageSchema = z.object({
  message_type: z.literal('user_message'),
  formattedMessage: z.record(z.unknown()).optional(),
  content: z.union([z.string(), z.array(LettaUserMessageContentUnion)]),
  step_id: z.string().nullish(),
  otid: z.string().nullish(),
  name: z.string().nullish(),
  date: z.string(),
  id: z.string(),
});

export const ReasoningMessageSchema = z.object({
  message_type: z.literal('reasoning_message'),
  source: z.enum(['reasoner_model', 'non_reasoner_model']),
  signature: z.string().nullish(),
  reasoning: z.string(),
  step_id: z.string().nullish(),
  otid: z.string().nullish(),
  name: z.string().nullish(),
  date: z.string(),
  id: z.string(),
});

export const HiddenReasoningMessageSchema = z.object({
  message_type: z.literal('hidden_reasoning_message'),
  state: z.enum(['redacted', 'omitted']),
  hidden_reasoning: z.string().nullish(),
  otid: z.string().nullish(),
  name: z.string().nullish(),
  step_id: z.string().nullish(),
  date: z.string(),
  id: z.string(),
});

export const SendMessageFunctionCallSchema = z.object({
  message: z.string(),
});

export const ToolCallMessageSchema = z.object({
  message_type: z.literal('tool_call_message'),
  tool_call: z.object({
    message_type: z.literal('tool_call_message').optional(),
    type: z.literal('tool_call').optional(),
    name: z.string().optional(),
    tool_call_id: z.string().optional(),
    arguments: z.string().optional(),
    formattedArguments: z.record(z.unknown()).optional(),
  }),
  otid: z.string().nullish(),
  name: z.string().nullish(),
  date: z.string(),
  step_id: z.string().nullish(),
  id: z.string(),
});

export const ToolReturnMessageSchema = z.object({
  message_type: z.literal('tool_return_message'),
  stderr: z.array(z.string()).nullish(),
  stdout: z.array(z.string()).nullish(),
  tool_return: z.string(),
  tool_call_id: z.string(),
  status: z.string(),
  otid: z.string().nullish(),
  name: z.string().nullish(),
  date: z.string(),
  step_id: z.string().nullish(),
  id: z.string(),
});

export type ToolReturnMessageSchemaType = z.infer<
  typeof ToolReturnMessageSchema
>;

export const AgentMessageSchema = z.discriminatedUnion('message_type', [
  ToolReturnMessageSchema,
  ToolCallMessageSchema,
  ReasoningMessageSchema,
  HiddenReasoningMessageSchema,
  UserMessageSchema,
  SystemMessageSchema,
]);

const ErrorCodeSchema = z.enum([
  'INTERNAL_SERVER_ERROR',
  'CONTEXT_WINDOW_EXCEEDED',
  'RATE_LIMIT_EXCEEDED',
  'AGENT_LIMIT_EXCEEDED',
  'CREDIT_LIMIT_EXCEEDED',
  'FREE_USAGE_EXCEEDED',
  'PREMIUM_USAGE_EXCEEDED',
]);

export const ErrorMessageSchema = z.object({
  error: z.string(),
  code: ErrorCodeSchema.optional(),
});

export const AgentMessageTypeSchema = z.enum([
  'tool_return_message',
  'tool_call_message',
  'reasoning_message',
  'user_message',
  'system_message',
]);

export function safeParseArguments(message: string): Record<string, any> {
  try {
    return JSON.parse(jsonrepair(message));
  } catch (_e) {
    return {};
  }
}

export type AgentMessage = z.infer<typeof AgentMessageSchema>;

const modelEndpointTypesSchema = LLMConfig.shape.model_endpoint_type;
const embeddingEndpointTypes = EmbeddingConfig.shape.embedding_endpoint_type;

// matches LLMConfig but enum is broken with ToZod
export const LLMConfigSchema = z.object({
  model: z.string(),
  handle: z.string().optional().nullable(),
  model_endpoint_type: modelEndpointTypesSchema,
  model_endpoint: z.string().optional().nullable(),
  model_wrapper: z.string().nullish(),
  context_window: z.number(),
});

export const EmbeddingConfigSchema = z.object({
  embedding_endpoint_type: embeddingEndpointTypes,
  embedding_endpoint: z.string().optional().nullable(),
  embedding_model: z.string(),
  embedding_dim: z.number(),
  embedding_chunk_size: z.number().optional().nullable(),
  azure_endpoint: z.string().optional().nullable(),
  azure_version: z.string().optional().nullable(),
  azure_deployment: z.string().optional().nullable(),
});

const BlockMetadataSchema = z.record(z.unknown());

export const BlockSchema: ToZod<Omit<Block, 'metadata'>> = z.object({
  value: z.string(),
  limit: z.number().optional(),
  name: z.string().nullish(),
  label: z.string().nullish(),
  description: z.string().nullish(),
  metadata: BlockMetadataSchema.optional(),
  id: z.string().optional(),
  source_id: z.string().nullish(),
  organization_id: z.string().nullish(),
  created_by_id: z.string().nullish(),
  last_updated_by_id: z.string().nullish(),
  is_template: z.boolean().optional(),
  identity_ids: z.array(z.string()).optional(),
  read_only: z.boolean().optional(),
  preserve_on_migration: z.boolean().nullish(),
});

export const MemorySchema = z.object({
  memory: z.record(BlockSchema).optional(),
  prompt_template: z.string().optional(),
});

export const CreateBlockSchema: ToZod<Omit<CreateBlock, 'metadata'>> = z.object(
  {
    value: z.string(),
    limit: z.number().optional(),
    name: z.string().nullish(),
    label: z.string(),
    description: z.string().nullish(),
    source_id: z.string().nullish(),
    metadata: BlockMetadataSchema.optional(),
    is_template: z.boolean().optional(),
    identity_ids: z.array(z.string()).nullish(),
    read_only: z.boolean().optional(),
    preserve_on_migration: z.boolean().nullish(),
  },
);

export const MemoryBlocksSchema = z.array(CreateBlockSchema);

const c = initContract();

export const VersionedTemplateType = c.type<{
  id: string;
  fullVersion: string;
  version: string;
  state?: AgentState;
}>();

export type MCPServerItemType = SSEServerConfig | StdioServerConfig;
