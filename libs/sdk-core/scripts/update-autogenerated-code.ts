import { Project, SyntaxKind } from 'ts-morph';
import * as path from 'path';
import * as fs from 'fs';
import { execSync } from 'child_process';

async function job() {
  const project = new Project();

  project.addSourceFilesAtPaths(
    path.join(
      __dirname,
      '..',
      'src',
      'lib',
      '_autogenerated',
      'requests',
      '**/*.ts',
    ),
  );

  const typesFile = project.getSourceFileOrThrow('types.gen.ts');

  // find type name 'object' and delete it
  typesFile.getTypeAlias('object')?.remove();

  const openAPIFile = project.getSourceFileOrThrow(
    path.join(
      __dirname,
      '..',
      'src',
      'lib',
      '_autogenerated',
      'requests',
      'core',
      'OpenAPI.ts',
    ),
  );

  // find the constant OpenAPI, look at BASE property and change it to process.env.LETTA_AGENTS_ENDPOINT

  const openAPI = openAPIFile.getVariableDeclarationOrThrow('OpenAPI');

  const dataValue = openAPI.getInitializerIfKind(
    SyntaxKind.ObjectLiteralExpression,
  );

  dataValue?.getProperty('BASE')?.remove();

  dataValue?.addPropertyAssignment({
    name: 'BASE',
    initializer: "process.env.LETTA_AGENTS_ENDPOINT || ''",
  });

  const sourceFile = project.getSourceFileOrThrow('services.gen.ts');

  sourceFile.getClasses().forEach((cls) => {
    cls.getMethods().forEach((method) => {
      const hasHeaderParam = method.getParameters().some((param) => {
        return param.getName() === 'headers';
      });

      if (!hasHeaderParam) {
        method.addParameter({
          name: 'headers',
          type: '{ user_id: string, [x: string]: string }',
          hasQuestionToken: true,
        });
      }

      method.forEachChild((node) => {
        if (node.isKind(SyntaxKind.Block)) {
          node.forEachChild((child) => {
            if (child.isKind(SyntaxKind.ReturnStatement)) {
              child.forEachChild((sub) => {
                if (sub.isKind(SyntaxKind.CallExpression)) {
                  const secondPart = sub.getArguments()[1];

                  if (secondPart.isKind(SyntaxKind.ObjectLiteralExpression)) {
                    secondPart.getProperty('headers')?.remove();

                    secondPart.addShorthandPropertyAssignment({
                      name: 'headers',
                    });
                  }
                }
              });
            }
          });
        }
      });
    });
  });

  await project.save();

  // create zod schema from types.gen.ts
  execSync(
    'npx typed-openapi ../../apps/core/letta/server/openapi_letta.json -r zod -o src/lib/_autogenerated/requests/zod.types.gen.ts',
    {
      stdio: 'inherit',
    },
  );

  formatAutogeneratedFiles();
}

function formatAutogeneratedFiles() {
  const autoGeneratedDir = path.join(
    __dirname,
    '..',
    'src',
    'lib',
    '_autogenerated',
  );

  try {
    // Use Prettier to format all TypeScript files in _autogenerated directory
    execSync(`npx prettier --write "${autoGeneratedDir}/**/*.ts"`, {
      stdio: 'inherit',
    });
    console.log(
      'Successfully formatted autogenerated TypeScript files with Prettier',
    );
  } catch (error) {
    console.error('Error formatting autogenerated files:', error);
    process.exit(1);
  }
}

async function updateTypes() {
  // get types file replace LettaResponse_properties_FunctionCall with LettaResponse_properties_FunctionCall[]

  const typesFiles = fs.readFileSync(
    path.join(
      __dirname,
      '..',
      'src',
      'lib',
      '_autogenerated',
      'requests',
      'types.gen.ts',
    ),
    'utf-8',
  );

  const newTypesFile = typesFiles.replace(
    /LettaResponse_properties_([A-z]+)/g,
    'LettaResponse["$1"]',
  );

  fs.writeFileSync(
    path.join(
      __dirname,
      '..',
      'src',
      'lib',
      '_autogenerated',
      'requests',
      'types.gen.ts',
    ),
    newTypesFile,
  );
}

updateTypes().catch(console.error);

job().catch(console.error);
