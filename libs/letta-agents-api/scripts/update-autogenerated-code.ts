import { Project, SyntaxKind } from 'ts-morph';
import * as path from 'path';
import * as fs from 'fs';
import { execSync } from 'child_process';

async function job() {
  const project = new Project();

  project.addSourceFilesAtPaths(
    path.join(
      __dirname,
      '..',
      'src',
      'lib',
      '_autogenerated',
      'requests',
      '**/*.ts',
    ),
  );

  const typesFile = project.getSourceFileOrThrow('types.gen.ts');

  // find type name 'object' and delete it
  typesFile.getTypeAlias('object')?.remove();

  const openAPIFile = project.getSourceFileOrThrow(
    path.join(
      __dirname,
      '..',
      'src',
      'lib',
      '_autogenerated',
      'requests',
      'core',
      'OpenAPI.ts',
    ),
  );

  // find the constant OpenAPI, look at BASE property and change it to process.env.LETTA_AGENTS_ENDPOINT

  const openAPI = openAPIFile.getVariableDeclarationOrThrow('OpenAPI');

  const dataValue = openAPI.getInitializerIfKind(
    SyntaxKind.ObjectLiteralExpression,
  );

  dataValue?.getProperty('BASE')?.remove();

  dataValue?.addPropertyAssignment({
    name: 'BASE',
    initializer: "process.env.LETTA_AGENTS_ENDPOINT || ''",
  });

  const sourceFile = project.getSourceFileOrThrow('services.gen.ts');

  sourceFile.getClasses().forEach((cls) => {
    cls.getMethods().forEach((method) => {
      const hasHeaderParam = method.getParameters().some((param) => {
        return param.getName() === 'headers';
      });

      if (!hasHeaderParam) {
        method.addParameter({
          name: 'headers',
          type: '{ user_id: string }',
          hasQuestionToken: true,
        });
      }

      method.forEachChild((node) => {
        if (node.isKind(SyntaxKind.Block)) {
          node.forEachChild((child) => {
            if (child.isKind(SyntaxKind.ReturnStatement)) {
              child.forEachChild((sub) => {
                if (sub.isKind(SyntaxKind.CallExpression)) {
                  const secondPart = sub.getArguments()[1];

                  if (secondPart.isKind(SyntaxKind.ObjectLiteralExpression)) {
                    secondPart.getProperty('headers')?.remove();

                    secondPart.addShorthandPropertyAssignment({
                      name: 'headers',
                    });
                  }
                }
              });
            }
          });
        }
      });
    });
  });

  await project.save();
  formatAutogeneratedFiles();
}

function formatAutogeneratedFiles() {
  const filePath = path.join(
    __dirname,
    '..',
    'src',
    'lib',
    '_autogenerated',
    'requests',
    '**',
    '*.ts',
  );

  try {
    // Use Prettier to format the JSON file
    execSync(`npx prettier --write "${filePath}"`, { stdio: 'inherit' });
    console.log('Successfully formatted openapi.json with Prettier');
  } catch (error) {
    console.error('Error formatting openapi.json:', error);
    process.exit(1);
  }
}

async function updateTypes() {
  // get types file replace LettaResponse_properties_FunctionCall with LettaResponse_properties_FunctionCall[]

  const typesFiles = fs.readFileSync(
    path.join(
      __dirname,
      '..',
      'src',
      'lib',
      '_autogenerated',
      'requests',
      'types.gen.ts',
    ),
    'utf-8',
  );

  const newTypesFile = typesFiles.replace(
    /LettaResponse_properties_([A-z]+)/g,
    'LettaResponse["$1"]',
  );

  fs.writeFileSync(
    path.join(
      __dirname,
      '..',
      'src',
      'lib',
      '_autogenerated',
      'requests',
      'types.gen.ts',
    ),
    newTypesFile,
  );
}

updateTypes().catch(console.error);

job().catch(console.error);
