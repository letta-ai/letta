// This file is auto-generated by @hey-api/openapi-ts

export type APIKey = {
  /**
   * The human-friendly ID of the Sk
   */
  id?: string;
  /**
   * The unique identifier of the user associated with the token.
   */
  user_id: string;
  /**
   * The key value.
   */
  key: string;
  /**
   * Name of the token.
   */
  name: string;
};

export type APIKeyCreate = {
  /**
   * The unique identifier of the user associated with the token.
   */
  user_id: string;
  /**
   * Name of the token.
   */
  name?: string | null;
};

/**
 * Representation of an agent's state. This is the state of the agent at a given time, and is persisted in the DB backend. The state has all the information needed to recreate a persisted agent.
 *
 * Parameters:
 * id (str): The unique identifier of the agent.
 * name (str): The name of the agent (must be unique to the user).
 * created_at (datetime): The datetime the agent was created.
 * message_ids (List[str]): The ids of the messages in the agent's in-context memory.
 * memory (Memory): The in-context memory of the agent.
 * tools (List[str]): The tools used by the agent. This includes any memory editing functions specified in `memory`.
 * system (str): The system prompt used by the agent.
 * llm_config (LLMConfig): The LLM configuration used by the agent.
 * embedding_config (EmbeddingConfig): The embedding configuration used by the agent.
 */
export type AgentState = {
  /**
   * The description of the agent.
   */
  description?: string | null;
  /**
   * The metadata of the agent.
   */
  metadata_?: {
    [key: string]: unknown;
  } | null;
  /**
   * The user id of the agent.
   */
  user_id?: string | null;
  /**
   * The human-friendly ID of the Agent
   */
  id?: string;
  /**
   * The name of the agent.
   */
  name: string;
  /**
   * The datetime the agent was created.
   */
  created_at?: string;
  /**
   * The ids of the messages in the agent's in-context memory.
   */
  message_ids?: Array<string> | null;
  /**
   * The in-context memory of the agent.
   */
  memory?: Memory;
  /**
   * The tools used by the agent.
   */
  tools: Array<string>;
  /**
   * The system prompt used by the agent.
   */
  system: string;
  /**
   * The LLM configuration used by the agent.
   */
  llm_config: LLMConfig;
  /**
   * The embedding configuration used by the agent.
   */
  embedding_config: EmbeddingConfig;
};

export type ArchivalMemorySummary = {
  /**
   * Number of rows in archival memory
   */
  size: number;
};

export type AssistantFile = {
  /**
   * The unique identifier of the file.
   */
  id: string;
  object?: string;
  /**
   * The unix timestamp of when the file was created.
   */
  created_at: number;
  /**
   * The unique identifier of the assistant.
   */
  assistant_id: string;
};

export type AssistantMessage_Input = {
  content?: string | null;
  role?: string;
  name?: string | null;
  tool_calls?: Array<letta__schemas__openai__chat_completion_request__ToolCall> | null;
};

export type AssistantMessage_Output = {
  id: string;
  date: string;
  message_type?: 'assistant_message';
  assistant_message: string;
};

export type message_type = 'assistant_message';

export type AuthRequest = {
  /**
   * Admin password provided when starting the Letta server
   */
  password?: string;
};

export type AuthResponse = {
  /**
   * UUID of the user
   */
  uuid: string;
  /**
   * Whether the user is an admin
   */
  is_admin?: boolean | null;
};

/**
 * A Block represents a reserved section of the LLM's context window which is editable. `Block` objects contained in the `Memory` object, which is able to edit the Block values.
 *
 * Parameters:
 * name (str): The name of the block.
 * value (str): The value of the block. This is the string that is represented in the context window.
 * limit (int): The character limit of the block.
 * template (bool): Whether the block is a template (e.g. saved human/persona options). Non-template blocks are not stored in the database and are ephemeral, while templated blocks are stored in the database.
 * label (str): The label of the block (e.g. 'human', 'persona'). This defines a category for the block.
 * description (str): Description of the block.
 * metadata_ (Dict): Metadata of the block.
 * user_id (str): The unique identifier of the user associated with the block.
 */
export type Block = {
  /**
   * Value of the block.
   */
  value: string;
  /**
   * Character limit of the block.
   */
  limit?: number;
  /**
   * Name of the block.
   */
  name?: string | null;
  /**
   * Whether the block is a template (e.g. saved human/persona options).
   */
  template?: boolean;
  /**
   * Label of the block (e.g. 'human', 'persona').
   */
  label?: string | null;
  /**
   * Description of the block.
   */
  description?: string | null;
  /**
   * Metadata of the block.
   */
  metadata_?: {
    [key: string]: unknown;
  } | null;
  /**
   * The unique identifier of the user associated with the block.
   */
  user_id?: string | null;
  /**
   * The human-friendly ID of the Block
   */
  id?: string;
};

export type Body_upload_file_to_source = {
  file: Blob | File;
};

/**
 * https://platform.openai.com/docs/api-reference/chat/create
 */
export type ChatCompletionRequest = {
  model: string;
  messages: Array<
    | SystemMessage_Input
    | UserMessage_Input
    | AssistantMessage_Input
    | ToolMessage
  >;
  frequency_penalty?: number | null;
  logit_bias?: {
    [key: string]: number;
  } | null;
  logprobs?: boolean | null;
  top_logprobs?: number | null;
  max_tokens?: number | null;
  n?: number | null;
  presence_penalty?: number | null;
  response_format?: ResponseFormat | null;
  seed?: number | null;
  stop?: string | Array<string> | null;
  stream?: boolean | null;
  temperature?: number | null;
  top_p?: number | null;
  user?: string | null;
  tools?: Array<Tool_Input> | null;
  tool_choice?: 'none' | 'auto' | ToolFunctionChoice | null;
  functions?: Array<FunctionSchema> | null;
  function_call?: 'none' | 'auto' | FunctionCall_Input | null;
};

/**
 * https://platform.openai.com/docs/api-reference/chat/object
 */
export type ChatCompletionResponse = {
  id: string;
  choices: Array<Choice>;
  created: string;
  model?: string | null;
  system_fingerprint?: string | null;
  object?: 'chat.completion';
  usage: UsageStatistics;
};

export type Choice = {
  finish_reason: string;
  index: number;
  message: letta__schemas__openai__chat_completion_response__Message;
  logprobs?: {
    [key: string]: Array<MessageContentLogProb> | null;
  } | null;
};

export type CreateAgent = {
  /**
   * The description of the agent.
   */
  description?: string | null;
  /**
   * The metadata of the agent.
   */
  metadata_?: {
    [key: string]: unknown;
  } | null;
  /**
   * The user id of the agent.
   */
  user_id?: string | null;
  /**
   * The name of the agent.
   */
  name?: string | null;
  /**
   * The ids of the messages in the agent's in-context memory.
   */
  message_ids?: Array<string> | null;
  /**
   * The in-context memory of the agent.
   */
  memory?: Memory | null;
  /**
   * The tools used by the agent.
   */
  tools?: Array<string> | null;
  /**
   * The system prompt used by the agent.
   */
  system?: string | null;
  /**
   * The LLM configuration used by the agent.
   */
  llm_config?: LLMConfig | null;
  /**
   * The embedding configuration used by the agent.
   */
  embedding_config?: EmbeddingConfig | null;
};

export type CreateArchivalMemory = {
  /**
   * Text to write to archival memory.
   */
  text: string;
};

export type CreateAssistantFileRequest = {
  /**
   * The unique identifier of the file.
   */
  file_id: string;
};

export type CreateAssistantRequest = {
  /**
   * The model to use for the assistant.
   */
  model: string;
  /**
   * The name of the assistant.
   */
  name: string;
  /**
   * The description of the assistant.
   */
  description?: string;
  /**
   * The instructions for the assistant.
   */
  instructions: string;
  /**
   * The tools used by the assistant.
   */
  tools?: Array<string>;
  /**
   * List of file IDs associated with the assistant.
   */
  file_ids?: Array<string>;
  /**
   * Metadata associated with the assistant.
   */
  metadata?: {
    [key: string]: unknown;
  };
  /**
   * The model to use for the assistant.
   */
  embedding_model?: string;
};

/**
 * Create a block
 */
export type CreateBlock = {
  /**
   * Value of the block.
   */
  value?: string | null;
  /**
   * Character limit of the block.
   */
  limit?: number;
  /**
   * Name of the block.
   */
  name?: string | null;
  template?: boolean;
  /**
   * Label of the block.
   */
  label: string;
  /**
   * Description of the block.
   */
  description?: string | null;
  /**
   * Metadata of the block.
   */
  metadata_?: {
    [key: string]: unknown;
  } | null;
  /**
   * The unique identifier of the user associated with the block.
   */
  user_id?: string | null;
};

export type CreateMessageRequest = {
  /**
   * Role of the message sender (either 'user' or 'system')
   */
  role: string;
  /**
   * The message content to be processed by the agent.
   */
  content: string;
  /**
   * List of file IDs associated with the message.
   */
  file_ids?: Array<string> | null;
  /**
   * Metadata associated with the message.
   */
  metadata?: {
    [key: string]: unknown;
  } | null;
};

export type CreateRunRequest = {
  /**
   * The unique identifier of the assistant.
   */
  assistant_id: string;
  /**
   * The model used by the run.
   */
  model?: string | null;
  /**
   * The instructions for the run.
   */
  instructions: string;
  /**
   * Additional instructions for the run.
   */
  additional_instructions?: string | null;
  /**
   * The tools used by the run (overrides assistant).
   */
  tools?: Array<letta__schemas__openai__openai__ToolCall> | null;
  /**
   * Metadata associated with the run.
   */
  metadata?: {
    [key: string]: unknown;
  } | null;
};

export type CreateThreadRequest = {
  /**
   * List of message IDs associated with the thread.
   */
  messages?: Array<string> | null;
  /**
   * Metadata associated with the thread.
   */
  metadata?: {
    [key: string]: unknown;
  } | null;
  /**
   * The name of the assistant (i.e. Letta preset)
   */
  assistant_name?: string | null;
};

export type CreateThreadRunRequest = {
  /**
   * The unique identifier of the assistant.
   */
  assistant_id: string;
  /**
   * The thread to run.
   */
  thread: OpenAIThread;
  /**
   * The model used by the run.
   */
  model: string;
  /**
   * The instructions for the run.
   */
  instructions: string;
  /**
   * The tools used by the run (overrides assistant).
   */
  tools?: Array<letta__schemas__openai__openai__ToolCall> | null;
  /**
   * Metadata associated with the run.
   */
  metadata?: {
    [key: string]: unknown;
  } | null;
};

export type DeleteAssistantFileResponse = {
  /**
   * The unique identifier of the file.
   */
  id: string;
  object?: string;
  /**
   * Whether the file was deleted.
   */
  deleted: boolean;
};

export type DeleteAssistantResponse = {
  /**
   * The unique identifier of the agent.
   */
  id: string;
  object?: string;
  /**
   * Whether the agent was deleted.
   */
  deleted: boolean;
};

export type DeleteThreadResponse = {
  /**
   * The unique identifier of the agent.
   */
  id: string;
  object?: string;
  /**
   * Whether the agent was deleted.
   */
  deleted: boolean;
};

/**
 * Representation of a single document (broken up into `Passage` objects)
 */
export type Document = {
  /**
   * The human-friendly ID of the Doc
   */
  id?: string;
  /**
   * The text of the document.
   */
  text: string;
  /**
   * The unique identifier of the source associated with the document.
   */
  source_id: string;
  /**
   * The unique identifier of the user associated with the document.
   */
  user_id: string;
  /**
   * The metadata of the document.
   */
  metadata_?: {
    [key: string]: unknown;
  } | null;
};

/**
 * Embedding model configuration. This object specifies all the information necessary to access an embedding model to usage with Letta, except for secret keys.
 *
 * Attributes:
 * embedding_endpoint_type (str): The endpoint type for the model.
 * embedding_endpoint (str): The endpoint for the model.
 * embedding_model (str): The model for the embedding.
 * embedding_dim (int): The dimension of the embedding.
 * embedding_chunk_size (int): The chunk size of the embedding.
 * azure_endpoint (:obj:`str`, optional): The Azure endpoint for the model (Azure only).
 * azure_version (str): The Azure version for the model (Azure only).
 * azure_deployment (str): The Azure deployment for the model (Azure only).
 */
export type EmbeddingConfig = {
  /**
   * The endpoint type for the model.
   */
  embedding_endpoint_type: string;
  /**
   * The endpoint for the model (`None` if local).
   */
  embedding_endpoint?: string | null;
  /**
   * The model for the embedding.
   */
  embedding_model: string;
  /**
   * The dimension of the embedding.
   */
  embedding_dim: number;
  /**
   * The chunk size of the embedding.
   */
  embedding_chunk_size?: number | null;
  /**
   * The Azure endpoint for the model.
   */
  azure_endpoint?: string | null;
  /**
   * The Azure version for the model.
   */
  azure_version?: string | null;
  /**
   * The Azure deployment for the model.
   */
  azure_deployment?: string | null;
};

export type Function = {
  /**
   * The name of the function.
   */
  name: string;
  /**
   * The arguments of the function.
   */
  arguments: string;
};

export type FunctionCall_Input = {
  name: string;
};

export type FunctionCallDelta = {
  name: string | null;
  arguments: string | null;
};

/**
 * A message representing a request to call a function (generated by the LLM to trigger function execution).
 *
 * Attributes:
 * function_call (Union[FunctionCall, FunctionCallDelta]): The function call
 * id (str): The ID of the message
 * date (datetime): The date the message was created in ISO format
 */
export type FunctionCallMessage = {
  id: string;
  date: string;
  message_type?: 'function_call';
  function_call:
    | letta__schemas__letta_message__FunctionCall
    | FunctionCallDelta;
};

export type message_type2 = 'function_call';

/**
 * A message representing the return value of a function call (generated by Letta executing the requested function).
 *
 * Attributes:
 * function_return (str): The return value of the function
 * status (Literal["success", "error"]): The status of the function call
 * id (str): The ID of the message
 * date (datetime): The date the message was created in ISO format
 */
export type FunctionReturn = {
  id: string;
  date: string;
  message_type?: 'function_return';
  function_return: string;
  status: 'success' | 'error';
};

export type message_type3 = 'function_return';

export type status = 'success' | 'error';

export type FunctionSchema = {
  name: string;
  description?: string | null;
  parameters?: {
    [key: string]: unknown;
  } | null;
};

export type HTTPValidationError = {
  detail?: Array<ValidationError>;
};

export type ImageFile = {
  type?: string;
  file_id: string;
};

/**
 * Representation of an agent's internal monologue.
 *
 * Attributes:
 * internal_monologue (str): The internal monologue of the agent
 * id (str): The ID of the message
 * date (datetime): The date the message was created in ISO format
 */
export type InternalMonologue = {
  id: string;
  date: string;
  message_type?: 'internal_monologue';
  internal_monologue: string;
};

export type message_type4 = 'internal_monologue';

/**
 * Representation of offline jobs, used for tracking status of data loading tasks (involving parsing and embedding documents).
 *
 * Parameters:
 * id (str): The unique identifier of the job.
 * status (JobStatus): The status of the job.
 * created_at (datetime): The unix timestamp of when the job was created.
 * completed_at (datetime): The unix timestamp of when the job was completed.
 * user_id (str): The unique identifier of the user associated with the.
 */
export type Job = {
  /**
   * The metadata of the job.
   */
  metadata_?: {
    [key: string]: unknown;
  } | null;
  /**
   * The human-friendly ID of the Job
   */
  id?: string;
  /**
   * The status of the job.
   */
  status?: JobStatus;
  /**
   * The unix timestamp of when the job was created.
   */
  created_at?: string;
  /**
   * The unix timestamp of when the job was completed.
   */
  completed_at?: string | null;
  /**
   * The unique identifier of the user associated with the job.
   */
  user_id: string;
};

/**
 * Status of the job.
 */
export type JobStatus =
  | 'created'
  | 'running'
  | 'completed'
  | 'failed'
  | 'pending';

/**
 * Configuration for a Language Model (LLM) model. This object specifies all the information necessary to access an LLM model to usage with Letta, except for secret keys.
 *
 * Attributes:
 * model (str): The name of the LLM model.
 * model_endpoint_type (str): The endpoint type for the model.
 * model_endpoint (str): The endpoint for the model.
 * model_wrapper (str): The wrapper for the model.
 * context_window (int): The context window size for the model.
 */
export type LLMConfig = {
  /**
   * LLM model name.
   */
  model: string;
  /**
   * The endpoint type for the model.
   */
  model_endpoint_type: string;
  /**
   * The endpoint for the model.
   */
  model_endpoint: string;
  /**
   * The wrapper for the model.
   */
  model_wrapper?: string | null;
  /**
   * The context window size for the model.
   */
  context_window: number;
};

/**
 * Base class for simplified Letta message response type. This is intended to be used for developers who want the internal monologue, function calls, and function returns in a simplified format that does not include additional information other than the content and timestamp.
 *
 * Attributes:
 * id (str): The ID of the message
 * date (datetime): The date the message was created in ISO format
 */
export type LettaMessage = {
  id: string;
  date: string;
};

export type LettaRequest = {
  /**
   * The messages to be sent to the agent.
   */
  messages: Array<MessageCreate>;
  /**
   * Whether to asynchronously send the messages to the agent.
   */
  run_async?: boolean;
  /**
   * Flag to determine if the response should be streamed. Set to True for streaming agent steps.
   */
  stream_steps?: boolean;
  /**
   * Flag to determine if individual tokens should be streamed. Set to True for token streaming (requires stream_steps = True).
   */
  stream_tokens?: boolean;
  /**
   * Set True to return the raw Message object. Set False to return the Message in the format of the Letta API.
   */
  return_message_object?: boolean;
};

/**
 * Response object from an agent interaction, consisting of the new messages generated by the agent and usage statistics.
 * The type of the returned messages can be either `Message` or `LettaMessage`, depending on what was specified in the request.
 *
 * Attributes:
 * messages (List[Union[Message, LettaMessage]]): The messages returned by the agent.
 * usage (LettaUsageStatistics): The usage statistics
 */
export type LettaResponse = {
  /**
   * The messages returned by the agent.
   */
  messages: Array<letta__schemas__message__Message> | Array<LettaMessage>;
  /**
   * The usage statistics of the agent.
   */
  usage: LettaUsageStatistics;
};

/**
 * Usage statistics for the agent interaction.
 *
 * Attributes:
 * completion_tokens (int): The number of tokens generated by the agent.
 * prompt_tokens (int): The number of tokens in the prompt.
 * total_tokens (int): The total number of tokens processed by the agent.
 * step_count (int): The number of steps taken by the agent.
 */
export type LettaUsageStatistics = {
  /**
   * The number of tokens generated by the agent.
   */
  completion_tokens?: number;
  /**
   * The number of tokens in the prompt.
   */
  prompt_tokens?: number;
  /**
   * The total number of tokens processed by the agent.
   */
  total_tokens?: number;
  /**
   * The number of steps taken by the agent.
   */
  step_count?: number;
};

export type ListMessagesResponse = {
  /**
   * List of message objects.
   */
  messages: Array<OpenAIMessage>;
};

export type LogProbToken = {
  token: string;
  logprob: number;
  bytes: Array<number> | null;
};

/**
 * Represents the in-context memory of the agent. This includes both the `Block` objects (labelled by sections), as well as tools to edit the blocks.
 *
 * Attributes:
 * memory (Dict[str, Block]): Mapping from memory block section to memory block.
 */
export type Memory = {
  /**
   * Mapping from memory block section to memory block.
   */
  memory?: {
    [key: string]: Block;
  };
  /**
   * Jinja2 template for compiling memory blocks into a prompt string
   */
  prompt_template?: string;
};

export type MessageContentLogProb = {
  token: string;
  logprob: number;
  bytes: Array<number> | null;
  top_logprobs: Array<LogProbToken> | null;
};

/**
 * Request to create a message
 */
export type MessageCreate = {
  /**
   * The role of the participant.
   */
  role: MessageRole;
  /**
   * The text of the message.
   */
  text: string;
  /**
   * The name of the participant.
   */
  name?: string | null;
};

export type MessageFile = {
  /**
   * The unique identifier of the file.
   */
  id: string;
  object?: string;
  /**
   * The unix timestamp of when the file was created.
   */
  created_at: number;
  /**
   * The unique identifier of the message.
   */
  message_id: string;
};

export type MessageRole = 'assistant' | 'user' | 'tool' | 'function' | 'system';

export type ModifyMessageRequest = {
  /**
   * Metadata associated with the message.
   */
  metadata?: {
    [key: string]: unknown;
  };
};

export type ModifyRunRequest = {
  /**
   * Metadata associated with the run.
   */
  metadata?: {
    [key: string]: unknown;
  };
};

export type ModifyThreadRequest = {
  /**
   * Metadata associated with the thread.
   */
  metadata?: {
    [key: string]: unknown;
  };
};

/**
 * Represents an OpenAI assistant (equivalent to Letta preset)
 */
export type OpenAIAssistant = {
  /**
   * The unique identifier of the assistant.
   */
  id: string;
  /**
   * The name of the assistant.
   */
  name: string;
  object?: string;
  /**
   * The description of the assistant.
   */
  description?: string | null;
  /**
   * The unix timestamp of when the assistant was created.
   */
  created_at: number;
  /**
   * The model used by the assistant.
   */
  model: string;
  /**
   * The instructions for the assistant.
   */
  instructions: string;
  /**
   * The tools used by the assistant.
   */
  tools?: Array<string> | null;
  /**
   * List of file IDs associated with the assistant.
   */
  file_ids?: Array<string> | null;
  /**
   * Metadata associated with the assistant.
   */
  metadata?: {
    [key: string]: unknown;
  } | null;
};

export type OpenAIError = {
  /**
   * The error code.
   */
  code: string;
  /**
   * The error message.
   */
  message: string;
};

export type OpenAIMessage = {
  /**
   * The unique identifier of the message.
   */
  id: string;
  object?: string;
  /**
   * The unix timestamp of when the message was created.
   */
  created_at: number;
  /**
   * The unique identifier of the thread.
   */
  thread_id: string;
  /**
   * Role of the message sender (either 'user' or 'system')
   */
  role: string;
  /**
   * The message content to be processed by the agent.
   */
  content?: Array<Text | ImageFile>;
  /**
   * The unique identifier of the assistant.
   */
  assistant_id: string;
  /**
   * The unique identifier of the run.
   */
  run_id?: string | null;
  /**
   * List of file IDs associated with the message.
   */
  file_ids?: Array<string> | null;
  /**
   * Metadata associated with the message.
   */
  metadata?: {
    [key: string]: unknown;
  } | null;
};

export type OpenAIMessageCreationStep = {
  type?: string;
  /**
   * The unique identifier of the message.
   */
  message_id: string;
};

export type OpenAIRun = {
  /**
   * The unique identifier of the run.
   */
  id: string;
  object?: string;
  /**
   * The unix timestamp of when the run was created.
   */
  created_at: number;
  /**
   * The unique identifier of the thread.
   */
  thread_id: string;
  /**
   * The unique identifier of the assistant.
   */
  assistant_id: string;
  /**
   * The status of the run.
   */
  status: string;
  /**
   * The required action of the run.
   */
  required_action?: RequiredAction | null;
  /**
   * The last error of the run.
   */
  last_error?: OpenAIError | null;
  /**
   * The unix timestamp of when the run expires.
   */
  expires_at: number;
  /**
   * The unix timestamp of when the run started.
   */
  started_at?: number | null;
  /**
   * The unix timestamp of when the run was cancelled.
   */
  cancelled_at?: number | null;
  /**
   * The unix timestamp of when the run failed.
   */
  failed_at?: number | null;
  /**
   * The unix timestamp of when the run completed.
   */
  completed_at?: number | null;
  /**
   * The model used by the run.
   */
  model: string;
  /**
   * The instructions for the run.
   */
  instructions: string;
  /**
   * The tools used by the run.
   */
  tools?: Array<letta__schemas__openai__openai__ToolCall> | null;
  /**
   * List of file IDs associated with the run.
   */
  file_ids?: Array<string> | null;
  /**
   * Metadata associated with the run.
   */
  metadata?: {
    [key: string]: unknown;
  } | null;
  /**
   * The usage of the run.
   */
  usage?: OpenAIUsage | null;
};

export type OpenAIRunStep = {
  /**
   * The unique identifier of the run step.
   */
  id: string;
  object?: string;
  /**
   * The unix timestamp of when the run step was created.
   */
  created_at: number;
  /**
   * The unique identifier of the assistant.
   */
  assistant_id: string;
  /**
   * The unique identifier of the thread.
   */
  thread_id: string;
  /**
   * The unique identifier of the run.
   */
  run_id: string;
  /**
   * The type of the run step.
   */
  type: string;
  /**
   * The status of the run step.
   */
  status: string;
  /**
   * The step defaults.
   */
  step_defaults: OpenAIToolCallsStep | OpenAIMessageCreationStep;
  /**
   * The last error of the run step.
   */
  last_error?: OpenAIError | null;
  /**
   * The unix timestamp of when the run step expired.
   */
  expired_at?: number | null;
  /**
   * The unix timestamp of when the run failed.
   */
  failed_at?: number | null;
  /**
   * The unix timestamp of when the run completed.
   */
  completed_at?: number | null;
  /**
   * The usage of the run.
   */
  usage?: OpenAIUsage | null;
};

/**
 * Represents an OpenAI thread (equivalent to Letta agent)
 */
export type OpenAIThread = {
  /**
   * The unique identifier of the thread.
   */
  id: string;
  object?: string;
  /**
   * The unix timestamp of when the thread was created.
   */
  created_at: number;
  /**
   * Metadata associated with the thread.
   */
  metadata?: {
    [key: string]: unknown;
  };
};

export type OpenAIToolCallsStep = {
  type?: string;
  /**
   * The tool calls.
   */
  tool_calls: Array<letta__schemas__openai__openai__ToolCall>;
};

export type OpenAIUsage = {
  /**
   * The number of tokens used for the run.
   */
  completion_tokens: number;
  /**
   * The number of tokens used for the prompt.
   */
  prompt_tokens: number;
  /**
   * The total number of tokens used for the run.
   */
  total_tokens: number;
};

export type Organization = {
  /**
   * The human-friendly ID of the Org
   */
  id?: string;
  /**
   * The name of the organization.
   */
  name: string;
  /**
   * The creation date of the user.
   */
  created_at?: string;
};

export type OrganizationCreate = {
  /**
   * The name of the organization.
   */
  name?: string | null;
};

/**
 * Representation of a passage, which is stored in archival memory.
 *
 * Parameters:
 * text (str): The text of the passage.
 * embedding (List[float]): The embedding of the passage.
 * embedding_config (EmbeddingConfig): The embedding configuration used by the passage.
 * created_at (datetime): The creation date of the passage.
 * user_id (str): The unique identifier of the user associated with the passage.
 * agent_id (str): The unique identifier of the agent associated with the passage.
 * source_id (str): The data source of the passage.
 * doc_id (str): The unique identifier of the document associated with the passage.
 */
export type Passage = {
  /**
   * The unique identifier of the user associated with the passage.
   */
  user_id?: string | null;
  /**
   * The unique identifier of the agent associated with the passage.
   */
  agent_id?: string | null;
  /**
   * The data source of the passage.
   */
  source_id?: string | null;
  /**
   * The unique identifier of the document associated with the passage.
   */
  doc_id?: string | null;
  /**
   * The metadata of the passage.
   */
  metadata_?: {
    [key: string]: unknown;
  } | null;
  /**
   * The human-friendly ID of the Passage
   */
  id?: string;
  /**
   * The text of the passage.
   */
  text: string;
  /**
   * The embedding of the passage.
   */
  embedding: Array<number> | null;
  /**
   * The embedding configuration used by the passage.
   */
  embedding_config: EmbeddingConfig | null;
  /**
   * The creation date of the passage.
   */
  created_at?: string;
};

export type RecallMemorySummary = {
  /**
   * Number of rows in recall memory
   */
  size: number;
};

export type RequiredAction = {
  type?: string;
  submit_tool_outputs: Array<letta__schemas__openai__openai__ToolCall>;
};

export type ResponseFormat = {
  type?: string;
};

/**
 * Representation of a source, which is a collection of documents and passages.
 *
 * Parameters:
 * id (str): The ID of the source
 * name (str): The name of the source.
 * embedding_config (EmbeddingConfig): The embedding configuration used by the source.
 * created_at (datetime): The creation date of the source.
 * user_id (str): The ID of the user that created the source.
 * metadata_ (dict): Metadata associated with the source.
 * description (str): The description of the source.
 */
export type Source = {
  /**
   * The description of the source.
   */
  description?: string | null;
  /**
   * The embedding configuration used by the source.
   */
  embedding_config: EmbeddingConfig;
  /**
   * Metadata associated with the source.
   */
  metadata_?: {
    [key: string]: unknown;
  } | null;
  /**
   * The human-friendly ID of the Source
   */
  id?: string;
  /**
   * The name of the source.
   */
  name: string;
  /**
   * The creation date of the source.
   */
  created_at?: string;
  /**
   * The ID of the user that created the source.
   */
  user_id: string;
};

export type SourceCreate = {
  /**
   * The description of the source.
   */
  description?: string | null;
  /**
   * The embedding configuration used by the passage.
   */
  embedding_config?: EmbeddingConfig | null;
  /**
   * Metadata associated with the source.
   */
  metadata_?: {
    [key: string]: unknown;
  } | null;
  /**
   * The name of the source.
   */
  name: string;
};

export type SourceUpdate = {
  /**
   * The description of the source.
   */
  description?: string | null;
  /**
   * The embedding configuration used by the passage.
   */
  embedding_config?: EmbeddingConfig | null;
  /**
   * Metadata associated with the source.
   */
  metadata_?: {
    [key: string]: unknown;
  } | null;
  /**
   * The ID of the source.
   */
  id: string;
  /**
   * The name of the source.
   */
  name?: string | null;
};

export type SubmitToolOutputsToRunRequest = {
  /**
   * The tool outputs to submit.
   */
  tools_outputs: Array<ToolCallOutput>;
};

export type SystemMessage_Input = {
  content: string;
  role?: string;
  name?: string | null;
};

/**
 * A message generated by the system. Never streamed back on a response, only used for cursor pagination.
 *
 * Attributes:
 * message (str): The message sent by the system
 * id (str): The ID of the message
 * date (datetime): The date the message was created in ISO format
 */
export type SystemMessage_Output = {
  id: string;
  date: string;
  message_type?: 'system_message';
  message: string;
};

export type message_type5 = 'system_message';

export type Text = {
  object?: string;
  /**
   * The text content to be processed by the agent.
   */
  text: string;
};

export type Tool_Input = {
  type?: 'function';
  function: FunctionSchema;
};

export type type = 'function';

/**
 * Representation of a tool, which is a function that can be called by the agent.
 *
 * Parameters:
 * id (str): The unique identifier of the tool.
 * name (str): The name of the function.
 * tags (List[str]): Metadata tags.
 * source_code (str): The source code of the function.
 * json_schema (Dict): The JSON schema of the function.
 */
export type Tool_Output = {
  /**
   * The description of the tool.
   */
  description?: string | null;
  /**
   * The type of the source code.
   */
  source_type?: string | null;
  /**
   * The module of the function.
   */
  module?: string | null;
  /**
   * The unique identifier of the user associated with the function.
   */
  user_id?: string | null;
  /**
   * The human-friendly ID of the Tool
   */
  id?: string;
  /**
   * The name of the function.
   */
  name: string;
  /**
   * Metadata tags.
   */
  tags: Array<string>;
  /**
   * The source code of the function.
   */
  source_code: string;
  /**
   * The JSON schema of the function.
   */
  json_schema?: {
    [key: string]: unknown;
  };
};

export type ToolCallFunction_Output = {
  /**
   * The name of the function to call
   */
  name: string;
  /**
   * The arguments to pass to the function (JSON dump)
   */
  arguments: string;
};

export type ToolCallOutput = {
  /**
   * The unique identifier of the tool call.
   */
  tool_call_id: string;
  /**
   * The output of the tool call.
   */
  output: string;
};

export type ToolCreate = {
  /**
   * The description of the tool.
   */
  description?: string | null;
  /**
   * The type of the source code.
   */
  source_type?: string | null;
  /**
   * The module of the function.
   */
  module?: string | null;
  /**
   * The unique identifier of the user associated with the function.
   */
  user_id?: string | null;
  /**
   * The name of the function (auto-generated from source_code if not provided).
   */
  name?: string | null;
  /**
   * Metadata tags.
   */
  tags: Array<string>;
  /**
   * The source code of the function.
   */
  source_code: string;
  /**
   * The JSON schema of the function (auto-generated from source_code if not provided)
   */
  json_schema?: {
    [key: string]: unknown;
  } | null;
};

export type ToolFunctionChoice = {
  type?: 'function';
  function: FunctionCall_Input;
};

export type ToolMessage = {
  content: string;
  role?: string;
  tool_call_id: string;
};

export type ToolUpdate = {
  /**
   * The description of the tool.
   */
  description?: string | null;
  /**
   * The type of the source code.
   */
  source_type?: string | null;
  /**
   * The module of the function.
   */
  module?: string | null;
  /**
   * The unique identifier of the user associated with the function.
   */
  user_id?: string | null;
  /**
   * The name of the function.
   */
  name?: string | null;
  /**
   * Metadata tags.
   */
  tags?: Array<string> | null;
  /**
   * The source code of the function.
   */
  source_code?: string | null;
  /**
   * The JSON schema of the function.
   */
  json_schema?: {
    [key: string]: unknown;
  } | null;
  /**
   * The unique identifier of the tool.
   */
  id: string;
};

export type UpdateAgentState = {
  /**
   * The description of the agent.
   */
  description?: string | null;
  /**
   * The metadata of the agent.
   */
  metadata_?: {
    [key: string]: unknown;
  } | null;
  /**
   * The user id of the agent.
   */
  user_id?: string | null;
  /**
   * The id of the agent.
   */
  id: string;
  /**
   * The name of the agent.
   */
  name?: string | null;
  /**
   * The tools used by the agent.
   */
  tools?: Array<string> | null;
  /**
   * The system prompt used by the agent.
   */
  system?: string | null;
  /**
   * The LLM configuration used by the agent.
   */
  llm_config?: LLMConfig | null;
  /**
   * The embedding configuration used by the agent.
   */
  embedding_config?: EmbeddingConfig | null;
  /**
   * The ids of the messages in the agent's in-context memory.
   */
  message_ids?: Array<string> | null;
  /**
   * The in-context memory of the agent.
   */
  memory?: Memory | null;
};

/**
 * Update a block
 */
export type UpdateBlock = {
  /**
   * Value of the block.
   */
  value?: string | null;
  /**
   * Character limit of the block.
   */
  limit?: number | null;
  /**
   * Name of the block.
   */
  name?: string | null;
  /**
   * Whether the block is a template (e.g. saved human/persona options).
   */
  template?: boolean;
  /**
   * Label of the block (e.g. 'human', 'persona').
   */
  label?: string | null;
  /**
   * Description of the block.
   */
  description?: string | null;
  /**
   * Metadata of the block.
   */
  metadata_?: {
    [key: string]: unknown;
  } | null;
  /**
   * The unique identifier of the user associated with the block.
   */
  user_id?: string | null;
  /**
   * The unique identifier of the block.
   */
  id: string;
};

/**
 * Request to update a message
 */
export type UpdateMessage = {
  /**
   * The id of the message.
   */
  id: string;
  /**
   * The role of the participant.
   */
  role?: MessageRole | null;
  /**
   * The text of the message.
   */
  text?: string | null;
  /**
   * The name of the participant.
   */
  name?: string | null;
  /**
   * The list of tool calls requested.
   */
  tool_calls?: Array<letta__schemas__openai__chat_completions__ToolCall_Input> | null;
  /**
   * The id of the tool call.
   */
  tool_call_id?: string | null;
};

export type UsageStatistics = {
  completion_tokens?: number;
  prompt_tokens?: number;
  total_tokens?: number;
};

/**
 * Representation of a user.
 *
 * Parameters:
 * id (str): The unique identifier of the user.
 * name (str): The name of the user.
 * created_at (datetime): The creation date of the user.
 */
export type User = {
  /**
   * The human-friendly ID of the User
   */
  id?: string;
  /**
   * The organization id of the user
   */
  org_id: string | null;
  /**
   * The name of the user.
   */
  name: string;
  /**
   * The creation date of the user.
   */
  created_at?: string;
};

export type UserCreate = {
  /**
   * The name of the user.
   */
  name?: string | null;
  /**
   * The organization id of the user.
   */
  org_id?: string | null;
};

export type UserMessage_Input = {
  content: string | Array<string>;
  role?: string;
  name?: string | null;
};

/**
 * A message sent by the user. Never streamed back on a response, only used for cursor pagination.
 *
 * Attributes:
 * message (str): The message sent by the user
 * id (str): The ID of the message
 * date (datetime): The date the message was created in ISO format
 */
export type UserMessage_Output = {
  id: string;
  date: string;
  message_type?: 'user_message';
  message: string;
};

export type message_type6 = 'user_message';

export type ValidationError = {
  loc: Array<string | number>;
  msg: string;
  type: string;
};

export type letta__schemas__letta_message__FunctionCall = {
  name: string;
  arguments: string;
};

/**
 * Letta's internal representation of a message. Includes methods to convert to/from LLM provider formats.
 *
 * Attributes:
 * id (str): The unique identifier of the message.
 * role (MessageRole): The role of the participant.
 * text (str): The text of the message.
 * user_id (str): The unique identifier of the user.
 * agent_id (str): The unique identifier of the agent.
 * model (str): The model used to make the function call.
 * name (str): The name of the participant.
 * created_at (datetime): The time the message was created.
 * tool_calls (List[ToolCall]): The list of tool calls requested.
 * tool_call_id (str): The id of the tool call.
 */
export type letta__schemas__message__Message = {
  /**
   * The human-friendly ID of the Message
   */
  id?: string;
  /**
   * The role of the participant.
   */
  role: MessageRole;
  /**
   * The text of the message.
   */
  text?: string | null;
  /**
   * The unique identifier of the user.
   */
  user_id?: string | null;
  /**
   * The unique identifier of the agent.
   */
  agent_id?: string | null;
  /**
   * The model used to make the function call.
   */
  model?: string | null;
  /**
   * The name of the participant.
   */
  name?: string | null;
  /**
   * The time the message was created.
   */
  created_at?: string;
  /**
   * The list of tool calls requested.
   */
  tool_calls?: Array<letta__schemas__openai__chat_completions__ToolCall_Output> | null;
  /**
   * The id of the tool call.
   */
  tool_call_id?: string | null;
};

export type letta__schemas__openai__chat_completion_request__ToolCall = {
  id: string;
  type?: 'function';
  function: letta__schemas__openai__chat_completion_request__ToolCallFunction;
};

export type letta__schemas__openai__chat_completion_request__ToolCallFunction =
  {
    name: string;
    arguments: string;
  };

export type letta__schemas__openai__chat_completion_response__FunctionCall = {
  arguments: string;
  name: string;
};

export type letta__schemas__openai__chat_completion_response__Message = {
  content?: string | null;
  tool_calls?: Array<letta__schemas__openai__chat_completion_response__ToolCall> | null;
  role: string;
  function_call?: letta__schemas__openai__chat_completion_response__FunctionCall | null;
};

export type letta__schemas__openai__chat_completion_response__ToolCall = {
  id: string;
  type?: 'function';
  function: letta__schemas__openai__chat_completion_response__FunctionCall;
};

export type letta__schemas__openai__chat_completions__ToolCall_Input = {
  /**
   * The ID of the tool call
   */
  id: string;
  type?: string;
  /**
   * The arguments and name for the function
   */
  function: letta__schemas__openai__chat_completions__ToolCallFunction;
};

export type letta__schemas__openai__chat_completions__ToolCall_Output = {
  /**
   * The ID of the tool call
   */
  id: string;
  type?: string;
  /**
   * The arguments and name for the function
   */
  function: ToolCallFunction_Output;
};

export type letta__schemas__openai__chat_completions__ToolCallFunction = {
  /**
   * The name of the function to call
   */
  name: string;
  /**
   * The arguments to pass to the function (JSON dump)
   */
  arguments: string;
};

export type letta__schemas__openai__openai__ToolCall = {
  /**
   * The unique identifier of the tool call.
   */
  id: string;
  type?: string;
  /**
   * The function call.
   */
  function: Function;
};

export type DeleteToolData = {
  toolId: string;
};

export type DeleteToolResponse = unknown;

export type GetToolData = {
  toolId: string;
};

export type GetToolResponse = Tool_Output;

export type UpdateToolData = {
  requestBody: ToolUpdate;
  toolId: string;
};

export type UpdateToolResponse = Tool_Output;

export type GetToolIdByNameData = {
  toolName: string;
};

export type GetToolIdByNameResponse = string;

export type ListToolsResponse = Array<Tool_Output>;

export type CreateToolData = {
  requestBody: ToolCreate;
  update?: boolean;
};

export type CreateToolResponse = Tool_Output;

export type GetSourceData = {
  sourceId: string;
};

export type GetSourceResponse = Source;

export type UpdateSourceData = {
  requestBody: SourceUpdate;
  sourceId: string;
};

export type UpdateSourceResponse = Source;

export type DeleteSourceData = {
  sourceId: string;
};

export type DeleteSourceResponse = unknown;

export type GetSourceIdByNameData = {
  sourceName: string;
};

export type GetSourceIdByNameResponse = string;

export type ListSourcesResponse = Array<Source>;

export type CreateSourceData = {
  requestBody: SourceCreate;
};

export type CreateSourceResponse = Source;

export type AttachAgentToSourceData = {
  /**
   * The unique identifier of the agent to attach the source to.
   */
  agentId: string;
  sourceId: string;
};

export type AttachAgentToSourceResponse = Source;

export type DetachAgentFromSourceData = {
  /**
   * The unique identifier of the agent to detach the source from.
   */
  agentId: string;
  sourceId: string;
};

export type DetachAgentFromSourceResponse = Source;

export type UploadFileToSourceData = {
  formData: Body_upload_file_to_source;
  sourceId: string;
};

export type UploadFileToSourceResponse = Job;

export type ListSourcePassagesData = {
  sourceId: string;
};

export type ListSourcePassagesResponse = Array<Passage>;

export type ListSourceDocumentsData = {
  sourceId: string;
};

export type ListSourceDocumentsResponse = Array<Document>;

export type ListAgentsResponse = Array<AgentState>;

export type CreateAgentData = {
  requestBody: CreateAgent;
};

export type CreateAgentResponse = AgentState;

export type UpdateAgentData = {
  agentId: string;
  requestBody: UpdateAgentState;
};

export type UpdateAgentResponse = AgentState;

export type GetAgentData = {
  agentId: string;
};

export type GetAgentResponse = AgentState;

export type DeleteAgentData = {
  agentId: string;
};

export type DeleteAgentResponse = unknown;

export type GetAgentSourcesData = {
  agentId: string;
};

export type GetAgentSourcesResponse = Array<Source>;

export type ListAgentInContextMessagesData = {
  agentId: string;
};

export type ListAgentInContextMessagesResponse =
  Array<letta__schemas__message__Message>;

export type GetAgentMemoryData = {
  agentId: string;
};

export type GetAgentMemoryResponse = Memory;

export type UpdateAgentMemoryData = {
  agentId: string;
  requestBody: {
    [key: string]: unknown;
  };
};

export type UpdateAgentMemoryResponse = Memory;

export type GetAgentRecallMemorySummaryData = {
  agentId: string;
};

export type GetAgentRecallMemorySummaryResponse = RecallMemorySummary;

export type GetAgentArchivalMemorySummaryData = {
  agentId: string;
};

export type GetAgentArchivalMemorySummaryResponse = ArchivalMemorySummary;

export type ListAgentArchivalMemoryData = {
  /**
   * Unique ID of the memory to start the query range at.
   */
  after?: number | null;
  agentId: string;
  /**
   * Unique ID of the memory to end the query range at.
   */
  before?: number | null;
  /**
   * How many results to include in the response.
   */
  limit?: number | null;
};

export type ListAgentArchivalMemoryResponse = Array<Passage>;

export type CreateAgentArchivalMemoryData = {
  agentId: string;
  requestBody: CreateArchivalMemory;
};

export type CreateAgentArchivalMemoryResponse = Array<Passage>;

export type DeleteAgentArchivalMemoryData = {
  agentId: string;
  memoryId: string;
};

export type DeleteAgentArchivalMemoryResponse = unknown;

export type ListAgentMessagesData = {
  agentId: string;
  /**
   * Message before which to retrieve the returned messages.
   */
  before?: string | null;
  /**
   * Maximum number of messages to retrieve.
   */
  limit?: number;
  /**
   * If true, returns Message objects. If false, return LettaMessage objects.
   */
  msgObject?: boolean;
};

export type ListAgentMessagesResponse =
  | Array<letta__schemas__message__Message>
  | Array<
      | SystemMessage_Output
      | UserMessage_Output
      | InternalMonologue
      | FunctionCallMessage
      | FunctionReturn
      | AssistantMessage_Output
    >;

export type CreateAgentMessageData = {
  agentId: string;
  requestBody: LettaRequest;
};

export type CreateAgentMessageResponse = LettaResponse;

export type UpdateAgentMessageData = {
  agentId: string;
  messageId: string;
  requestBody: UpdateMessage;
};

export type UpdateAgentMessageResponse = letta__schemas__message__Message;

export type ListModelsResponse = Array<LLMConfig>;

export type ListEmbeddingModelsResponse = Array<EmbeddingConfig>;

export type ListMemoryBlocksData = {
  /**
   * Labels to include (e.g. human, persona)
   */
  label?: string | null;
  /**
   * Name of the block
   */
  name?: string | null;
  /**
   * Whether to include only templates
   */
  templatesOnly?: boolean;
};

export type ListMemoryBlocksResponse = Array<Block>;

export type CreateMemoryBlockData = {
  requestBody: CreateBlock;
};

export type CreateMemoryBlockResponse = Block;

export type UpdateMemoryBlockData = {
  blockId: string;
  requestBody: UpdateBlock;
};

export type UpdateMemoryBlockResponse = Block;

export type DeleteMemoryBlockData = {
  blockId: string;
};

export type DeleteMemoryBlockResponse = Block;

export type GetMemoryBlockData = {
  blockId: string;
};

export type GetMemoryBlockResponse = Block;

export type ListJobsData = {
  /**
   * Only list jobs associated with the source.
   */
  sourceId?: string | null;
};

export type ListJobsResponse = Array<Job>;

export type ListActiveJobsResponse = Array<Job>;

export type GetJobData = {
  jobId: string;
};

export type GetJobResponse = Job;

export type ListUsersData = {
  cursor?: string | null;
  limit?: number | null;
};

export type ListUsersResponse = Array<User>;

export type CreateUserData = {
  requestBody: UserCreate;
};

export type CreateUserResponse = User;

export type DeleteUserData = {
  /**
   * The user_id key to be deleted.
   */
  userId: string;
};

export type DeleteUserResponse = User;

export type CreateApiKeyData = {
  requestBody: APIKeyCreate;
};

export type CreateApiKeyResponse = APIKey;

export type ListApiKeysData = {
  /**
   * The unique identifier of the user.
   */
  userId: string;
};

export type ListApiKeysResponse = Array<APIKey>;

export type DeleteApiKeyData = {
  /**
   * The API key to be deleted.
   */
  apiKey: string;
};

export type DeleteApiKeyResponse = APIKey;

export type ListOrgsData = {
  cursor?: string | null;
  limit?: number | null;
};

export type ListOrgsResponse = Array<Organization>;

export type CreateOrganizationData = {
  requestBody: OrganizationCreate;
};

export type CreateOrganizationResponse = Organization;

export type DeleteOrganizationData = {
  /**
   * The org_id key to be deleted.
   */
  orgId: string;
};

export type DeleteOrganizationResponse = Organization;

export type AuthenticateUserV1AuthPostData = {
  requestBody: AuthRequest;
};

export type AuthenticateUserV1AuthPostResponse = AuthResponse;

export type $OpenApiTs = {
  '/v1/tools/{tool_id}': {
    delete: {
      req: DeleteToolData;
      res: {
        /**
         * Successful Response
         */
        200: unknown;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
    get: {
      req: GetToolData;
      res: {
        /**
         * Successful Response
         */
        200: Tool_Output;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
    patch: {
      req: UpdateToolData;
      res: {
        /**
         * Successful Response
         */
        200: Tool_Output;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/tools/name/{tool_name}': {
    get: {
      req: GetToolIdByNameData;
      res: {
        /**
         * Successful Response
         */
        200: string;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/tools/': {
    get: {
      res: {
        /**
         * Successful Response
         */
        200: Array<Tool_Output>;
      };
    };
    post: {
      req: CreateToolData;
      res: {
        /**
         * Successful Response
         */
        200: Tool_Output;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/sources/{source_id}': {
    get: {
      req: GetSourceData;
      res: {
        /**
         * Successful Response
         */
        200: Source;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
    patch: {
      req: UpdateSourceData;
      res: {
        /**
         * Successful Response
         */
        200: Source;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
    delete: {
      req: DeleteSourceData;
      res: {
        /**
         * Successful Response
         */
        200: unknown;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/sources/name/{source_name}': {
    get: {
      req: GetSourceIdByNameData;
      res: {
        /**
         * Successful Response
         */
        200: string;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/sources/': {
    get: {
      res: {
        /**
         * Successful Response
         */
        200: Array<Source>;
      };
    };
    post: {
      req: CreateSourceData;
      res: {
        /**
         * Successful Response
         */
        200: Source;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/sources/{source_id}/attach': {
    post: {
      req: AttachAgentToSourceData;
      res: {
        /**
         * Successful Response
         */
        200: Source;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/sources/{source_id}/detach': {
    post: {
      req: DetachAgentFromSourceData;
      res: {
        /**
         * Successful Response
         */
        200: Source;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/sources/{source_id}/upload': {
    post: {
      req: UploadFileToSourceData;
      res: {
        /**
         * Successful Response
         */
        200: Job;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/sources/{source_id}/passages': {
    get: {
      req: ListSourcePassagesData;
      res: {
        /**
         * Successful Response
         */
        200: Array<Passage>;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/sources/{source_id}/documents': {
    get: {
      req: ListSourceDocumentsData;
      res: {
        /**
         * Successful Response
         */
        200: Array<Document>;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/agents/': {
    get: {
      res: {
        /**
         * Successful Response
         */
        200: Array<AgentState>;
      };
    };
    post: {
      req: CreateAgentData;
      res: {
        /**
         * Successful Response
         */
        200: AgentState;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/agents/{agent_id}': {
    patch: {
      req: UpdateAgentData;
      res: {
        /**
         * Successful Response
         */
        200: AgentState;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
    get: {
      req: GetAgentData;
      res: {
        /**
         * Successful Response
         */
        200: AgentState;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
    delete: {
      req: DeleteAgentData;
      res: {
        /**
         * Successful Response
         */
        200: unknown;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/agents/{agent_id}/sources': {
    get: {
      req: GetAgentSourcesData;
      res: {
        /**
         * Successful Response
         */
        200: Array<Source>;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/agents/{agent_id}/memory/messages': {
    get: {
      req: ListAgentInContextMessagesData;
      res: {
        /**
         * Successful Response
         */
        200: Array<letta__schemas__message__Message>;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/agents/{agent_id}/memory': {
    get: {
      req: GetAgentMemoryData;
      res: {
        /**
         * Successful Response
         */
        200: Memory;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
    patch: {
      req: UpdateAgentMemoryData;
      res: {
        /**
         * Successful Response
         */
        200: Memory;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/agents/{agent_id}/memory/recall': {
    get: {
      req: GetAgentRecallMemorySummaryData;
      res: {
        /**
         * Successful Response
         */
        200: RecallMemorySummary;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/agents/{agent_id}/memory/archival': {
    get: {
      req: GetAgentArchivalMemorySummaryData;
      res: {
        /**
         * Successful Response
         */
        200: ArchivalMemorySummary;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/agents/{agent_id}/archival': {
    get: {
      req: ListAgentArchivalMemoryData;
      res: {
        /**
         * Successful Response
         */
        200: Array<Passage>;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
    post: {
      req: CreateAgentArchivalMemoryData;
      res: {
        /**
         * Successful Response
         */
        200: Array<Passage>;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/agents/{agent_id}/archival/{memory_id}': {
    delete: {
      req: DeleteAgentArchivalMemoryData;
      res: {
        /**
         * Successful Response
         */
        200: unknown;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/agents/{agent_id}/messages': {
    get: {
      req: ListAgentMessagesData;
      res: {
        /**
         * Successful Response
         */
        200:
          | Array<letta__schemas__message__Message>
          | Array<
              | SystemMessage_Output
              | UserMessage_Output
              | InternalMonologue
              | FunctionCallMessage
              | FunctionReturn
              | AssistantMessage_Output
            >;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
    post: {
      req: CreateAgentMessageData;
      res: {
        /**
         * Successful Response
         */
        200: LettaResponse;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/agents/{agent_id}/messages/{message_id}': {
    patch: {
      req: UpdateAgentMessageData;
      res: {
        /**
         * Successful Response
         */
        200: letta__schemas__message__Message;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/models/': {
    get: {
      res: {
        /**
         * Successful Response
         */
        200: Array<LLMConfig>;
      };
    };
  };
  '/v1/models/embedding': {
    get: {
      res: {
        /**
         * Successful Response
         */
        200: Array<EmbeddingConfig>;
      };
    };
  };
  '/v1/blocks/': {
    get: {
      req: ListMemoryBlocksData;
      res: {
        /**
         * Successful Response
         */
        200: Array<Block>;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
    post: {
      req: CreateMemoryBlockData;
      res: {
        /**
         * Successful Response
         */
        200: Block;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/blocks/{block_id}': {
    patch: {
      req: UpdateMemoryBlockData;
      res: {
        /**
         * Successful Response
         */
        200: Block;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
    delete: {
      req: DeleteMemoryBlockData;
      res: {
        /**
         * Successful Response
         */
        200: Block;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
    get: {
      req: GetMemoryBlockData;
      res: {
        /**
         * Successful Response
         */
        200: Block;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/jobs/': {
    get: {
      req: ListJobsData;
      res: {
        /**
         * Successful Response
         */
        200: Array<Job>;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/jobs/active': {
    get: {
      res: {
        /**
         * Successful Response
         */
        200: Array<Job>;
      };
    };
  };
  '/v1/jobs/{job_id}': {
    get: {
      req: GetJobData;
      res: {
        /**
         * Successful Response
         */
        200: Job;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/admin/users/': {
    get: {
      req: ListUsersData;
      res: {
        /**
         * Successful Response
         */
        200: Array<User>;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
    post: {
      req: CreateUserData;
      res: {
        /**
         * Successful Response
         */
        200: User;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
    delete: {
      req: DeleteUserData;
      res: {
        /**
         * Successful Response
         */
        200: User;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/admin/users/keys': {
    post: {
      req: CreateApiKeyData;
      res: {
        /**
         * Successful Response
         */
        200: APIKey;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
    get: {
      req: ListApiKeysData;
      res: {
        /**
         * Successful Response
         */
        200: Array<APIKey>;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
    delete: {
      req: DeleteApiKeyData;
      res: {
        /**
         * Successful Response
         */
        200: APIKey;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/admin/orgs/': {
    get: {
      req: ListOrgsData;
      res: {
        /**
         * Successful Response
         */
        200: Array<Organization>;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
    post: {
      req: CreateOrganizationData;
      res: {
        /**
         * Successful Response
         */
        200: Organization;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
    delete: {
      req: DeleteOrganizationData;
      res: {
        /**
         * Successful Response
         */
        200: Organization;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/auth': {
    post: {
      req: AuthenticateUserV1AuthPostData;
      res: {
        /**
         * Successful Response
         */
        200: AuthResponse;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
};
