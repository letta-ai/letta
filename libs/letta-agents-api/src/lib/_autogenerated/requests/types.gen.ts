// This file is auto-generated by @hey-api/openapi-ts

export type APIKey = {
  /**
   * The human-friendly ID of the Sk
   */
  id?: string;
  /**
   * The unique identifier of the user associated with the token.
   */
  user_id: string;
  /**
   * The key value.
   */
  key: string;
  /**
   * Name of the token.
   */
  name: string;
};

export type APIKeyCreate = {
  /**
   * The unique identifier of the user associated with the token.
   */
  user_id: string;
  /**
   * Name of the token.
   */
  name?: string | null;
};

/**
 * Action data model.
 */
export type ActionModel = {
  name: string;
  display_name?: string | null;
  parameters: ActionParametersModel;
  response: ActionResponseModel;
  appName: string;
  appId: string;
  tags: Array<string>;
  enabled?: boolean;
  logo?: string | null;
  description?: string | null;
};

/**
 * Action parameter data models.
 */
export type ActionParametersModel = {
  properties: {
    [key: string]: unknown;
  };
  title: string;
  type: string;
  required?: Array<string> | null;
};

/**
 * Action response data model.
 */
export type ActionResponseModel = {
  properties: {
    [key: string]: unknown;
  };
  title: string;
  type: string;
  required?: Array<string> | null;
};

/**
 * Representation of an agent's state. This is the state of the agent at a given time, and is persisted in the DB backend. The state has all the information needed to recreate a persisted agent.
 *
 * Parameters:
 * id (str): The unique identifier of the agent.
 * name (str): The name of the agent (must be unique to the user).
 * created_at (datetime): The datetime the agent was created.
 * message_ids (List[str]): The ids of the messages in the agent's in-context memory.
 * memory (Memory): The in-context memory of the agent.
 * tools (List[str]): The tools used by the agent. This includes any memory editing functions specified in `memory`.
 * system (str): The system prompt used by the agent.
 * llm_config (LLMConfig): The LLM configuration used by the agent.
 * embedding_config (EmbeddingConfig): The embedding configuration used by the agent.
 */
export type AgentState = {
  /**
   * The description of the agent.
   */
  description?: string | null;
  /**
   * The metadata of the agent.
   */
  metadata_?: {
    [key: string]: unknown;
  } | null;
  /**
   * The user id of the agent.
   */
  user_id?: string | null;
  /**
   * The human-friendly ID of the Agent
   */
  id?: string;
  /**
   * The name of the agent.
   */
  name: string;
  /**
   * The datetime the agent was created.
   */
  created_at?: string;
  /**
   * The ids of the messages in the agent's in-context memory.
   */
  message_ids?: Array<string> | null;
  /**
   * The tools used by the agent.
   */
  tool_names: Array<string>;
  /**
   * The list of tool rules.
   */
  tool_rules?: Array<ChildToolRule | InitToolRule | TerminalToolRule> | null;
  /**
   * The system prompt used by the agent.
   */
  system: string;
  /**
   * The type of agent.
   */
  agent_type: AgentType;
  /**
   * The LLM configuration used by the agent.
   */
  llm_config: LLMConfig;
  /**
   * The embedding configuration used by the agent.
   */
  embedding_config: EmbeddingConfig;
  /**
   * The in-context memory of the agent.
   */
  memory: Memory;
  /**
   * The tools used by the agent.
   */
  tools: Array<letta__schemas__tool__Tool>;
  /**
   * The sources used by the agent.
   */
  sources: Array<Source>;
  /**
   * The tags associated with the agent.
   */
  tags: Array<string>;
};

/**
 * Enum to represent the type of agent.
 */
export type AgentType =
  | 'memgpt_agent'
  | 'split_thread_agent'
  | 'o1_agent'
  | 'offline_memory_agent'
  | 'chat_only_agent';

/**
 * App authenticatio scheme.
 */
export type AppAuthScheme = {
  scheme_name: string;
  auth_mode:
    | 'OAUTH2'
    | 'OAUTH1'
    | 'API_KEY'
    | 'BASIC'
    | 'BEARER_TOKEN'
    | 'BASIC_WITH_JWT';
  fields: Array<AuthSchemeField>;
  proxy?: {
    [key: string]: unknown;
  } | null;
  authorization_url?: string | null;
  token_url?: string | null;
  default_scopes?: Array<unknown> | null;
  token_response_metadata?: Array<unknown> | null;
  client_id?: string | null;
  client_secret?: string | null;
};

export type auth_mode =
  | 'OAUTH2'
  | 'OAUTH1'
  | 'API_KEY'
  | 'BASIC'
  | 'BEARER_TOKEN'
  | 'BASIC_WITH_JWT';

/**
 * App data model.
 */
export type AppModel = {
  name: string;
  key: string;
  appId: string;
  description: string;
  categories: Array<string>;
  meta: {
    [key: string]: unknown;
  };
  logo?: string | null;
  docs?: string | null;
  group?: string | null;
  status?: string | null;
  enabled?: boolean;
  no_auth?: boolean;
  auth_schemes?: Array<AppAuthScheme> | null;
  testConnectors?: Array<{
    [key: string]: unknown;
  }> | null;
  documentation_doc_text?: string | null;
  configuration_docs_text?: string | null;
};

export type ArchivalMemorySummary = {
  /**
   * Number of rows in archival memory
   */
  size: number;
};

export type AssistantFile = {
  /**
   * The unique identifier of the file.
   */
  id: string;
  object?: string;
  /**
   * The unix timestamp of when the file was created.
   */
  created_at: number;
  /**
   * The unique identifier of the assistant.
   */
  assistant_id: string;
};

export type AssistantMessage_Input = {
  content?: string | null;
  role?: string;
  name?: string | null;
  tool_calls?: Array<letta__schemas__openai__chat_completion_request__ToolCall> | null;
};

export type AssistantMessage_Output = {
  id: string;
  date: string;
  message_type?: 'assistant_message';
  assistant_message: string;
};

export type message_type = 'assistant_message';

export type AuthRequest = {
  /**
   * Admin password provided when starting the Letta server
   */
  password?: string;
};

export type AuthResponse = {
  /**
   * UUID of the user
   */
  uuid: string;
  /**
   * Whether the user is an admin
   */
  is_admin?: boolean | null;
};

/**
 * Auth scheme field.
 */
export type AuthSchemeField = {
  name: string;
  display_name?: string | null;
  description: string;
  type: string;
  default?: string | null;
  required?: boolean;
  expected_from_customer?: boolean;
  get_current_user_endpoint?: string | null;
};

/**
 * A Block represents a reserved section of the LLM's context window which is editable. `Block` objects contained in the `Memory` object, which is able to edit the Block values.
 *
 * Parameters:
 * label (str): The label of the block (e.g. 'human', 'persona'). This defines a category for the block.
 * value (str): The value of the block. This is the string that is represented in the context window.
 * limit (int): The character limit of the block.
 * is_template (bool): Whether the block is a template (e.g. saved human/persona options). Non-template blocks are not stored in the database and are ephemeral, while templated blocks are stored in the database.
 * label (str): The label of the block (e.g. 'human', 'persona'). This defines a category for the block.
 * template_name (str): The name of the block template (if it is a template).
 * description (str): Description of the block.
 * metadata_ (Dict): Metadata of the block.
 * user_id (str): The unique identifier of the user associated with the block.
 */
export type Block = {
  /**
   * Value of the block.
   */
  value: string;
  /**
   * Character limit of the block.
   */
  limit?: number;
  /**
   * Name of the block if it is a template.
   */
  name?: string | null;
  /**
   * Whether the block is a template (e.g. saved human/persona options).
   */
  is_template?: boolean;
  /**
   * Label of the block (e.g. 'human', 'persona') in the context window.
   */
  label?: string | null;
  /**
   * Description of the block.
   */
  description?: string | null;
  /**
   * Metadata of the block.
   */
  metadata_?: {
    [key: string]: unknown;
  } | null;
  /**
   * The human-friendly ID of the Block
   */
  id?: string;
  /**
   * The unique identifier of the organization associated with the block.
   */
  organization_id?: string | null;
  /**
   * The id of the user that made this Block.
   */
  created_by_id?: string | null;
  /**
   * The id of the user that last updated this Block.
   */
  last_updated_by_id?: string | null;
};

/**
 * Update a block
 */
export type BlockUpdate = {
  /**
   * Value of the block.
   */
  value?: string | null;
  /**
   * Character limit of the block.
   */
  limit?: number | null;
  /**
   * Name of the block if it is a template.
   */
  name?: string | null;
  /**
   * Whether the block is a template (e.g. saved human/persona options).
   */
  is_template?: boolean;
  /**
   * Label of the block (e.g. 'human', 'persona') in the context window.
   */
  label?: string | null;
  /**
   * Description of the block.
   */
  description?: string | null;
  /**
   * Metadata of the block.
   */
  metadata_?: {
    [key: string]: unknown;
  } | null;
};

export type Body_upload_file_to_source = {
  file: Blob | File;
};

/**
 * https://platform.openai.com/docs/api-reference/chat/create
 */
export type ChatCompletionRequest = {
  model: string;
  messages: Array<
    | SystemMessage_Input
    | UserMessage_Input
    | AssistantMessage_Input
    | ToolMessage
  >;
  frequency_penalty?: number | null;
  logit_bias?: {
    [key: string]: number;
  } | null;
  logprobs?: boolean | null;
  top_logprobs?: number | null;
  max_tokens?: number | null;
  n?: number | null;
  presence_penalty?: number | null;
  response_format?: ResponseFormat | null;
  seed?: number | null;
  stop?: string | Array<string> | null;
  stream?: boolean | null;
  temperature?: number | null;
  top_p?: number | null;
  user?: string | null;
  tools?: Array<Tool_Input> | null;
  tool_choice?: 'none' | 'auto' | 'required' | ToolFunctionChoice | null;
  functions?: Array<FunctionSchema> | null;
  function_call?: 'none' | 'auto' | FunctionCall_Input | null;
};

/**
 * https://platform.openai.com/docs/api-reference/chat/object
 */
export type ChatCompletionResponse = {
  id: string;
  choices: Array<Choice>;
  created: string;
  model?: string | null;
  system_fingerprint?: string | null;
  object?: 'chat.completion';
  usage: UsageStatistics;
};
/**
 * A ToolRule represents a tool that can be invoked by the agent.
 */
export type ChildToolRule = {
  /**
   * The name of the tool. Must exist in the database for the user's organization.
   */
  tool_name: string;
  type?: ToolRuleType;
  /**
   * The children tools that can be invoked.
   */
  children: Array<string>;
};

export type Choice = {
  finish_reason: string;
  index: number;
  message: letta__schemas__openai__chat_completion_response__Message;
  logprobs?: {
    [key: string]: Array<MessageContentLogProb> | null;
  } | null;
  seed?: number | null;
};

/**
 * Overview of the context window, including the number of messages and tokens.
 */
export type ContextWindowOverview = {
  /**
   * The maximum amount of tokens the context window can hold.
   */
  context_window_size_max: number;
  /**
   * The current number of tokens in the context window.
   */
  context_window_size_current: number;
  /**
   * The number of messages in the context window.
   */
  num_messages: number;
  /**
   * The number of messages in the archival memory.
   */
  num_archival_memory: number;
  /**
   * The number of messages in the recall memory.
   */
  num_recall_memory: number;
  /**
   * The number of tokens in the external memory summary (archival + recall metadata).
   */
  num_tokens_external_memory_summary: number;
  /**
   * The number of tokens in the system prompt.
   */
  num_tokens_system: number;
  /**
   * The content of the system prompt.
   */
  system_prompt: string;
  /**
   * The number of tokens in the core memory.
   */
  num_tokens_core_memory: number;
  /**
   * The content of the core memory.
   */
  core_memory: string;
  /**
   * The number of tokens in the summary memory.
   */
  num_tokens_summary_memory: number;
  /**
   * The content of the summary memory.
   */
  summary_memory?: string | null;
  /**
   * The number of tokens in the functions definitions.
   */
  num_tokens_functions_definitions: number;
  /**
   * The content of the functions definitions.
   */
  functions_definitions: Array<letta__schemas__openai__chat_completion_request__Tool> | null;
  /**
   * The number of tokens in the messages list.
   */
  num_tokens_messages: number;
  /**
   * The messages in the context window.
   */
  messages: Array<letta__schemas__message__Message_Output>;
};

export type CreateAgent = {
  /**
   * The description of the agent.
   */
  description?: string | null;
  /**
   * The metadata of the agent.
   */
  metadata_?: {
    [key: string]: unknown;
  } | null;
  /**
   * The user id of the agent.
   */
  user_id?: string | null;
  /**
   * The name of the agent.
   */
  name?: string | null;
  /**
   * The ids of the messages in the agent's in-context memory.
   */
  message_ids?: Array<string> | null;
  /**
   * The blocks to create in the agent's in-context memory.
   */
  memory_blocks: Array<CreateBlock>;
  /**
   * The tools used by the agent.
   */
  tools?: Array<string> | null;
  /**
   * The tool rules governing the agent.
   */
  tool_rules?: Array<ChildToolRule | InitToolRule | TerminalToolRule> | null;
  /**
   * The tags associated with the agent.
   */
  tags?: Array<string> | null;
  /**
   * The system prompt used by the agent.
   */
  system?: string | null;
  /**
   * The type of agent.
   */
  agent_type?: AgentType | null;
  /**
   * The LLM configuration used by the agent.
   */
  llm_config?: LLMConfig | null;
  /**
   * The embedding configuration used by the agent.
   */
  embedding_config?: EmbeddingConfig | null;
  /**
   * The initial set of messages to put in the agent's in-context memory.
   */
  initial_message_sequence?: Array<MessageCreate> | null;
};

export type CreateArchivalMemory = {
  /**
   * Text to write to archival memory.
   */
  text: string;
};

export type CreateAssistantFileRequest = {
  /**
   * The unique identifier of the file.
   */
  file_id: string;
};

export type CreateAssistantRequest = {
  /**
   * The model to use for the assistant.
   */
  model: string;
  /**
   * The name of the assistant.
   */
  name: string;
  /**
   * The description of the assistant.
   */
  description?: string;
  /**
   * The instructions for the assistant.
   */
  instructions: string;
  /**
   * The tools used by the assistant.
   */
  tools?: Array<string>;
  /**
   * List of file IDs associated with the assistant.
   */
  file_ids?: Array<string>;
  /**
   * Metadata associated with the assistant.
   */
  metadata?: {
    [key: string]: unknown;
  };
  /**
   * The model to use for the assistant.
   */
  embedding_model?: string;
};

/**
 * Create a block
 */
export type CreateBlock = {
  /**
   * Value of the block.
   */
  value: string;
  /**
   * Character limit of the block.
   */
  limit?: number;
  /**
   * Name of the block if it is a template.
   */
  name?: string | null;
  is_template?: boolean;
  /**
   * Label of the block.
   */
  label: string;
  /**
   * Description of the block.
   */
  description?: string | null;
  /**
   * Metadata of the block.
   */
  metadata_?: {
    [key: string]: unknown;
  } | null;
};

export type CreateMessageRequest = {
  /**
   * Role of the message sender (either 'user' or 'system')
   */
  role: string;
  /**
   * The message content to be processed by the agent.
   */
  content: string;
  /**
   * List of file IDs associated with the message.
   */
  file_ids?: Array<string> | null;
  /**
   * Metadata associated with the message.
   */
  metadata?: {
    [key: string]: unknown;
  } | null;
};

export type CreateRunRequest = {
  /**
   * The unique identifier of the assistant.
   */
  assistant_id: string;
  /**
   * The model used by the run.
   */
  model?: string | null;
  /**
   * The instructions for the run.
   */
  instructions: string;
  /**
   * Additional instructions for the run.
   */
  additional_instructions?: string | null;
  /**
   * The tools used by the run (overrides assistant).
   */
  tools?: Array<letta__schemas__openai__openai__ToolCall> | null;
  /**
   * Metadata associated with the run.
   */
  metadata?: {
    [key: string]: unknown;
  } | null;
};

export type CreateThreadRequest = {
  /**
   * List of message IDs associated with the thread.
   */
  messages?: Array<string> | null;
  /**
   * Metadata associated with the thread.
   */
  metadata?: {
    [key: string]: unknown;
  } | null;
  /**
   * The name of the assistant (i.e. Letta preset)
   */
  assistant_name?: string | null;
};

export type CreateThreadRunRequest = {
  /**
   * The unique identifier of the assistant.
   */
  assistant_id: string;
  /**
   * The thread to run.
   */
  thread: OpenAIThread;
  /**
   * The model used by the run.
   */
  model: string;
  /**
   * The instructions for the run.
   */
  instructions: string;
  /**
   * The tools used by the run (overrides assistant).
   */
  tools?: Array<letta__schemas__openai__openai__ToolCall> | null;
  /**
   * Metadata associated with the run.
   */
  metadata?: {
    [key: string]: unknown;
  } | null;
};

export type DeleteAssistantFileResponse = {
  /**
   * The unique identifier of the file.
   */
  id: string;
  object?: string;
  /**
   * Whether the file was deleted.
   */
  deleted: boolean;
};

export type DeleteAssistantResponse = {
  /**
   * The unique identifier of the agent.
   */
  id: string;
  object?: string;
  /**
   * Whether the agent was deleted.
   */
  deleted: boolean;
};

export type DeleteThreadResponse = {
  /**
   * The unique identifier of the agent.
   */
  id: string;
  object?: string;
  /**
   * Whether the agent was deleted.
   */
  deleted: boolean;
};

export type E2BSandboxConfig = {
  /**
   * Time limit for the sandbox (in seconds).
   */
  timeout?: number;
  /**
   * The E2B template id (docker image).
   */
  template?: string | null;
  /**
   * A list of pip packages to install on the E2B Sandbox
   */
  pip_requirements?: Array<string> | null;
};

/**
 * Embedding model configuration. This object specifies all the information necessary to access an embedding model to usage with Letta, except for secret keys.
 *
 * Attributes:
 * embedding_endpoint_type (str): The endpoint type for the model.
 * embedding_endpoint (str): The endpoint for the model.
 * embedding_model (str): The model for the embedding.
 * embedding_dim (int): The dimension of the embedding.
 * embedding_chunk_size (int): The chunk size of the embedding.
 * azure_endpoint (:obj:`str`, optional): The Azure endpoint for the model (Azure only).
 * azure_version (str): The Azure version for the model (Azure only).
 * azure_deployment (str): The Azure deployment for the model (Azure only).
 */
export type EmbeddingConfig = {
  /**
   * The endpoint type for the model.
   */
  embedding_endpoint_type: string;
  /**
   * The endpoint for the model (`None` if local).
   */
  embedding_endpoint?: string | null;
  /**
   * The model for the embedding.
   */
  embedding_model: string;
  /**
   * The dimension of the embedding.
   */
  embedding_dim: number;
  /**
   * The chunk size of the embedding.
   */
  embedding_chunk_size?: number | null;
  /**
   * The Azure endpoint for the model.
   */
  azure_endpoint?: string | null;
  /**
   * The Azure version for the model.
   */
  azure_version?: string | null;
  /**
   * The Azure deployment for the model.
   */
  azure_deployment?: string | null;
};

/**
 * Representation of a single FileMetadata
 */
export type FileMetadata = {
  /**
   * The human-friendly ID of the File
   */
  id?: string;
  /**
   * The unique identifier of the organization associated with the document.
   */
  organization_id?: string | null;
  /**
   * The unique identifier of the source associated with the document.
   */
  source_id: string;
  /**
   * The name of the file.
   */
  file_name?: string | null;
  /**
   * The path to the file.
   */
  file_path?: string | null;
  /**
   * The type of the file (MIME type).
   */
  file_type?: string | null;
  /**
   * The size of the file in bytes.
   */
  file_size?: number | null;
  /**
   * The creation date of the file.
   */
  file_creation_date?: string | null;
  /**
   * The last modified date of the file.
   */
  file_last_modified_date?: string | null;
  /**
   * The creation date of the file.
   */
  created_at?: string | null;
  /**
   * The update date of the file.
   */
  updated_at?: string | null;
  /**
   * Whether this file is deleted or not.
   */
  is_deleted?: boolean;
};

export type Function = {
  /**
   * The name of the function.
   */
  name: string;
  /**
   * The arguments of the function.
   */
  arguments: string;
};

export type FunctionCall_Input = {
  name: string;
};

export type FunctionCallDelta = {
  name: string | null;
  arguments: string | null;
  function_call_id: string | null;
};

/**
 * A message representing a request to call a function (generated by the LLM to trigger function execution).
 *
 * Attributes:
 * function_call (Union[FunctionCall, FunctionCallDelta]): The function call
 * id (str): The ID of the message
 * date (datetime): The date the message was created in ISO format
 */
export type FunctionCallMessage = {
  id: string;
  date: string;
  message_type?: 'function_call';
  function_call:
    | letta__schemas__letta_message__FunctionCall
    | FunctionCallDelta;
};

export type message_type2 = 'function_call';

/**
 * A message representing the return value of a function call (generated by Letta executing the requested function).
 *
 * Attributes:
 * function_return (str): The return value of the function
 * status (Literal["success", "error"]): The status of the function call
 * id (str): The ID of the message
 * date (datetime): The date the message was created in ISO format
 * function_call_id (str): A unique identifier for the function call that generated this message
 */
export type FunctionReturn = {
  id: string;
  date: string;
  message_type?: 'function_return';
  function_return: string;
  status: 'success' | 'error';
  function_call_id: string;
};

export type message_type3 = 'function_return';

export type status = 'success' | 'error';

export type FunctionSchema = {
  name: string;
  description?: string | null;
  parameters?: {
    [key: string]: unknown;
  } | null;
};

export type HTTPValidationError = {
  detail?: Array<ValidationError>;
};

/**
 * Health check response body
 */
export type Health = {
  version: string;
  status: string;
};

export type ImageFile = {
  type?: string;
  file_id: string;
};

/**
 * Represents the initial tool rule configuration.
 */
export type InitToolRule = {
  /**
   * The name of the tool. Must exist in the database for the user's organization.
   */
  tool_name: string;
  type?: ToolRuleType;
};

/**
 * Representation of an agent's internal monologue.
 *
 * Attributes:
 * internal_monologue (str): The internal monologue of the agent
 * id (str): The ID of the message
 * date (datetime): The date the message was created in ISO format
 */
export type InternalMonologue = {
  id: string;
  date: string;
  message_type?: 'internal_monologue';
  internal_monologue: string;
};

export type message_type4 = 'internal_monologue';

/**
 * Representation of offline jobs, used for tracking status of data loading tasks (involving parsing and embedding files).
 *
 * Parameters:
 * id (str): The unique identifier of the job.
 * status (JobStatus): The status of the job.
 * created_at (datetime): The unix timestamp of when the job was created.
 * completed_at (datetime): The unix timestamp of when the job was completed.
 * user_id (str): The unique identifier of the user associated with the.
 */
export type Job = {
  /**
   * The id of the user that made this object.
   */
  created_by_id?: string | null;
  /**
   * The id of the user that made this object.
   */
  last_updated_by_id?: string | null;
  /**
   * The timestamp when the object was created.
   */
  created_at?: string | null;
  /**
   * The timestamp when the object was last updated.
   */
  updated_at?: string | null;
  /**
   * The status of the job.
   */
  status?: JobStatus;
  /**
   * The unix timestamp of when the job was completed.
   */
  completed_at?: string | null;
  /**
   * The metadata of the job.
   */
  metadata_?: {
    [key: string]: unknown;
  } | null;
  /**
   * The human-friendly ID of the Job
   */
  id?: string;
  /**
   * The unique identifier of the user associated with the job.
   */
  user_id?: string | null;
};

/**
 * Status of the job.
 */
export type JobStatus =
  | 'created'
  | 'running'
  | 'completed'
  | 'failed'
  | 'pending';

/**
 * Configuration for a Language Model (LLM) model. This object specifies all the information necessary to access an LLM model to usage with Letta, except for secret keys.
 *
 * Attributes:
 * model (str): The name of the LLM model.
 * model_endpoint_type (str): The endpoint type for the model.
 * model_endpoint (str): The endpoint for the model.
 * model_wrapper (str): The wrapper for the model. This is used to wrap additional text around the input/output of the model. This is useful for text-to-text completions, such as the Completions API in OpenAI.
 * context_window (int): The context window size for the model.
 * put_inner_thoughts_in_kwargs (bool): Puts `inner_thoughts` as a kwarg in the function call if this is set to True. This helps with function calling performance and also the generation of inner thoughts.
 */
export type LLMConfig = {
  /**
   * LLM model name.
   */
  model: string;
  /**
   * The endpoint type for the model.
   */
  model_endpoint_type:
    | 'openai'
    | 'anthropic'
    | 'cohere'
    | 'google_ai'
    | 'azure'
    | 'groq'
    | 'ollama'
    | 'webui'
    | 'webui-legacy'
    | 'lmstudio'
    | 'lmstudio-legacy'
    | 'llamacpp'
    | 'koboldcpp'
    | 'vllm'
    | 'hugging-face'
    | 'mistral'
    | 'together';
  /**
   * The endpoint for the model.
   */
  model_endpoint?: string | null;
  /**
   * The wrapper for the model.
   */
  model_wrapper?: string | null;
  /**
   * The context window size for the model.
   */
  context_window: number;
  /**
   * Puts 'inner_thoughts' as a kwarg in the function call if this is set to True. This helps with function calling performance and also the generation of inner thoughts.
   */
  put_inner_thoughts_in_kwargs?: boolean | null;
};

/**
 * The endpoint type for the model.
 */
export type model_endpoint_type =
  | 'openai'
  | 'anthropic'
  | 'cohere'
  | 'google_ai'
  | 'azure'
  | 'groq'
  | 'ollama'
  | 'webui'
  | 'webui-legacy'
  | 'lmstudio'
  | 'lmstudio-legacy'
  | 'llamacpp'
  | 'koboldcpp'
  | 'vllm'
  | 'hugging-face'
  | 'mistral'
  | 'together';

export type LettaRequest = {
  /**
   * The messages to be sent to the agent.
   */
  messages: Array<MessageCreate> | Array<Message_Input>;
  /**
   * The name of the designated message tool.
   */
  assistant_message_tool_name?: string;
  /**
   * The name of the message argument in the designated message tool.
   */
  assistant_message_tool_kwarg?: string;
};

export type LettaResponse = {
  AssistantMessage?: {
    id: string;
    date: string;
    message_type?: 'assistant_message';
    assistant_message: string;
  };
  FunctionCall?: {
    name: string;
    arguments: string;
    function_call_id: string;
  };
  FunctionCallDelta?: {
    name: string | null;
    arguments: string | null;
    function_call_id: string | null;
  };
  /**
   * A message representing a request to call a function (generated by the LLM to trigger function execution).
   *
   * Attributes:
   * function_call (Union[FunctionCall, FunctionCallDelta]): The function call
   * id (str): The ID of the message
   * date (datetime): The date the message was created in ISO format
   */
  FunctionCallMessage?: {
    id: string;
    date: string;
    message_type?: 'function_call';
    function_call:
      | LettaResponse['FunctionCall']
      | LettaResponse['FunctionCallDelta'];
  };
  /**
   * A message representing the return value of a function call (generated by Letta executing the requested function).
   *
   * Attributes:
   * function_return (str): The return value of the function
   * status (Literal["success", "error"]): The status of the function call
   * id (str): The ID of the message
   * date (datetime): The date the message was created in ISO format
   * function_call_id (str): A unique identifier for the function call that generated this message
   */
  FunctionReturn?: {
    id: string;
    date: string;
    message_type?: 'function_return';
    function_return: string;
    status: 'success' | 'error';
    function_call_id: string;
  };
  /**
   * Representation of an agent's internal monologue.
   *
   * Attributes:
   * internal_monologue (str): The internal monologue of the agent
   * id (str): The ID of the message
   * date (datetime): The date the message was created in ISO format
   */
  InternalMonologue?: {
    id: string;
    date: string;
    message_type?: 'internal_monologue';
    internal_monologue: string;
  };
  /**
   * Usage statistics for the agent interaction.
   *
   * Attributes:
   * completion_tokens (int): The number of tokens generated by the agent.
   * prompt_tokens (int): The number of tokens in the prompt.
   * total_tokens (int): The total number of tokens processed by the agent.
   * step_count (int): The number of steps taken by the agent.
   */
  LettaUsageStatistics?: {
    /**
     * The number of tokens generated by the agent.
     */
    completion_tokens?: number;
    /**
     * The number of tokens in the prompt.
     */
    prompt_tokens?: number;
    /**
     * The total number of tokens processed by the agent.
     */
    total_tokens?: number;
    /**
     * The number of steps taken by the agent.
     */
    step_count?: number;
  };
  /**
   * A message generated by the system. Never streamed back on a response, only used for cursor pagination.
   *
   * Attributes:
   * message (str): The message sent by the system
   * id (str): The ID of the message
   * date (datetime): The date the message was created in ISO format
   */
  SystemMessage?: {
    id: string;
    date: string;
    message_type?: 'system_message';
    message: string;
  };
  /**
   * A message sent by the user. Never streamed back on a response, only used for cursor pagination.
   *
   * Attributes:
   * message (str): The message sent by the user
   * id (str): The ID of the message
   * date (datetime): The date the message was created in ISO format
   */
  UserMessage?: {
    id: string;
    date: string;
    message_type?: 'user_message';
    message: string;
  };
};

export type LettaStreamingRequest = {
  /**
   * The messages to be sent to the agent.
   */
  messages: Array<MessageCreate> | Array<Message_Input>;
  /**
   * The name of the designated message tool.
   */
  assistant_message_tool_name?: string;
  /**
   * The name of the message argument in the designated message tool.
   */
  assistant_message_tool_kwarg?: string;
  /**
   * Flag to determine if individual tokens should be streamed. Set to True for token streaming (requires stream_steps = True).
   */
  stream_tokens?: boolean;
};

/**
 * Usage statistics for the agent interaction.
 *
 * Attributes:
 * completion_tokens (int): The number of tokens generated by the agent.
 * prompt_tokens (int): The number of tokens in the prompt.
 * total_tokens (int): The total number of tokens processed by the agent.
 * step_count (int): The number of steps taken by the agent.
 */
export type LettaUsageStatistics = {
  /**
   * The number of tokens generated by the agent.
   */
  completion_tokens?: number;
  /**
   * The number of tokens in the prompt.
   */
  prompt_tokens?: number;
  /**
   * The total number of tokens processed by the agent.
   */
  total_tokens?: number;
  /**
   * The number of steps taken by the agent.
   */
  step_count?: number;
};

export type ListMessagesResponse = {
  /**
   * List of message objects.
   */
  messages: Array<OpenAIMessage>;
};

export type LocalSandboxConfig = {
  /**
   * Directory for the sandbox environment.
   */
  sandbox_dir: string;
  /**
   * Whether or not to use the venv, or run directly in the same run loop.
   */
  use_venv?: boolean;
  /**
   * The name for the venv in the sandbox directory. We first search for an existing venv with this name, otherwise, we make it from the requirements.txt.
   */
  venv_name?: string;
};

export type LogProbToken = {
  token: string;
  logprob: number;
  bytes: Array<number> | null;
};

/**
 * Represents the in-context memory (i.e. Core memory) of the agent. This includes both the `Block` objects (labelled by sections), as well as tools to edit the blocks.
 */
export type Memory = {
  /**
   * Memory blocks contained in the agent's in-context memory
   */
  blocks: Array<Block>;
  /**
   * Jinja2 template for compiling memory blocks into a prompt string
   */
  prompt_template?: string;
};

/**
 * Letta's internal representation of a message. Includes methods to convert to/from LLM provider formats.
 *
 * Attributes:
 * id (str): The unique identifier of the message.
 * role (MessageRole): The role of the participant.
 * text (str): The text of the message.
 * user_id (str): The unique identifier of the user.
 * agent_id (str): The unique identifier of the agent.
 * model (str): The model used to make the function call.
 * name (str): The name of the participant.
 * created_at (datetime): The time the message was created.
 * tool_calls (List[ToolCall]): The list of tool calls requested.
 * tool_call_id (str): The id of the tool call.
 */
export type Message_Input = {
  /**
   * The human-friendly ID of the Message
   */
  id?: string;
  /**
   * The role of the participant.
   */
  role: MessageRole;
  /**
   * The text of the message.
   */
  text?: string | null;
  /**
   * The unique identifier of the user.
   */
  user_id?: string | null;
  /**
   * The unique identifier of the agent.
   */
  agent_id?: string | null;
  /**
   * The model used to make the function call.
   */
  model?: string | null;
  /**
   * The name of the participant.
   */
  name?: string | null;
  /**
   * The time the message was created.
   */
  created_at?: string;
  /**
   * The list of tool calls requested.
   */
  tool_calls?: Array<letta__schemas__openai__chat_completions__ToolCall_Input> | null;
  /**
   * The id of the tool call.
   */
  tool_call_id?: string | null;
};

export type MessageContentLogProb = {
  token: string;
  logprob: number;
  bytes: Array<number> | null;
  top_logprobs: Array<LogProbToken> | null;
};

/**
 * Request to create a message
 */
export type MessageCreate = {
  /**
   * The role of the participant.
   */
  role: 'user' | 'system';
  /**
   * The text of the message.
   */
  text: string;
  /**
   * The name of the participant.
   */
  name?: string | null;
};

/**
 * The role of the participant.
 */
export type role = 'user' | 'system';

export type MessageFile = {
  /**
   * The unique identifier of the file.
   */
  id: string;
  object?: string;
  /**
   * The unix timestamp of when the file was created.
   */
  created_at: number;
  /**
   * The unique identifier of the message.
   */
  message_id: string;
};

export type MessageRole = 'assistant' | 'user' | 'tool' | 'function' | 'system';

export type ModifyMessageRequest = {
  /**
   * Metadata associated with the message.
   */
  metadata?: {
    [key: string]: unknown;
  };
};

export type ModifyRunRequest = {
  /**
   * Metadata associated with the run.
   */
  metadata?: {
    [key: string]: unknown;
  };
};

export type ModifyThreadRequest = {
  /**
   * Metadata associated with the thread.
   */
  metadata?: {
    [key: string]: unknown;
  };
};

/**
 * Represents an OpenAI assistant (equivalent to Letta preset)
 */
export type OpenAIAssistant = {
  /**
   * The unique identifier of the assistant.
   */
  id: string;
  /**
   * The name of the assistant.
   */
  name: string;
  object?: string;
  /**
   * The description of the assistant.
   */
  description?: string | null;
  /**
   * The unix timestamp of when the assistant was created.
   */
  created_at: number;
  /**
   * The model used by the assistant.
   */
  model: string;
  /**
   * The instructions for the assistant.
   */
  instructions: string;
  /**
   * The tools used by the assistant.
   */
  tools?: Array<string> | null;
  /**
   * List of file IDs associated with the assistant.
   */
  file_ids?: Array<string> | null;
  /**
   * Metadata associated with the assistant.
   */
  metadata?: {
    [key: string]: unknown;
  } | null;
};

export type OpenAIError = {
  /**
   * The error code.
   */
  code: string;
  /**
   * The error message.
   */
  message: string;
};

export type OpenAIMessage = {
  /**
   * The unique identifier of the message.
   */
  id: string;
  object?: string;
  /**
   * The unix timestamp of when the message was created.
   */
  created_at: number;
  /**
   * The unique identifier of the thread.
   */
  thread_id: string;
  /**
   * Role of the message sender (either 'user' or 'system')
   */
  role: string;
  /**
   * The message content to be processed by the agent.
   */
  content?: Array<Text | ImageFile>;
  /**
   * The unique identifier of the assistant.
   */
  assistant_id: string;
  /**
   * The unique identifier of the run.
   */
  run_id?: string | null;
  /**
   * List of file IDs associated with the message.
   */
  file_ids?: Array<string> | null;
  /**
   * Metadata associated with the message.
   */
  metadata?: {
    [key: string]: unknown;
  } | null;
};

export type OpenAIMessageCreationStep = {
  type?: string;
  /**
   * The unique identifier of the message.
   */
  message_id: string;
};

export type OpenAIRun = {
  /**
   * The unique identifier of the run.
   */
  id: string;
  object?: string;
  /**
   * The unix timestamp of when the run was created.
   */
  created_at: number;
  /**
   * The unique identifier of the thread.
   */
  thread_id: string;
  /**
   * The unique identifier of the assistant.
   */
  assistant_id: string;
  /**
   * The status of the run.
   */
  status: string;
  /**
   * The required action of the run.
   */
  required_action?: RequiredAction | null;
  /**
   * The last error of the run.
   */
  last_error?: OpenAIError | null;
  /**
   * The unix timestamp of when the run expires.
   */
  expires_at: number;
  /**
   * The unix timestamp of when the run started.
   */
  started_at?: number | null;
  /**
   * The unix timestamp of when the run was cancelled.
   */
  cancelled_at?: number | null;
  /**
   * The unix timestamp of when the run failed.
   */
  failed_at?: number | null;
  /**
   * The unix timestamp of when the run completed.
   */
  completed_at?: number | null;
  /**
   * The model used by the run.
   */
  model: string;
  /**
   * The instructions for the run.
   */
  instructions: string;
  /**
   * The tools used by the run.
   */
  tools?: Array<letta__schemas__openai__openai__ToolCall> | null;
  /**
   * List of file IDs associated with the run.
   */
  file_ids?: Array<string> | null;
  /**
   * Metadata associated with the run.
   */
  metadata?: {
    [key: string]: unknown;
  } | null;
  /**
   * The usage of the run.
   */
  usage?: OpenAIUsage | null;
};

export type OpenAIRunStep = {
  /**
   * The unique identifier of the run step.
   */
  id: string;
  object?: string;
  /**
   * The unix timestamp of when the run step was created.
   */
  created_at: number;
  /**
   * The unique identifier of the assistant.
   */
  assistant_id: string;
  /**
   * The unique identifier of the thread.
   */
  thread_id: string;
  /**
   * The unique identifier of the run.
   */
  run_id: string;
  /**
   * The type of the run step.
   */
  type: string;
  /**
   * The status of the run step.
   */
  status: string;
  /**
   * The step defaults.
   */
  step_defaults: OpenAIToolCallsStep | OpenAIMessageCreationStep;
  /**
   * The last error of the run step.
   */
  last_error?: OpenAIError | null;
  /**
   * The unix timestamp of when the run step expired.
   */
  expired_at?: number | null;
  /**
   * The unix timestamp of when the run failed.
   */
  failed_at?: number | null;
  /**
   * The unix timestamp of when the run completed.
   */
  completed_at?: number | null;
  /**
   * The usage of the run.
   */
  usage?: OpenAIUsage | null;
};

/**
 * Represents an OpenAI thread (equivalent to Letta agent)
 */
export type OpenAIThread = {
  /**
   * The unique identifier of the thread.
   */
  id: string;
  object?: string;
  /**
   * The unix timestamp of when the thread was created.
   */
  created_at: number;
  /**
   * Metadata associated with the thread.
   */
  metadata?: {
    [key: string]: unknown;
  };
};

export type OpenAIToolCallsStep = {
  type?: string;
  /**
   * The tool calls.
   */
  tool_calls: Array<letta__schemas__openai__openai__ToolCall>;
};

export type OpenAIUsage = {
  /**
   * The number of tokens used for the run.
   */
  completion_tokens: number;
  /**
   * The number of tokens used for the prompt.
   */
  prompt_tokens: number;
  /**
   * The total number of tokens used for the run.
   */
  total_tokens: number;
};

export type Organization = {
  /**
   * The human-friendly ID of the Org
   */
  id?: string;
  /**
   * The name of the organization.
   */
  name?: string;
  /**
   * The creation date of the organization.
   */
  created_at?: string | null;
};

export type OrganizationCreate = {
  /**
   * The name of the organization.
   */
  name?: string | null;
};

/**
 * Representation of a passage, which is stored in archival memory.
 *
 * Parameters:
 * text (str): The text of the passage.
 * embedding (List[float]): The embedding of the passage.
 * embedding_config (EmbeddingConfig): The embedding configuration used by the passage.
 * created_at (datetime): The creation date of the passage.
 * user_id (str): The unique identifier of the user associated with the passage.
 * agent_id (str): The unique identifier of the agent associated with the passage.
 * source_id (str): The data source of the passage.
 * file_id (str): The unique identifier of the file associated with the passage.
 */
export type Passage = {
  /**
   * The unique identifier of the user associated with the passage.
   */
  user_id?: string | null;
  /**
   * The unique identifier of the agent associated with the passage.
   */
  agent_id?: string | null;
  /**
   * The data source of the passage.
   */
  source_id?: string | null;
  /**
   * The unique identifier of the file associated with the passage.
   */
  file_id?: string | null;
  /**
   * The metadata of the passage.
   */
  metadata_?: {
    [key: string]: unknown;
  } | null;
  /**
   * The human-friendly ID of the Passage
   */
  id?: string;
  /**
   * The text of the passage.
   */
  text: string;
  /**
   * The embedding of the passage.
   */
  embedding: Array<number> | null;
  /**
   * The embedding configuration used by the passage.
   */
  embedding_config: EmbeddingConfig | null;
  /**
   * The creation date of the passage.
   */
  created_at?: string;
};

export type RecallMemorySummary = {
  /**
   * Number of rows in recall memory
   */
  size: number;
};

export type RequiredAction = {
  type?: string;
  submit_tool_outputs: Array<letta__schemas__openai__openai__ToolCall>;
};

export type ResponseFormat = {
  type?: string;
};

export type SandboxConfig = {
  /**
   * The id of the user that made this object.
   */
  created_by_id?: string | null;
  /**
   * The id of the user that made this object.
   */
  last_updated_by_id?: string | null;
  /**
   * The timestamp when the object was created.
   */
  created_at?: string | null;
  /**
   * The timestamp when the object was last updated.
   */
  updated_at?: string | null;
  /**
   * The human-friendly ID of the Sandbox
   */
  id?: string;
  /**
   * The type of sandbox.
   */
  type?: SandboxType;
  /**
   * The unique identifier of the organization associated with the sandbox.
   */
  organization_id?: string | null;
  /**
   * The JSON sandbox settings data.
   */
  config?: {
    [key: string]: unknown;
  };
};

export type SandboxConfigCreate = {
  /**
   * The configuration for the sandbox.
   */
  config: LocalSandboxConfig | E2BSandboxConfig;
};

/**
 * Pydantic model for updating SandboxConfig fields.
 */
export type SandboxConfigUpdate = {
  /**
   * The JSON configuration data for the sandbox.
   */
  config?: LocalSandboxConfig | E2BSandboxConfig;
};

export type SandboxEnvironmentVariable = {
  /**
   * The id of the user that made this object.
   */
  created_by_id?: string | null;
  /**
   * The id of the user that made this object.
   */
  last_updated_by_id?: string | null;
  /**
   * The timestamp when the object was created.
   */
  created_at?: string | null;
  /**
   * The timestamp when the object was last updated.
   */
  updated_at?: string | null;
  /**
   * The human-friendly ID of the Sandbox-env
   */
  id?: string;
  /**
   * The name of the environment variable.
   */
  key: string;
  /**
   * The value of the environment variable.
   */
  value: string;
  /**
   * An optional description of the environment variable.
   */
  description?: string | null;
  /**
   * The ID of the sandbox config this environment variable belongs to.
   */
  sandbox_config_id: string;
  /**
   * The ID of the organization this environment variable belongs to.
   */
  organization_id?: string | null;
};

export type SandboxEnvironmentVariableCreate = {
  /**
   * The name of the environment variable.
   */
  key: string;
  /**
   * The value of the environment variable.
   */
  value: string;
  /**
   * An optional description of the environment variable.
   */
  description?: string | null;
};

/**
 * Pydantic model for updating SandboxEnvironmentVariable fields.
 */
export type SandboxEnvironmentVariableUpdate = {
  /**
   * The name of the environment variable.
   */
  key?: string | null;
  /**
   * The value of the environment variable.
   */
  value?: string | null;
  /**
   * An optional description of the environment variable.
   */
  description?: string | null;
};

export type SandboxType = 'e2b' | 'local';

/**
 * Representation of a source, which is a collection of files and passages.
 *
 * Parameters:
 * id (str): The ID of the source
 * name (str): The name of the source.
 * embedding_config (EmbeddingConfig): The embedding configuration used by the source.
 * user_id (str): The ID of the user that created the source.
 * metadata_ (dict): Metadata associated with the source.
 * description (str): The description of the source.
 */
export type Source = {
  /**
   * The human-friendly ID of the Source
   */
  id?: string;
  /**
   * The name of the source.
   */
  name: string;
  /**
   * The description of the source.
   */
  description?: string | null;
  /**
   * The embedding configuration used by the source.
   */
  embedding_config: EmbeddingConfig;
  /**
   * The ID of the organization that created the source.
   */
  organization_id?: string | null;
  /**
   * Metadata associated with the source.
   */
  metadata_?: {
    [key: string]: unknown;
  } | null;
  /**
   * The id of the user that made this Tool.
   */
  created_by_id?: string | null;
  /**
   * The id of the user that made this Tool.
   */
  last_updated_by_id?: string | null;
  /**
   * The timestamp when the source was created.
   */
  created_at?: string | null;
  /**
   * The timestamp when the source was last updated.
   */
  updated_at?: string | null;
};

/**
 * Schema for creating a new Source.
 */
export type SourceCreate = {
  /**
   * The name of the source.
   */
  name: string;
  /**
   * The embedding configuration used by the source.
   */
  embedding_config?: EmbeddingConfig | null;
  /**
   * The description of the source.
   */
  description?: string | null;
  /**
   * Metadata associated with the source.
   */
  metadata_?: {
    [key: string]: unknown;
  } | null;
};

/**
 * Schema for updating an existing Source.
 */
export type SourceUpdate = {
  /**
   * The name of the source.
   */
  name?: string | null;
  /**
   * The description of the source.
   */
  description?: string | null;
  /**
   * Metadata associated with the source.
   */
  metadata_?: {
    [key: string]: unknown;
  } | null;
  /**
   * The embedding configuration used by the source.
   */
  embedding_config?: EmbeddingConfig | null;
};

export type SubmitToolOutputsToRunRequest = {
  /**
   * The tool outputs to submit.
   */
  tools_outputs: Array<ToolCallOutput>;
};

export type SystemMessage_Input = {
  content: string;
  role?: string;
  name?: string | null;
};

/**
 * A message generated by the system. Never streamed back on a response, only used for cursor pagination.
 *
 * Attributes:
 * message (str): The message sent by the system
 * id (str): The ID of the message
 * date (datetime): The date the message was created in ISO format
 */
export type SystemMessage_Output = {
  id: string;
  date: string;
  message_type?: 'system_message';
  message: string;
};

export type message_type5 = 'system_message';

/**
 * Represents a terminal tool rule configuration where if this tool gets called, it must end the agent loop.
 */
export type TerminalToolRule = {
  /**
   * The name of the tool. Must exist in the database for the user's organization.
   */
  tool_name: string;
  type?: ToolRuleType;
};

export type Text = {
  object?: string;
  /**
   * The text content to be processed by the agent.
   */
  text: string;
};

export type Tool_Input = {
  type?: 'function';
  function: FunctionSchema;
};

export type type = 'function';

export type ToolCallFunction_Output = {
  /**
   * The name of the function to call
   */
  name: string;
  /**
   * The arguments to pass to the function (JSON dump)
   */
  arguments: string;
};

export type ToolCallOutput = {
  /**
   * The unique identifier of the tool call.
   */
  tool_call_id: string;
  /**
   * The output of the tool call.
   */
  output: string;
};

export type ToolCreate = {
  /**
   * The name of the function (auto-generated from source_code if not provided).
   */
  name?: string | null;
  /**
   * The description of the tool.
   */
  description?: string | null;
  /**
   * Metadata tags.
   */
  tags?: Array<string>;
  /**
   * The source code of the function.
   */
  module?: string | null;
  /**
   * The source code of the function.
   */
  source_code: string;
  /**
   * The source type of the function.
   */
  source_type?: string;
  /**
   * The JSON schema of the function (auto-generated from source_code if not provided)
   */
  json_schema?: {
    [key: string]: unknown;
  } | null;
};

export type ToolFunctionChoice = {
  type?: 'function';
  function: FunctionCall_Input;
};

export type ToolMessage = {
  content: string;
  role?: string;
  tool_call_id: string;
};

/**
 * Type of tool rule.
 */
export type ToolRuleType =
  | 'InitToolRule'
  | 'TerminalToolRule'
  | 'continue_loop'
  | 'ToolRule'
  | 'require_parent_tools';

export type ToolRunFromSource = {
  /**
   * The source code of the function.
   */
  source_code: string;
  /**
   * The arguments to pass to the tool (as stringified JSON).
   */
  args: string;
  /**
   * The name of the tool to run.
   */
  name?: string | null;
  /**
   * The type of the source code.
   */
  source_type?: string | null;
};

export type ToolUpdate = {
  /**
   * The description of the tool.
   */
  description?: string | null;
  /**
   * The name of the function.
   */
  name?: string | null;
  /**
   * Metadata tags.
   */
  tags?: Array<string> | null;
  /**
   * The source code of the function.
   */
  module?: string | null;
  /**
   * The source code of the function.
   */
  source_code?: string | null;
  /**
   * The type of the source code.
   */
  source_type?: string | null;
  /**
   * The JSON schema of the function (auto-generated from source_code if not provided)
   */
  json_schema?: {
    [key: string]: unknown;
  } | null;
};

export type UpdateAgentState = {
  /**
   * The description of the agent.
   */
  description?: string | null;
  /**
   * The metadata of the agent.
   */
  metadata_?: {
    [key: string]: unknown;
  } | null;
  /**
   * The user id of the agent.
   */
  user_id?: string | null;
  /**
   * The id of the agent.
   */
  id: string;
  /**
   * The name of the agent.
   */
  name?: string | null;
  /**
   * The tools used by the agent.
   */
  tool_names?: Array<string> | null;
  /**
   * The tags associated with the agent.
   */
  tags?: Array<string> | null;
  /**
   * The system prompt used by the agent.
   */
  system?: string | null;
  /**
   * The LLM configuration used by the agent.
   */
  llm_config?: LLMConfig | null;
  /**
   * The embedding configuration used by the agent.
   */
  embedding_config?: EmbeddingConfig | null;
  /**
   * The ids of the messages in the agent's in-context memory.
   */
  message_ids?: Array<string> | null;
};

/**
 * Request to update a message
 */
export type UpdateMessage = {
  /**
   * The id of the message.
   */
  id: string;
  /**
   * The role of the participant.
   */
  role?: MessageRole | null;
  /**
   * The text of the message.
   */
  text?: string | null;
  /**
   * The name of the participant.
   */
  name?: string | null;
  /**
   * The list of tool calls requested.
   */
  tool_calls?: Array<letta__schemas__openai__chat_completions__ToolCall_Input> | null;
  /**
   * The id of the tool call.
   */
  tool_call_id?: string | null;
};

export type UsageStatistics = {
  completion_tokens?: number;
  prompt_tokens?: number;
  total_tokens?: number;
};

/**
 * Representation of a user.
 *
 * Parameters:
 * id (str): The unique identifier of the user.
 * name (str): The name of the user.
 * created_at (datetime): The creation date of the user.
 */
export type User = {
  /**
   * The human-friendly ID of the User
   */
  id?: string;
  /**
   * The organization id of the user
   */
  organization_id?: string | null;
  /**
   * The name of the user.
   */
  name: string;
  /**
   * The creation date of the user.
   */
  created_at?: string | null;
  /**
   * The update date of the user.
   */
  updated_at?: string | null;
  /**
   * Whether this user is deleted or not.
   */
  is_deleted?: boolean;
};

export type UserCreate = {
  /**
   * The name of the user.
   */
  name: string;
  /**
   * The organization id of the user.
   */
  organization_id: string;
};

export type UserMessage_Input = {
  content: string | Array<string>;
  role?: string;
  name?: string | null;
};

/**
 * A message sent by the user. Never streamed back on a response, only used for cursor pagination.
 *
 * Attributes:
 * message (str): The message sent by the user
 * id (str): The ID of the message
 * date (datetime): The date the message was created in ISO format
 */
export type UserMessage_Output = {
  id: string;
  date: string;
  message_type?: 'user_message';
  message: string;
};

export type message_type6 = 'user_message';

export type UserUpdate = {
  /**
   * The id of the user to update.
   */
  id: string;
  /**
   * The new name of the user.
   */
  name?: string | null;
  /**
   * The new organization id of the user.
   */
  organization_id?: string | null;
};

export type ValidationError = {
  loc: Array<string | number>;
  msg: string;
  type: string;
};

export type letta__schemas__letta_message__FunctionCall = {
  name: string;
  arguments: string;
  function_call_id: string;
};

/**
 * Letta's internal representation of a message. Includes methods to convert to/from LLM provider formats.
 *
 * Attributes:
 * id (str): The unique identifier of the message.
 * role (MessageRole): The role of the participant.
 * text (str): The text of the message.
 * user_id (str): The unique identifier of the user.
 * agent_id (str): The unique identifier of the agent.
 * model (str): The model used to make the function call.
 * name (str): The name of the participant.
 * created_at (datetime): The time the message was created.
 * tool_calls (List[ToolCall]): The list of tool calls requested.
 * tool_call_id (str): The id of the tool call.
 */
export type letta__schemas__message__Message_Output = {
  /**
   * The human-friendly ID of the Message
   */
  id?: string;
  /**
   * The role of the participant.
   */
  role: MessageRole;
  /**
   * The text of the message.
   */
  text?: string | null;
  /**
   * The unique identifier of the user.
   */
  user_id?: string | null;
  /**
   * The unique identifier of the agent.
   */
  agent_id?: string | null;
  /**
   * The model used to make the function call.
   */
  model?: string | null;
  /**
   * The name of the participant.
   */
  name?: string | null;
  /**
   * The time the message was created.
   */
  created_at?: string;
  /**
   * The list of tool calls requested.
   */
  tool_calls?: Array<letta__schemas__openai__chat_completions__ToolCall_Output> | null;
  /**
   * The id of the tool call.
   */
  tool_call_id?: string | null;
};

export type letta__schemas__openai__chat_completion_request__Tool = {
  type?: 'function';
  function: FunctionSchema;
};

export type letta__schemas__openai__chat_completion_request__ToolCall = {
  id: string;
  type?: 'function';
  function: letta__schemas__openai__chat_completion_request__ToolCallFunction;
};

export type letta__schemas__openai__chat_completion_request__ToolCallFunction =
  {
    name: string;
    arguments: string;
  };

export type letta__schemas__openai__chat_completion_response__FunctionCall = {
  arguments: string;
  name: string;
};

export type letta__schemas__openai__chat_completion_response__Message = {
  content?: string | null;
  tool_calls?: Array<letta__schemas__openai__chat_completion_response__ToolCall> | null;
  role: string;
  function_call?: letta__schemas__openai__chat_completion_response__FunctionCall | null;
};

export type letta__schemas__openai__chat_completion_response__ToolCall = {
  id: string;
  type?: 'function';
  function: letta__schemas__openai__chat_completion_response__FunctionCall;
};

export type letta__schemas__openai__chat_completions__ToolCall_Input = {
  /**
   * The ID of the tool call
   */
  id: string;
  type?: string;
  /**
   * The arguments and name for the function
   */
  function: letta__schemas__openai__chat_completions__ToolCallFunction;
};

export type letta__schemas__openai__chat_completions__ToolCall_Output = {
  /**
   * The ID of the tool call
   */
  id: string;
  type?: string;
  /**
   * The arguments and name for the function
   */
  function: ToolCallFunction_Output;
};

export type letta__schemas__openai__chat_completions__ToolCallFunction = {
  /**
   * The name of the function to call
   */
  name: string;
  /**
   * The arguments to pass to the function (JSON dump)
   */
  arguments: string;
};

export type letta__schemas__openai__openai__ToolCall = {
  /**
   * The unique identifier of the tool call.
   */
  id: string;
  type?: string;
  /**
   * The function call.
   */
  function: Function;
};

/**
 * Representation of a tool, which is a function that can be called by the agent.
 *
 * Parameters:
 * id (str): The unique identifier of the tool.
 * name (str): The name of the function.
 * tags (List[str]): Metadata tags.
 * source_code (str): The source code of the function.
 * json_schema (Dict): The JSON schema of the function.
 */
export type letta__schemas__tool__Tool = {
  /**
   * The human-friendly ID of the Tool
   */
  id?: string;
  /**
   * The description of the tool.
   */
  description?: string | null;
  /**
   * The type of the source code.
   */
  source_type?: string | null;
  /**
   * The module of the function.
   */
  module?: string | null;
  /**
   * The unique identifier of the organization associated with the tool.
   */
  organization_id?: string | null;
  /**
   * The name of the function.
   */
  name?: string | null;
  /**
   * Metadata tags.
   */
  tags?: Array<string>;
  /**
   * The source code of the function.
   */
  source_code: string;
  /**
   * The JSON schema of the function.
   */
  json_schema?: {
    [key: string]: unknown;
  } | null;
  /**
   * The id of the user that made this Tool.
   */
  created_by_id?: string | null;
  /**
   * The id of the user that made this Tool.
   */
  last_updated_by_id?: string | null;
};

export type DeleteToolData = {
  toolId: string;
  userId?: string | null;
};

export type DeleteToolResponse = unknown;

export type GetToolData = {
  toolId: string;
  userId?: string | null;
};

export type GetToolResponse = letta__schemas__tool__Tool;

export type UpdateToolData = {
  requestBody: ToolUpdate;
  toolId: string;
  userId?: string | null;
};

export type UpdateToolResponse = letta__schemas__tool__Tool;

export type GetToolIdByNameData = {
  toolName: string;
  userId?: string | null;
};

export type GetToolIdByNameResponse = string;

export type ListToolsData = {
  cursor?: string | null;
  limit?: number | null;
  userId?: string | null;
};

export type ListToolsResponse = Array<letta__schemas__tool__Tool>;

export type CreateToolData = {
  requestBody: ToolCreate;
  userId?: string | null;
};

export type CreateToolResponse = letta__schemas__tool__Tool;

export type UpsertToolData = {
  requestBody: ToolCreate;
  userId?: string | null;
};

export type UpsertToolResponse = letta__schemas__tool__Tool;

export type AddBaseToolsData = {
  userId?: string | null;
};

export type AddBaseToolsResponse = Array<letta__schemas__tool__Tool>;

export type RunToolFromSourceData = {
  requestBody: ToolRunFromSource;
  userId?: string | null;
};

export type RunToolFromSourceResponse = FunctionReturn;

export type ListComposioAppsResponse = Array<AppModel>;

export type ListComposioActionsByAppData = {
  composioAppName: string;
};

export type ListComposioActionsByAppResponse = Array<ActionModel>;

export type AddComposioToolData = {
  composioActionName: string;
  userId?: string | null;
};

export type AddComposioToolResponse = letta__schemas__tool__Tool;

export type GetSourceData = {
  sourceId: string;
  userId?: string | null;
};

export type GetSourceResponse = Source;

export type UpdateSourceData = {
  requestBody: SourceUpdate;
  sourceId: string;
  userId?: string | null;
};

export type UpdateSourceResponse = Source;

export type DeleteSourceData = {
  sourceId: string;
  userId?: string | null;
};

export type DeleteSourceResponse = unknown;

export type GetSourceIdByNameData = {
  sourceName: string;
  userId?: string | null;
};

export type GetSourceIdByNameResponse = string;

export type ListSourcesData = {
  userId?: string | null;
};

export type ListSourcesResponse = Array<Source>;

export type CreateSourceData = {
  requestBody: SourceCreate;
  userId?: string | null;
};

export type CreateSourceResponse = Source;

export type AttachAgentToSourceData = {
  /**
   * The unique identifier of the agent to attach the source to.
   */
  agentId: string;
  sourceId: string;
  userId?: string | null;
};

export type AttachAgentToSourceResponse = Source;

export type DetachAgentFromSourceData = {
  /**
   * The unique identifier of the agent to detach the source from.
   */
  agentId: string;
  sourceId: string;
  userId?: string | null;
};

export type DetachAgentFromSourceResponse = Source;

export type UploadFileToSourceData = {
  formData: Body_upload_file_to_source;
  sourceId: string;
  userId?: string | null;
};

export type UploadFileToSourceResponse = Job;

export type ListSourcePassagesData = {
  sourceId: string;
  userId?: string | null;
};

export type ListSourcePassagesResponse = Array<Passage>;

export type ListFilesFromSourceData = {
  /**
   * Pagination cursor to fetch the next set of results
   */
  cursor?: string | null;
  /**
   * Number of files to return
   */
  limit?: number;
  sourceId: string;
  userId?: string | null;
};

export type ListFilesFromSourceResponse = Array<FileMetadata>;

export type DeleteFileFromSourceData = {
  fileId: string;
  sourceId: string;
  userId?: string | null;
};

export type DeleteFileFromSourceResponse = void;

export type ListAgentsData = {
  /**
   * Name of the agent
   */
  name?: string | null;
  /**
   * List of tags to filter agents by
   */
  tags?: Array<string> | null;
  userId?: string | null;
};

export type ListAgentsResponse = Array<AgentState>;

export type CreateAgentData = {
  requestBody: CreateAgent;
  userId?: string | null;
};

export type CreateAgentResponse = AgentState;

export type GetAgentContextWindowData = {
  agentId: string;
  userId?: string | null;
};

export type GetAgentContextWindowResponse = ContextWindowOverview;

export type UpdateAgentData = {
  agentId: string;
  requestBody: UpdateAgentState;
  userId?: string | null;
};

export type UpdateAgentResponse = AgentState;

export type GetAgentData = {
  agentId: string;
  userId?: string | null;
};

export type GetAgentResponse = AgentState;

export type DeleteAgentData = {
  agentId: string;
  userId?: string | null;
};

export type DeleteAgentResponse = unknown;

export type GetToolsFromAgentData = {
  agentId: string;
  userId?: string | null;
};

export type GetToolsFromAgentResponse = Array<letta__schemas__tool__Tool>;

export type AddToolToAgentData = {
  agentId: string;
  toolId: string;
  userId?: string | null;
};

export type AddToolToAgentResponse = AgentState;

export type RemoveToolFromAgentData = {
  agentId: string;
  toolId: string;
  userId?: string | null;
};

export type RemoveToolFromAgentResponse = AgentState;

export type GetAgentSourcesData = {
  agentId: string;
};

export type GetAgentSourcesResponse = Array<Source>;

export type ListAgentInContextMessagesData = {
  agentId: string;
};

export type ListAgentInContextMessagesResponse =
  Array<letta__schemas__message__Message_Output>;

export type GetAgentMemoryData = {
  agentId: string;
};

export type GetAgentMemoryResponse = Memory;

export type GetAgentMemoryBlockData = {
  agentId: string;
  blockLabel: string;
  userId?: string | null;
};

export type GetAgentMemoryBlockResponse = Block;

export type RemoveAgentMemoryBlockByLabelData = {
  agentId: string;
  blockLabel: string;
  userId?: string | null;
};

export type RemoveAgentMemoryBlockByLabelResponse = Memory;

export type UpdateAgentMemoryBlockByLabelData = {
  agentId: string;
  blockLabel: string;
  requestBody: BlockUpdate;
  userId?: string | null;
};

export type UpdateAgentMemoryBlockByLabelResponse = Block;

export type GetAgentMemoryBlocksData = {
  agentId: string;
  userId?: string | null;
};

export type GetAgentMemoryBlocksResponse = Array<Block>;

export type AddAgentMemoryBlockData = {
  agentId: string;
  requestBody: CreateBlock;
  userId?: string | null;
};

export type AddAgentMemoryBlockResponse = Memory;

export type GetAgentRecallMemorySummaryData = {
  agentId: string;
};

export type GetAgentRecallMemorySummaryResponse = RecallMemorySummary;

export type GetAgentArchivalMemorySummaryData = {
  agentId: string;
};

export type GetAgentArchivalMemorySummaryResponse = ArchivalMemorySummary;

export type ListAgentArchivalMemoryData = {
  /**
   * Unique ID of the memory to start the query range at.
   */
  after?: number | null;
  agentId: string;
  /**
   * Unique ID of the memory to end the query range at.
   */
  before?: number | null;
  /**
   * How many results to include in the response.
   */
  limit?: number | null;
  userId?: string | null;
};

export type ListAgentArchivalMemoryResponse = Array<Passage>;

export type CreateAgentArchivalMemoryData = {
  agentId: string;
  requestBody: CreateArchivalMemory;
  userId?: string | null;
};

export type CreateAgentArchivalMemoryResponse = Array<Passage>;

export type DeleteAgentArchivalMemoryData = {
  agentId: string;
  memoryId: string;
  userId?: string | null;
};

export type DeleteAgentArchivalMemoryResponse = unknown;

export type ListAgentMessagesData = {
  agentId: string;
  /**
   * The name of the message argument in the designated message tool.
   */
  assistantMessageToolKwarg?: string;
  /**
   * The name of the designated message tool.
   */
  assistantMessageToolName?: string;
  /**
   * Message before which to retrieve the returned messages.
   */
  before?: string | null;
  /**
   * Maximum number of messages to retrieve.
   */
  limit?: number;
  /**
   * If true, returns Message objects. If false, return LettaMessage objects.
   */
  msgObject?: boolean;
  userId?: string | null;
};

export type ListAgentMessagesResponse =
  | Array<letta__schemas__message__Message_Output>
  | Array<
      | SystemMessage_Output
      | UserMessage_Output
      | InternalMonologue
      | FunctionCallMessage
      | FunctionReturn
      | AssistantMessage_Output
    >;

export type CreateAgentMessageData = {
  agentId: string;
  requestBody: LettaRequest;
  userId?: string | null;
};

export type CreateAgentMessageResponse = LettaResponse;

export type UpdateAgentMessageData = {
  agentId: string;
  messageId: string;
  requestBody: UpdateMessage;
};

export type UpdateAgentMessageResponse =
  letta__schemas__message__Message_Output;

export type CreateAgentMessage1Data = {
  agentId: string;
  requestBody: LettaStreamingRequest;
  userId?: string | null;
};

export type CreateAgentMessage1Response = unknown;

export type ListModelsResponse = Array<LLMConfig>;

export type ListEmbeddingModelsResponse = Array<EmbeddingConfig>;

export type ListMemoryBlocksData = {
  /**
   * Labels to include (e.g. human, persona)
   */
  label?: string | null;
  /**
   * Name of the block
   */
  name?: string | null;
  /**
   * Whether to include only templates
   */
  templatesOnly?: boolean;
  userId?: string | null;
};

export type ListMemoryBlocksResponse = Array<Block>;

export type CreateMemoryBlockData = {
  requestBody: CreateBlock;
  userId?: string | null;
};

export type CreateMemoryBlockResponse = Block;

export type UpdateMemoryBlockData = {
  blockId: string;
  requestBody: BlockUpdate;
  userId?: string | null;
};

export type UpdateMemoryBlockResponse = Block;

export type DeleteMemoryBlockData = {
  blockId: string;
  userId?: string | null;
};

export type DeleteMemoryBlockResponse = Block;

export type GetMemoryBlockData = {
  blockId: string;
  userId?: string | null;
};

export type GetMemoryBlockResponse = Block;

export type UpdateAgentMemoryBlockData = {
  /**
   * The unique identifier of the agent to attach the source to.
   */
  agentId: string;
  blockId: string;
  userId?: string | null;
};

export type UpdateAgentMemoryBlockResponse = Block;

export type UpdateAgentMemoryBlock1Data = {
  /**
   * The unique identifier of the agent to attach the source to.
   */
  agentId: string;
  blockId: string;
  userId?: string | null;
};

export type UpdateAgentMemoryBlock1Response = Memory;

export type ListJobsData = {
  /**
   * Only list jobs associated with the source.
   */
  sourceId?: string | null;
  userId?: string | null;
};

export type ListJobsResponse = Array<Job>;

export type ListActiveJobsData = {
  userId?: string | null;
};

export type ListActiveJobsResponse = Array<Job>;

export type GetJobData = {
  jobId: string;
  userId?: string | null;
};

export type GetJobResponse = Job;

export type DeleteJobData = {
  jobId: string;
  userId?: string | null;
};

export type DeleteJobResponse = Job;

export type HealthCheckResponse = Health;

export type CreateSandboxConfigV1SandboxConfigPostData = {
  requestBody: SandboxConfigCreate;
  userId?: string | null;
};

export type CreateSandboxConfigV1SandboxConfigPostResponse = SandboxConfig;

export type ListSandboxConfigsV1SandboxConfigGetData = {
  /**
   * Pagination cursor to fetch the next set of results
   */
  cursor?: string | null;
  /**
   * Number of results to return
   */
  limit?: number;
  userId?: string | null;
};

export type ListSandboxConfigsV1SandboxConfigGetResponse = Array<SandboxConfig>;

export type CreateDefaultE2bSandboxConfigV1SandboxConfigE2bDefaultPostData = {
  userId?: string | null;
};

export type CreateDefaultE2bSandboxConfigV1SandboxConfigE2bDefaultPostResponse =
  SandboxConfig;

export type CreateDefaultLocalSandboxConfigV1SandboxConfigLocalDefaultPostData =
  {
    userId?: string | null;
  };

export type CreateDefaultLocalSandboxConfigV1SandboxConfigLocalDefaultPostResponse =
  SandboxConfig;

export type UpdateSandboxConfigV1SandboxConfigSandboxConfigIdPatchData = {
  requestBody: SandboxConfigUpdate;
  sandboxConfigId: string;
  userId?: string | null;
};

export type UpdateSandboxConfigV1SandboxConfigSandboxConfigIdPatchResponse =
  SandboxConfig;

export type DeleteSandboxConfigV1SandboxConfigSandboxConfigIdDeleteData = {
  sandboxConfigId: string;
  userId?: string | null;
};

export type DeleteSandboxConfigV1SandboxConfigSandboxConfigIdDeleteResponse =
  void;

export type CreateSandboxEnvVarV1SandboxConfigSandboxConfigIdEnvironmentVariablePostData =
  {
    requestBody: SandboxEnvironmentVariableCreate;
    sandboxConfigId: string;
    userId?: string | null;
  };

export type CreateSandboxEnvVarV1SandboxConfigSandboxConfigIdEnvironmentVariablePostResponse =
  SandboxEnvironmentVariable;

export type ListSandboxEnvVarsV1SandboxConfigSandboxConfigIdEnvironmentVariableGetData =
  {
    /**
     * Pagination cursor to fetch the next set of results
     */
    cursor?: string | null;
    /**
     * Number of results to return
     */
    limit?: number;
    sandboxConfigId: string;
    userId?: string | null;
  };

export type ListSandboxEnvVarsV1SandboxConfigSandboxConfigIdEnvironmentVariableGetResponse =
  Array<SandboxEnvironmentVariable>;

export type UpdateSandboxEnvVarV1SandboxConfigEnvironmentVariableEnvVarIdPatchData =
  {
    envVarId: string;
    requestBody: SandboxEnvironmentVariableUpdate;
    userId?: string | null;
  };

export type UpdateSandboxEnvVarV1SandboxConfigEnvironmentVariableEnvVarIdPatchResponse =
  SandboxEnvironmentVariable;

export type DeleteSandboxEnvVarV1SandboxConfigEnvironmentVariableEnvVarIdDeleteData =
  {
    envVarId: string;
    userId?: string | null;
  };

export type DeleteSandboxEnvVarV1SandboxConfigEnvironmentVariableEnvVarIdDeleteResponse =
  void;

export type ListUsersData = {
  cursor?: string | null;
  limit?: number | null;
};

export type ListUsersResponse = Array<User>;

export type CreateUserData = {
  requestBody: UserCreate;
};

export type CreateUserResponse = User;

export type UpdateUserData = {
  requestBody: UserUpdate;
};

export type UpdateUserResponse = User;

export type DeleteUserData = {
  /**
   * The user_id key to be deleted.
   */
  userId: string;
};

export type DeleteUserResponse = User;

export type CreateApiKeyData = {
  requestBody: APIKeyCreate;
};

export type CreateApiKeyResponse = APIKey;

export type ListApiKeysData = {
  /**
   * The unique identifier of the user.
   */
  userId: string;
};

export type ListApiKeysResponse = Array<APIKey>;

export type DeleteApiKeyData = {
  /**
   * The API key to be deleted.
   */
  apiKey: string;
};

export type DeleteApiKeyResponse = APIKey;

export type ListOrgsData = {
  cursor?: string | null;
  limit?: number | null;
};

export type ListOrgsResponse = Array<Organization>;

export type CreateOrganizationData = {
  requestBody: OrganizationCreate;
};

export type CreateOrganizationResponse = Organization;

export type DeleteOrganizationByIdData = {
  /**
   * The org_id key to be deleted.
   */
  orgId: string;
};

export type DeleteOrganizationByIdResponse = Organization;

export type AuthenticateUserV1AuthPostData = {
  requestBody: AuthRequest;
};

export type AuthenticateUserV1AuthPostResponse = AuthResponse;

export type $OpenApiTs = {
  '/v1/tools/{tool_id}': {
    delete: {
      req: DeleteToolData;
      res: {
        /**
         * Successful Response
         */
        200: unknown;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
    get: {
      req: GetToolData;
      res: {
        /**
         * Successful Response
         */
        200: letta__schemas__tool__Tool;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
    patch: {
      req: UpdateToolData;
      res: {
        /**
         * Successful Response
         */
        200: letta__schemas__tool__Tool;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/tools/name/{tool_name}': {
    get: {
      req: GetToolIdByNameData;
      res: {
        /**
         * Successful Response
         */
        200: string;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/tools/': {
    get: {
      req: ListToolsData;
      res: {
        /**
         * Successful Response
         */
        200: Array<letta__schemas__tool__Tool>;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
    post: {
      req: CreateToolData;
      res: {
        /**
         * Successful Response
         */
        200: letta__schemas__tool__Tool;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
    put: {
      req: UpsertToolData;
      res: {
        /**
         * Successful Response
         */
        200: letta__schemas__tool__Tool;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/tools/add-base-tools': {
    post: {
      req: AddBaseToolsData;
      res: {
        /**
         * Successful Response
         */
        200: Array<letta__schemas__tool__Tool>;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/tools/run': {
    post: {
      req: RunToolFromSourceData;
      res: {
        /**
         * Successful Response
         */
        200: FunctionReturn;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/tools/composio/apps': {
    get: {
      res: {
        /**
         * Successful Response
         */
        200: Array<AppModel>;
      };
    };
  };
  '/v1/tools/composio/apps/{composio_app_name}/actions': {
    get: {
      req: ListComposioActionsByAppData;
      res: {
        /**
         * Successful Response
         */
        200: Array<ActionModel>;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/tools/composio/{composio_action_name}': {
    post: {
      req: AddComposioToolData;
      res: {
        /**
         * Successful Response
         */
        200: letta__schemas__tool__Tool;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/sources/{source_id}': {
    get: {
      req: GetSourceData;
      res: {
        /**
         * Successful Response
         */
        200: Source;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
    patch: {
      req: UpdateSourceData;
      res: {
        /**
         * Successful Response
         */
        200: Source;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
    delete: {
      req: DeleteSourceData;
      res: {
        /**
         * Successful Response
         */
        200: unknown;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/sources/name/{source_name}': {
    get: {
      req: GetSourceIdByNameData;
      res: {
        /**
         * Successful Response
         */
        200: string;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/sources/': {
    get: {
      req: ListSourcesData;
      res: {
        /**
         * Successful Response
         */
        200: Array<Source>;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
    post: {
      req: CreateSourceData;
      res: {
        /**
         * Successful Response
         */
        200: Source;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/sources/{source_id}/attach': {
    post: {
      req: AttachAgentToSourceData;
      res: {
        /**
         * Successful Response
         */
        200: Source;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/sources/{source_id}/detach': {
    post: {
      req: DetachAgentFromSourceData;
      res: {
        /**
         * Successful Response
         */
        200: Source;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/sources/{source_id}/upload': {
    post: {
      req: UploadFileToSourceData;
      res: {
        /**
         * Successful Response
         */
        200: Job;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/sources/{source_id}/passages': {
    get: {
      req: ListSourcePassagesData;
      res: {
        /**
         * Successful Response
         */
        200: Array<Passage>;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/sources/{source_id}/files': {
    get: {
      req: ListFilesFromSourceData;
      res: {
        /**
         * Successful Response
         */
        200: Array<FileMetadata>;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/sources/{source_id}/{file_id}': {
    delete: {
      req: DeleteFileFromSourceData;
      res: {
        /**
         * Successful Response
         */
        204: void;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/agents/': {
    get: {
      req: ListAgentsData;
      res: {
        /**
         * Successful Response
         */
        200: Array<AgentState>;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
    post: {
      req: CreateAgentData;
      res: {
        /**
         * Successful Response
         */
        200: AgentState;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/agents/{agent_id}/context': {
    get: {
      req: GetAgentContextWindowData;
      res: {
        /**
         * Successful Response
         */
        200: ContextWindowOverview;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/agents/{agent_id}': {
    patch: {
      req: UpdateAgentData;
      res: {
        /**
         * Successful Response
         */
        200: AgentState;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
    get: {
      req: GetAgentData;
      res: {
        /**
         * Successful Response
         */
        200: AgentState;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
    delete: {
      req: DeleteAgentData;
      res: {
        /**
         * Successful Response
         */
        200: unknown;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/agents/{agent_id}/tools': {
    get: {
      req: GetToolsFromAgentData;
      res: {
        /**
         * Successful Response
         */
        200: Array<letta__schemas__tool__Tool>;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/agents/{agent_id}/add-tool/{tool_id}': {
    patch: {
      req: AddToolToAgentData;
      res: {
        /**
         * Successful Response
         */
        200: AgentState;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/agents/{agent_id}/remove-tool/{tool_id}': {
    patch: {
      req: RemoveToolFromAgentData;
      res: {
        /**
         * Successful Response
         */
        200: AgentState;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/agents/{agent_id}/sources': {
    get: {
      req: GetAgentSourcesData;
      res: {
        /**
         * Successful Response
         */
        200: Array<Source>;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/agents/{agent_id}/memory/messages': {
    get: {
      req: ListAgentInContextMessagesData;
      res: {
        /**
         * Successful Response
         */
        200: Array<letta__schemas__message__Message_Output>;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/agents/{agent_id}/memory': {
    get: {
      req: GetAgentMemoryData;
      res: {
        /**
         * Successful Response
         */
        200: Memory;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/agents/{agent_id}/memory/block/{block_label}': {
    get: {
      req: GetAgentMemoryBlockData;
      res: {
        /**
         * Successful Response
         */
        200: Block;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
    delete: {
      req: RemoveAgentMemoryBlockByLabelData;
      res: {
        /**
         * Successful Response
         */
        200: Memory;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
    patch: {
      req: UpdateAgentMemoryBlockByLabelData;
      res: {
        /**
         * Successful Response
         */
        200: Block;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/agents/{agent_id}/memory/block': {
    get: {
      req: GetAgentMemoryBlocksData;
      res: {
        /**
         * Successful Response
         */
        200: Array<Block>;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
    post: {
      req: AddAgentMemoryBlockData;
      res: {
        /**
         * Successful Response
         */
        200: Memory;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/agents/{agent_id}/memory/recall': {
    get: {
      req: GetAgentRecallMemorySummaryData;
      res: {
        /**
         * Successful Response
         */
        200: RecallMemorySummary;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/agents/{agent_id}/memory/archival': {
    get: {
      req: GetAgentArchivalMemorySummaryData;
      res: {
        /**
         * Successful Response
         */
        200: ArchivalMemorySummary;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/agents/{agent_id}/archival': {
    get: {
      req: ListAgentArchivalMemoryData;
      res: {
        /**
         * Successful Response
         */
        200: Array<Passage>;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
    post: {
      req: CreateAgentArchivalMemoryData;
      res: {
        /**
         * Successful Response
         */
        200: Array<Passage>;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/agents/{agent_id}/archival/{memory_id}': {
    delete: {
      req: DeleteAgentArchivalMemoryData;
      res: {
        /**
         * Successful Response
         */
        200: unknown;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/agents/{agent_id}/messages': {
    get: {
      req: ListAgentMessagesData;
      res: {
        /**
         * Successful Response
         */
        200:
          | Array<letta__schemas__message__Message_Output>
          | Array<
              | SystemMessage_Output
              | UserMessage_Output
              | InternalMonologue
              | FunctionCallMessage
              | FunctionReturn
              | AssistantMessage_Output
            >;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
    post: {
      req: CreateAgentMessageData;
      res: {
        /**
         * Successful Response
         */
        200: LettaResponse;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/agents/{agent_id}/messages/{message_id}': {
    patch: {
      req: UpdateAgentMessageData;
      res: {
        /**
         * Successful Response
         */
        200: letta__schemas__message__Message_Output;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/agents/{agent_id}/messages/stream': {
    post: {
      req: CreateAgentMessage1Data;
      res: {
        /**
         * Successful response
         */
        200: unknown;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/models/': {
    get: {
      res: {
        /**
         * Successful Response
         */
        200: Array<LLMConfig>;
      };
    };
  };
  '/v1/models/embedding': {
    get: {
      res: {
        /**
         * Successful Response
         */
        200: Array<EmbeddingConfig>;
      };
    };
  };
  '/v1/blocks/': {
    get: {
      req: ListMemoryBlocksData;
      res: {
        /**
         * Successful Response
         */
        200: Array<Block>;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
    post: {
      req: CreateMemoryBlockData;
      res: {
        /**
         * Successful Response
         */
        200: Block;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/blocks/{block_id}': {
    patch: {
      req: UpdateMemoryBlockData;
      res: {
        /**
         * Successful Response
         */
        200: Block;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
    delete: {
      req: DeleteMemoryBlockData;
      res: {
        /**
         * Successful Response
         */
        200: Block;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
    get: {
      req: GetMemoryBlockData;
      res: {
        /**
         * Successful Response
         */
        200: Block;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/blocks/{block_id}/attach': {
    patch: {
      req: UpdateAgentMemoryBlockData;
      res: {
        /**
         * Successful Response
         */
        200: Block;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/blocks/{block_id}/detach': {
    patch: {
      req: UpdateAgentMemoryBlock1Data;
      res: {
        /**
         * Successful Response
         */
        200: Memory;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/jobs/': {
    get: {
      req: ListJobsData;
      res: {
        /**
         * Successful Response
         */
        200: Array<Job>;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/jobs/active': {
    get: {
      req: ListActiveJobsData;
      res: {
        /**
         * Successful Response
         */
        200: Array<Job>;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/jobs/{job_id}': {
    get: {
      req: GetJobData;
      res: {
        /**
         * Successful Response
         */
        200: Job;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
    delete: {
      req: DeleteJobData;
      res: {
        /**
         * Successful Response
         */
        200: Job;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/health/': {
    get: {
      res: {
        /**
         * Successful Response
         */
        200: Health;
      };
    };
  };
  '/v1/sandbox-config/': {
    post: {
      req: CreateSandboxConfigV1SandboxConfigPostData;
      res: {
        /**
         * Successful Response
         */
        200: SandboxConfig;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
    get: {
      req: ListSandboxConfigsV1SandboxConfigGetData;
      res: {
        /**
         * Successful Response
         */
        200: Array<SandboxConfig>;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/sandbox-config/e2b/default': {
    post: {
      req: CreateDefaultE2bSandboxConfigV1SandboxConfigE2bDefaultPostData;
      res: {
        /**
         * Successful Response
         */
        200: SandboxConfig;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/sandbox-config/local/default': {
    post: {
      req: CreateDefaultLocalSandboxConfigV1SandboxConfigLocalDefaultPostData;
      res: {
        /**
         * Successful Response
         */
        200: SandboxConfig;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/sandbox-config/{sandbox_config_id}': {
    patch: {
      req: UpdateSandboxConfigV1SandboxConfigSandboxConfigIdPatchData;
      res: {
        /**
         * Successful Response
         */
        200: SandboxConfig;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
    delete: {
      req: DeleteSandboxConfigV1SandboxConfigSandboxConfigIdDeleteData;
      res: {
        /**
         * Successful Response
         */
        204: void;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/sandbox-config/{sandbox_config_id}/environment-variable': {
    post: {
      req: CreateSandboxEnvVarV1SandboxConfigSandboxConfigIdEnvironmentVariablePostData;
      res: {
        /**
         * Successful Response
         */
        200: SandboxEnvironmentVariable;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
    get: {
      req: ListSandboxEnvVarsV1SandboxConfigSandboxConfigIdEnvironmentVariableGetData;
      res: {
        /**
         * Successful Response
         */
        200: Array<SandboxEnvironmentVariable>;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/sandbox-config/environment-variable/{env_var_id}': {
    patch: {
      req: UpdateSandboxEnvVarV1SandboxConfigEnvironmentVariableEnvVarIdPatchData;
      res: {
        /**
         * Successful Response
         */
        200: SandboxEnvironmentVariable;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
    delete: {
      req: DeleteSandboxEnvVarV1SandboxConfigEnvironmentVariableEnvVarIdDeleteData;
      res: {
        /**
         * Successful Response
         */
        204: void;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/admin/users/': {
    get: {
      req: ListUsersData;
      res: {
        /**
         * Successful Response
         */
        200: Array<User>;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
    post: {
      req: CreateUserData;
      res: {
        /**
         * Successful Response
         */
        200: User;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
    put: {
      req: UpdateUserData;
      res: {
        /**
         * Successful Response
         */
        200: User;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
    delete: {
      req: DeleteUserData;
      res: {
        /**
         * Successful Response
         */
        200: User;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/admin/users/keys': {
    post: {
      req: CreateApiKeyData;
      res: {
        /**
         * Successful Response
         */
        200: APIKey;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
    get: {
      req: ListApiKeysData;
      res: {
        /**
         * Successful Response
         */
        200: Array<APIKey>;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
    delete: {
      req: DeleteApiKeyData;
      res: {
        /**
         * Successful Response
         */
        200: APIKey;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/admin/orgs/': {
    get: {
      req: ListOrgsData;
      res: {
        /**
         * Successful Response
         */
        200: Array<Organization>;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
    post: {
      req: CreateOrganizationData;
      res: {
        /**
         * Successful Response
         */
        200: Organization;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
    delete: {
      req: DeleteOrganizationByIdData;
      res: {
        /**
         * Successful Response
         */
        200: Organization;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  '/v1/auth': {
    post: {
      req: AuthenticateUserV1AuthPostData;
      res: {
        /**
         * Successful Response
         */
        200: AuthResponse;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
};
