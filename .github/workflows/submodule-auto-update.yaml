name: 🔄 Auto-Update Letta Core Submodule

on:
  repository_dispatch:
    types: [letta-main-updated]
  workflow_dispatch:
    inputs:
      commit_sha:
        description: 'Specific commit SHA to update to (optional)'
        required: false
        type: string

permissions:
  contents: write
  actions: write
  checks: read
  id-token: write
  pull-requests: write

jobs:
  update-and-verify:
    runs-on: ubuntu-latest
    outputs:
      should_skip: ${{ steps.update-submodule.outputs.should_skip }}
      old_sha: ${{ steps.update-submodule.outputs.old_sha }}
      new_sha: ${{ steps.update-submodule.outputs.new_sha }}
      tests_passed: ${{ steps.check-tests.outputs.all_passed }}
    steps:
      - name: Install uv
        uses: astral-sh/setup-uv@v6
        with:
          activate-environment: true

      - name: Generate GitHub App Token
        id: app-token
        uses: actions/create-github-app-token@v1
        with:
          app-id: ${{ secrets.NOTIFIER_APP_ID }}
          private-key: ${{ secrets.NOTIFIER_PRIVATE_KEY }}

      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ steps.app-token.outputs.token }}
          submodules: true
          fetch-depth: 0

      - name: Update submodule to latest main
        id: update-submodule
        run: |
          cd apps/core
          git fetch origin

          # Use specific commit if provided, otherwise use latest main
          if [ -n "${{ github.event.inputs.commit_sha }}" ]; then
            TARGET_SHA="${{ github.event.inputs.commit_sha }}"
          elif [ -n "${{ github.event.client_payload.commit_sha }}" ]; then
            TARGET_SHA="${{ github.event.client_payload.commit_sha }}"
          else
            TARGET_SHA=$(git rev-parse origin/main)
          fi

          echo "Updating submodule to commit: $TARGET_SHA"
          git checkout $TARGET_SHA

          # Check if this is actually a new commit
          cd ..
          CURRENT_SHA=$(git rev-parse HEAD:apps/core)
          if [ "$CURRENT_SHA" = "$TARGET_SHA" ]; then
            echo "Submodule already at target commit $TARGET_SHA"
            echo "should_skip=true" >> $GITHUB_OUTPUT
            exit 0
          fi

          echo "Updated from $CURRENT_SHA to $TARGET_SHA"
          echo "old_sha=$CURRENT_SHA" >> $GITHUB_OUTPUT
          echo "new_sha=$TARGET_SHA" >> $GITHUB_OUTPUT
          echo "should_skip=false" >> $GITHUB_OUTPUT

      - name: Install just
        if: steps.update-submodule.outputs.should_skip != 'true'
        run: |
          curl --proto '=https' --tlsv1.2 -sSf https://just.systems/install.sh | sudo bash -s -- --to /usr/local/bin

      - name: Setup Node.js
        if: steps.update-submodule.outputs.should_skip != 'true'
        uses: actions/setup-node@v4
        with:
          node-version: '18'

      - name: Install dependencies
        if: steps.update-submodule.outputs.should_skip != 'true'
        run: |
          npm install
          cd apps/core
          uv sync --all-extras

      - name: Run stage-api and publish-api
        if: steps.update-submodule.outputs.should_skip != 'true'
        run: |
          echo "Running stage-api..."
          just stage-api
          echo "Running publish-api..."
          just publish-api

      - name: Commit submodule update and API changes to temporary branch
        if: steps.update-submodule.outputs.should_skip != 'true'
        run: |
          # Create a temporary branch for testing
          BRANCH_NAME="auto-update-submodule-${{ steps.update-submodule.outputs.new_sha }}"
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          git checkout -b $BRANCH_NAME

          # Add submodule changes
          git add apps/core
          git commit -m "chore: update letta core submodule to ${{ steps.update-submodule.outputs.new_sha }}" --no-verify

          # Check for API changes and commit them too
          if [[ -n $(git status --porcelain) ]]; then
            echo "API changes detected, adding to the same PR..."
            git add -A
            git commit -m "chore: update API artifacts following submodule update" --no-verify
          else
            echo "No API changes detected"
          fi

          git push origin $BRANCH_NAME
          echo "TEMP_BRANCH=$BRANCH_NAME" >> $GITHUB_ENV

      - name: Create Pull Request
        if: steps.update-submodule.outputs.should_skip != 'true'
        id: create-pr
        run: |
          BRANCH_NAME="auto-update-submodule-${{ steps.update-submodule.outputs.new_sha }}"

          PR_URL=$(gh pr create \
            --title "chore: update letta core submodule to ${{ steps.update-submodule.outputs.new_sha }}" \
            --body "$(cat <<'EOF'
          ## Summary
          - Automated submodule update from ${{ steps.update-submodule.outputs.old_sha }} to ${{ steps.update-submodule.outputs.new_sha }}

          ## Test plan
          - [ ] End-to-End Tests pass
          - [ ] Cloud API Stability Tests pass
          - [ ] Web Lint and Unit Tests pass
          - [ ] Cloud API Integration Tests pass
          - [ ] Web Migration API Stability Tests pass

          🤖 This PR was automatically created by the submodule auto-update workflow.
          EOF
          )" \
            --head $BRANCH_NAME \
            --base main)

          echo "pr_url=$PR_URL" >> $GITHUB_OUTPUT
          echo "PR created: $PR_URL"
        env:
          GH_TOKEN: ${{ steps.app-token.outputs.token }}

      - name: Wait for and check test results
        if: steps.update-submodule.outputs.should_skip != 'true'
        id: check-tests
        run: |
          echo "Waiting for tests to complete on PR..."

          # Define the required test contexts to monitor (partial matching patterns)
          REQUIRED_TESTS=(
            "cypress-run"
            "cloud-api-test"
            "main"
            "cloud-api-integration-tests"
            "migration-api-stability"
          )

          # Find the PR number
          BRANCH_NAME="auto-update-submodule-${{ steps.update-submodule.outputs.new_sha }}"
          PR_NUMBER=$(gh pr list --head $BRANCH_NAME --json number --jq '.[0].number')

          if [ -z "$PR_NUMBER" ]; then
            echo "ERROR: Could not find PR for branch $BRANCH_NAME"
            echo "all_passed=false" >> $GITHUB_OUTPUT
            exit 1
          fi

          echo "Monitoring PR #$PR_NUMBER"
          echo "Required tests: ${REQUIRED_TESTS[@]}"

          # Define required tests with flexible matching patterns
          # These will be matched against check names case-insensitively
          declare -A REQUIRED_TESTS
          REQUIRED_TESTS["e2e"]="End-to-End.*cypress"
          REQUIRED_TESTS["cloud-api-stability"]="Cloud API Stability"
          REQUIRED_TESTS["web-lint"]="Web.*Lint.*Test"
          REQUIRED_TESTS["cloud-api-integration"]="cloud-api.*integration"
          REQUIRED_TESTS["migration-api"]="Migration.*API"

          echo "Required test patterns:"
          for key in "${!REQUIRED_TESTS[@]}"; do
            echo "  - $key: ${REQUIRED_TESTS[$key]}"
          done

          # Configuration
          MAX_WAIT=2700  # 45 minutes
          WAIT_TIME=0
          SLEEP_INTERVAL=60  # Check every minute
          CHECK_COUNT=0
          NO_CHECK_COUNT=0
          MAX_NO_CHECK_COUNT=10  # After 10 minutes of no checks, allow proceeding

          while [ $WAIT_TIME -lt $MAX_WAIT ]; do
            CHECK_COUNT=$((CHECK_COUNT + 1))
            echo ""
            echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
            echo "Check #$CHECK_COUNT at $(date '+%H:%M:%S') (${WAIT_TIME}s elapsed)"
            echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"

            # Get check runs using gh pr checks (more reliable)
            echo "Fetching check status..."
            PR_CHECKS=$(gh pr checks $PR_NUMBER --json name,status,conclusion 2>/dev/null || echo "[]")

            # Handle no checks case
            if [ "$PR_CHECKS" = "[]" ] || [ -z "$PR_CHECKS" ]; then
              NO_CHECK_COUNT=$((NO_CHECK_COUNT + 1))
              echo "⚠️  No checks found (attempt $NO_CHECK_COUNT/$MAX_NO_CHECK_COUNT)"

              if [ $NO_CHECK_COUNT -ge $MAX_NO_CHECK_COUNT ]; then
                echo ""
                echo "⚠️  No checks found after ${NO_CHECK_COUNT} attempts."
                echo "This PR may not trigger any workflows (submodule-only change)."
                echo "Proceeding with merge."
                echo "all_passed=true" >> $GITHUB_OUTPUT
                exit 0
              fi

              # Show PR details periodically
              if [ $((NO_CHECK_COUNT % 3)) -eq 0 ]; then
                echo "PR State:"
                gh pr view $PR_NUMBER --json state,mergeable,draft | jq '.'
              fi

              echo "Waiting ${SLEEP_INTERVAL}s for checks to start..."
              sleep $SLEEP_INTERVAL
              WAIT_TIME=$((WAIT_TIME + SLEEP_INTERVAL))
              continue
            fi

            # Reset no-check counter since we found checks
            NO_CHECK_COUNT=0

            # Display all checks (excluding Vercel explicitly)
            echo "Available checks:"
            echo "$PR_CHECKS" | jq -r '.[] | select(.name | test("Vercel") | not) | "  • \(.name): \(.status) [\(.conclusion // "pending")]"' | sort

            # Also show Vercel separately if it exists
            VERCEL_CHECK=$(echo "$PR_CHECKS" | jq -r '.[] | select(.name | test("Vercel")) | "  • [IGNORED] \(.name): \(.status) [\(.conclusion // "pending")]"' | head -1)
            if [ -n "$VERCEL_CHECK" ]; then
              echo ""
              echo "Ignored checks:"
              echo "$VERCEL_CHECK"
            fi

            echo ""
            echo "Checking required tests..."

            # Track statuses
            declare -A TEST_RESULTS
            ALL_FOUND=true
            ALL_PASSED=true
            ANY_FAILED=false
            ANY_PENDING=false

            # Check each required test
            for test_key in "${!REQUIRED_TESTS[@]}"; do
              pattern="${REQUIRED_TESTS[$test_key]}"

              # Find matching check (case-insensitive, exclude Vercel)
              MATCHING_CHECK=$(echo "$PR_CHECKS" | jq -r --arg pattern "$pattern" '
                .[] |
                select(.name | test("Vercel") | not) |
                select(.name | test($pattern; "i")) |
                "\(.name)|\(.status)|\(.conclusion // "pending")"
              ' | head -1)

              if [ -z "$MATCHING_CHECK" ]; then
                echo "  ❓ $test_key: NOT FOUND (waiting...)"
                TEST_RESULTS[$test_key]="not_found"
                ALL_FOUND=false
                ALL_PASSED=false
              else
                CHECK_NAME=$(echo "$MATCHING_CHECK" | cut -d'|' -f1)
                STATUS=$(echo "$MATCHING_CHECK" | cut -d'|' -f2)
                CONCLUSION=$(echo "$MATCHING_CHECK" | cut -d'|' -f3)

                case "$STATUS" in
                  "COMPLETED"|"completed")
                    case "$CONCLUSION" in
                      "SUCCESS"|"success")
                        echo "  ✅ $test_key: PASSED"
                        TEST_RESULTS[$test_key]="passed"
                        ;;
                      "SKIPPED"|"skipped")
                        echo "  ⏭️  $test_key: SKIPPED (treated as pass)"
                        TEST_RESULTS[$test_key]="passed"
                        ;;
                      "FAILURE"|"failure")
                        echo "  ❌ $test_key: FAILED"
                        TEST_RESULTS[$test_key]="failed"
                        ANY_FAILED=true
                        ALL_PASSED=false
                        ;;
                      *)
                        echo "  ⚠️  $test_key: UNKNOWN CONCLUSION: $CONCLUSION"
                        TEST_RESULTS[$test_key]="failed"
                        ANY_FAILED=true
                        ALL_PASSED=false
                        ;;
                    esac
                    ;;
                  *)
                    echo "  ⏳ $test_key: RUNNING"
                    TEST_RESULTS[$test_key]="running"
                    ANY_PENDING=true
                    ALL_PASSED=false
                    ;;
                esac
              fi
            done

            echo ""
            echo "Decision:"

            # Make decision
            if [ "$ANY_FAILED" = true ]; then
              echo "❌ FAILED: One or more required tests failed"
              echo "all_passed=false" >> $GITHUB_OUTPUT
              exit 0
            fi

            if [ "$ALL_FOUND" = true ] && [ "$ALL_PASSED" = true ]; then
              echo "✅ SUCCESS: All required tests passed!"
              echo "all_passed=true" >> $GITHUB_OUTPUT
              exit 0
            fi

            if [ "$ANY_PENDING" = true ] || [ "$ALL_FOUND" = false ]; then
              PENDING_COUNT=0
              NOT_FOUND_COUNT=0
              for test_key in "${!TEST_RESULTS[@]}"; do
                if [ "${TEST_RESULTS[$test_key]}" = "running" ]; then
                  PENDING_COUNT=$((PENDING_COUNT + 1))
                elif [ "${TEST_RESULTS[$test_key]}" = "not_found" ]; then
                  NOT_FOUND_COUNT=$((NOT_FOUND_COUNT + 1))
                fi
              done

              echo "⏳ WAITING: $PENDING_COUNT running, $NOT_FOUND_COUNT not started"
            fi

            echo "Next check in ${SLEEP_INTERVAL}s..."
            sleep $SLEEP_INTERVAL
            WAIT_TIME=$((WAIT_TIME + SLEEP_INTERVAL))
          done

          # Timeout reached
          echo ""
          echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
          echo "⏰ TIMEOUT after ${MAX_WAIT}s"
          echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
          echo "Tests did not complete in time. Failing the workflow."

          echo "all_passed=false" >> $GITHUB_OUTPUT
        env:
          GH_TOKEN: ${{ steps.app-token.outputs.token }}

  merge-to-main:
    needs: update-and-verify
    if: needs.update-and-verify.outputs.should_skip != 'true' && needs.update-and-verify.outputs.tests_passed == 'true'
    runs-on: ubuntu-latest
    steps:
      - name: Generate GitHub App Token
        id: app-token
        uses: actions/create-github-app-token@v1
        with:
          app-id: ${{ secrets.NOTIFIER_APP_ID }}
          private-key: ${{ secrets.NOTIFIER_PRIVATE_KEY }}

      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ steps.app-token.outputs.token }}
          submodules: true
          fetch-depth: 0

      - name: Merge PR to main
        run: |
          TEMP_BRANCH="auto-update-submodule-${{ needs.update-and-verify.outputs.new_sha }}"

          # Find and merge the PR
          PR_NUMBER=$(gh pr list --head $TEMP_BRANCH --json number --jq '.[0].number')
          echo "Found PR #$PR_NUMBER for branch $TEMP_BRANCH"

          # Merge the PR
          gh pr merge $PR_NUMBER --squash --delete-branch --body "All tests passed successfully:
          ✅ End-to-End Tests
          ✅ Cloud API Stability Tests
          ✅ Web Lint and Unit Tests
          ✅ Cloud API Integration Tests
          ✅ Web Migration API Stability Tests

          Updated from ${{ needs.update-and-verify.outputs.old_sha }} to ${{ needs.update-and-verify.outputs.new_sha }}"
        env:
          GH_TOKEN: ${{ steps.app-token.outputs.token }}

  cleanup-on-failure:
    needs: update-and-verify
    if: needs.update-and-verify.outputs.should_skip != 'true' && needs.update-and-verify.outputs.tests_passed != 'true'
    runs-on: ubuntu-latest
    steps:
      - name: Generate GitHub App Token
        id: app-token
        uses: actions/create-github-app-token@v1
        with:
          app-id: ${{ secrets.NOTIFIER_APP_ID }}
          private-key: ${{ secrets.NOTIFIER_PRIVATE_KEY }}

      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ steps.app-token.outputs.token }}
          submodules: true

      - name: Close PR and clean up
        run: |
          TEMP_BRANCH="auto-update-submodule-${{ needs.update-and-verify.outputs.new_sha }}"

          # Find and close the PR
          PR_NUMBER=$(gh pr list --head $TEMP_BRANCH --json number --jq '.[0].number')
          if [ "$PR_NUMBER" != "null" ] && [ -n "$PR_NUMBER" ]; then
            echo "Closing PR #$PR_NUMBER for failed tests"
            gh pr close $PR_NUMBER --comment "🚨 Closing this PR because tests failed or timed out.

            Failed to update from ${{ needs.update-and-verify.outputs.old_sha }} to ${{ needs.update-and-verify.outputs.new_sha }}

            Please check the test results and update manually if needed."

            # Delete the branch
            git push origin --delete $TEMP_BRANCH || true
          else
            echo "No PR found to close"
            git push origin --delete $TEMP_BRANCH || true
          fi

          echo "🚨 Submodule update failed - tests did not pass"
        env:
          GH_TOKEN: ${{ steps.app-token.outputs.token }}
