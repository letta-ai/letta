---
title: Long-Running Executions
slug: guides/agents/long-running
subtitle: How to handle long-running agent executions
---

For agents that may take a long time to complete their response due to many chained tool calls (for example, a deep research agent), we recommended two approaches:

## Option 1: Use Async SDK with Polling

For truly long-running operations, use the [async SDK method](/api-reference/agents/messages/create-async) which returns immediately and allows you to poll for results:

<CodeGroup>
```curl curl
# Create async message (returns immediately with run ID)
curl --request POST \
  --url http://localhost:8283/v1/agents/$AGENT_ID/messages/async \
  --header 'Content-Type: application/json' \
  --data '{
  "messages": [
    {
      "role": "user",
      "content": "Run comprehensive analysis on this dataset"
    }
  ]
}'

# Poll for results using the returned run ID
curl --request GET \
  --url http://localhost:8283/v1/runs/$RUN_ID
```
```python title="python" maxLines=50
# Use create_async for long-running operations
run = client.agents.messages.create_async(
    agent_id=agent_state.id,
    messages=[
      {
        "role": "user",
        "content": "Run comprehensive analysis on this dataset"
      }
    ],
)

# Poll for completion
import time
while run.status != "completed":
    time.sleep(2)
    run = client.runs.retrieve(run_id=run.id)

# Get the messages once complete
messages = client.runs.messages.list(run_id=run.id)
```
```typescript maxLines=50 title="node.js"
// Use createAgentMessageAsync for long-running operations
const run = await client.agents.createAgentMessageAsync({
    agentId: agentState.id,
    requestBody: {
        messages: [
            {
                role: "user",
                content: "Run comprehensive analysis on this dataset"
            }
        ]
    }
});

// Poll for completion
while (run.status !== "completed") {
    await new Promise(resolve => setTimeout(resolve, 2000));
    run = await client.runs.retrieveRun({ runId: run.id });
}

// Get the messages once complete
const messages = await client.runs.listRunMessages({ runId: run.id });
```
</CodeGroup>

## Option 2: Configure Streaming with Keepalive Pings and Longer Timeouts

Alternatively, you can configure certain parameters on the POST SSE streaming request to prevent connection timeouts:

<CodeGroup>
```curl curl
curl --request POST \
  --url http://localhost:8283/v1/agents/$AGENT_ID/messages/stream \
  --header 'Content-Type: application/json' \
  --data '{
  "messages": [
    {
      "role": "user",
      "content": "Execute this long-running analysis"
    }
  ],
  "include_pings": true
}'
```
```python title="python" maxLines=50
# Configure client with longer timeout (default is 60 seconds)
from letta_client import Letta

client = Letta(
    base_url="http://localhost:8283",
)

# Enable pings to prevent timeout during long operations
stream = client.agents.messages.create_stream(
    agent_id=agent_state.id,
    messages=[
      {
        "role": "user",
        "content": "Execute this long-running analysis"
      }
    ],
    include_pings=True,  # Sends periodic keepalive messages
    request_options={"timeout_in_seconds": 600}  # 10 min timeout
)

# Process the stream (pings will keep connection alive)
for chunk in stream:
    if chunk.message_type == "ping":
        # Keepalive ping received, connection is still active
        continue
    print(chunk)
```
```typescript maxLines=50 title="node.js"
// Configure client with longer timeout (default is 60 seconds)
import { Letta } from '@letta/sdk';

const client = new Letta({
    baseUrl: 'http://localhost:8283',
});

// Enable pings to prevent timeout during long operations
const stream = await client.agents.createAgentMessageStream({
    agentId: agentState.id,
    requestBody: {
        messages: [
            {
                role: "user",
                content: "Execute this long-running analysis"
            }
        ],
        includePings: true  // Sends periodic keepalive messages
    }, {
        timeoutInSeconds: 600  // 10 minutes timeout in seconds
    }
});

// Process the stream (pings will keep connection alive)
for await (const chunk of stream) {
    if (chunk.message_type === "ping") {
        // Keepalive ping received, connection is still active
        continue;
    }
    console.log(chunk);
}
```
</CodeGroup>

The combination of a longer timeout and the `include_pings` flag ensures robust handling of long-running operations:
- **Timeout**: Extends the overall request timeout (default is 60 seconds). Set this based on your expected maximum operation time.
- **Include Pings**: Sends periodic keepalive messages to prevent the connection from being dropped due to inactivity, even if the agent takes a long time between outputs (e.g., when running complex tools or waiting for external services).

For very long-running tasks (e.g. user inputs that trigger 10+ minutes of agent steps), we highly recommend using the async SDK methods for increased reliability.
