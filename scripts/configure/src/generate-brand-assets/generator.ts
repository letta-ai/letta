import type { Tree } from '@nx/devkit';
import { generateFiles } from '@nx/devkit';
import { workspaceRoot, formatFiles } from '@nx/devkit';
import { startCase } from 'lodash';
import * as fs from 'fs';
import * as path from 'path';
import { copyFile } from '@nx/workspace';

function generateIndexFile(brandKeys: string[]) {
  const exports = brandKeys.map((brand) => `export * from './${brand}';`).join('\n')
  const keys = `export type BrandKeys =${brandKeys.map(brand => `\t| '${brand}'`).join('\n')}`

  return `${exports}\n${keys}`
}

function generateIconFile(name: string, svgContent: string) {
  return `import * as React from 'react';
import type { IconWrappedProps} from '../../../icons/IconWrapper';
import { IconWrapper } from '../../../icons/IconWrapper';

export function ${name}(props: IconWrappedProps) {
  return (<IconWrapper {...props}>${svgContent}</IconWrapper>);
}
`;
}


function generateDynamicLockupFile(name: string, svgContent: string) {
  return `import * as React from 'react';

interface ${name}Props {
  width?: string;
  height?: string;
  className?: string;
}

export function ${name}(props: ${name}Props) {
  return (
    <div
      className={props.className}
      style={{
        width: props.width,
        height: props.height
      }}
    >
      ${svgContent}
    </div>
  );
}
`;
}




const sourcePath =  path.join(workspaceRoot, 'libs/ui-component-library/src/lib/brands/sources');
const outputPath = path.join('libs/ui-component-library/src/lib/brands/_autogenerated');

export async function generateIconsGenerator(
  tree: Tree,
) {
  const brandsToGenerate = fs.readdirSync(
    sourcePath
  );

  const brandKeys: string[] = []

  brandsToGenerate.forEach((brandKey) => {


    try {
      const files = fs.readdirSync(
        path.join(sourcePath, brandKey)
      )

      brandKeys.push(brandKey);


      const logoMarkFilePath = files.find(fileName => fileName.split('.')[0] === 'logomark');
      const logoMarkLockupFilePath = files.find(fileName => fileName.split('.')[0] === 'lockup');
      const dynamicFile = files.find(fileName => fileName.split('.')[0] === 'logomark-dynamic');
      const lockupDynamicFile = files.find(fileName => fileName.split('.')[0] === 'lockup-dynamic');

      // make directory if does not exist
      if (!fs.existsSync(path.join(outputPath, brandKey))) {
        fs.mkdirSync(path.join(outputPath, brandKey))
      }

      const componentName = startCase(brandKey).replace(/ /g, '');

      generateFiles(
        tree,
        path.join(__dirname, 'files'),
        path.join(outputPath),
        {
          brandKey,
          name: componentName,
          logoMarkFilePath,
          logoMarkLockupFilePath,
        }
      );


      const dynamicFileCode = dynamicFile ? fs.readFileSync(path.join(sourcePath, brandKey, dynamicFile), 'utf-8') : '<div />'

      tree.write(
        path.join(outputPath, brandKey, `${componentName}LogoMarkDynamic.tsx`),
        generateIconFile(`${componentName}LogoMarkDynamic`,dynamicFileCode)
          .replace(/[A-z](-[A-z]+)=/g, x=>x.replace(/-./, y => y[1].toUpperCase()))
      )

      if (lockupDynamicFile) {
        const lockupDynamicFileCode = fs.readFileSync(path.join(sourcePath, brandKey, lockupDynamicFile), 'utf-8');

        tree.write(
          path.join(outputPath, brandKey, `${componentName}LockupDynamic.tsx`),
          generateDynamicLockupFile(`${componentName}LockupDynamic`,lockupDynamicFileCode)
            .replace(/[A-z](-[A-z]+)=/g, x=>x.replace(/-./, y => y[1].toUpperCase()))
        )

        // update index.tsx to include the dynamic lockup component
        const indexFilePath = path.join(outputPath, brandKey, 'index.tsx');

        const indexContent = tree.read(indexFilePath, 'utf-8');
        const newIndexContent = `${indexContent}\nexport * from './${componentName}LockupDynamic';\n`;
        tree.write(indexFilePath, newIndexContent);

      }

      files.forEach(file => {
        copyFile(
          path.join(sourcePath, brandKey, file),
          path.join(outputPath, brandKey),
        )
      })
    } catch (e) {
      console.error(e)
      return;
    }
  });


  tree.write(
    path.join(outputPath, 'index.tsx'),
    generateIndexFile(brandKeys)
  )

  // const indexContent = generateIndexFile(brandsToGenerate);
  //
  // tree.write(
  //   path.join('libs/ui-component-library/src/lib/icons/index.ts'),
  //   indexContent
  // );

  await formatFiles(tree);
}

export default generateIconsGenerator;
